

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Sparse Linear Equations &mdash; CVXOPT User&#39;s Guide</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
        <link rel="search" title="Search" href="search.html"/>
        <link rel="copyright" title="Copyright" href="copyright.html"/>
    <link rel="top" title="CVXOPT User&#39;s Guide" href="index.html"/>
        <link rel="next" title="Cone Programming" href="coneprog.html"/>
        <link rel="prev" title="Discrete Transforms" href="fftw.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="index.html" class="fa fa-home"> CVXOPT User's Guide</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="copyright.html">Copyright and License</a></li>
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrices.html">Dense and Sparse Matrices</a><ul>
<li class="toctree-l2"><a class="reference internal" href="matrices.html#dense-matrices">Dense Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="matrices.html#sparse-matrices">Sparse Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="matrices.html#arithmetic-operations">Arithmetic Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="matrices.html#indexing-and-slicing">Indexing and Slicing</a></li>
<li class="toctree-l2"><a class="reference internal" href="matrices.html#attributes-and-methods">Attributes and Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="matrices.html#built-in-functions">Built-In Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="matrices.html#other-matrix-functions">Other Matrix Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="matrices.html#randomly-generated-matrices">Randomly Generated Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="blas.html">The BLAS Interface</a><ul>
<li class="toctree-l2"><a class="reference internal" href="blas.html#matrix-classes">Matrix Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="blas.html#level-1-blas">Level 1 BLAS</a></li>
<li class="toctree-l2"><a class="reference internal" href="blas.html#level-2-blas">Level 2 BLAS</a></li>
<li class="toctree-l2"><a class="reference internal" href="blas.html#level-3-blas">Level 3 BLAS</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="lapack.html">The LAPACK Interface</a><ul>
<li class="toctree-l2"><a class="reference internal" href="lapack.html#general-linear-equations">General Linear Equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="lapack.html#positive-definite-linear-equations">Positive Definite Linear Equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="lapack.html#symmetric-and-hermitian-linear-equations">Symmetric and Hermitian Linear Equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="lapack.html#triangular-linear-equations">Triangular Linear Equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="lapack.html#least-squares-and-least-norm-problems">Least-Squares and Least-Norm Problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="lapack.html#symmetric-and-hermitian-eigenvalue-decomposition">Symmetric and Hermitian Eigenvalue Decomposition</a></li>
<li class="toctree-l2"><a class="reference internal" href="lapack.html#generalized-symmetric-definite-eigenproblems">Generalized Symmetric Definite Eigenproblems</a></li>
<li class="toctree-l2"><a class="reference internal" href="lapack.html#singular-value-decomposition">Singular Value Decomposition</a></li>
<li class="toctree-l2"><a class="reference internal" href="lapack.html#schur-and-generalized-schur-factorization">Schur and Generalized Schur Factorization</a></li>
<li class="toctree-l2"><a class="reference internal" href="lapack.html#example-analytic-centering">Example: Analytic Centering</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="fftw.html">Discrete Transforms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="fftw.html#discrete-fourier-transform">Discrete Fourier Transform</a></li>
<li class="toctree-l2"><a class="reference internal" href="fftw.html#discrete-cosine-transform">Discrete Cosine Transform</a></li>
<li class="toctree-l2"><a class="reference internal" href="fftw.html#discrete-sine-transform">Discrete Sine Transform</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Sparse Linear Equations</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#matrix-orderings">Matrix Orderings</a></li>
<li class="toctree-l2"><a class="reference internal" href="#general-linear-equations">General Linear Equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#positive-definite-linear-equations">Positive Definite Linear Equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example-covariance-selection">Example: Covariance Selection</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="coneprog.html">Cone Programming</a><ul>
<li class="toctree-l2"><a class="reference internal" href="coneprog.html#linear-cone-programs">Linear Cone Programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="coneprog.html#quadratic-cone-programs">Quadratic Cone Programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="coneprog.html#linear-programming">Linear Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="coneprog.html#quadratic-programming">Quadratic Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="coneprog.html#second-order-cone-programming">Second-Order Cone Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="coneprog.html#semidefinite-programming">Semidefinite Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="coneprog.html#exploiting-structure">Exploiting Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="coneprog.html#optional-solvers">Optional Solvers</a></li>
<li class="toctree-l2"><a class="reference internal" href="coneprog.html#algorithm-parameters">Algorithm Parameters</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="solvers.html">Nonlinear Convex Optimization</a><ul>
<li class="toctree-l2"><a class="reference internal" href="solvers.html#problems-with-nonlinear-objectives">Problems with Nonlinear Objectives</a></li>
<li class="toctree-l2"><a class="reference internal" href="solvers.html#problems-with-linear-objectives">Problems with Linear Objectives</a></li>
<li class="toctree-l2"><a class="reference internal" href="solvers.html#geometric-programming">Geometric Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="solvers.html#exploiting-structure">Exploiting Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="solvers.html#algorithm-parameters">Algorithm Parameters</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="modeling.html">Modeling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="modeling.html#variables">Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="modeling.html#functions">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="modeling.html#constraints">Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="modeling.html#optimization-problems">Optimization Problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="modeling.html#examples">Examples</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="c-api.html">C API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="c-api.html#dense-matrices">Dense Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="c-api.html#sparse-matrices">Sparse Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="printing.html">Matrix Formatting</a></li>
<li class="toctree-l1"><a class="reference external" href="http://cvxopt.org">cvxopt.org</a></li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">CVXOPT User's Guide</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Sparse Linear Equations</li>
      <li class="wy-breadcrumbs-aside">
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            
  <div class="section" id="sparse-linear-equations">
<span id="c-spsolvers"></span><h1>Sparse Linear Equations<a class="headerlink" href="#sparse-linear-equations" title="Permalink to this headline">¶</a></h1>
<p>In this section we describe routines for solving sparse sets of linear
equations.</p>
<p>A real symmetric or complex Hermitian sparse matrix is stored as an
<a class="reference internal" href="matrices.html#cvxopt.spmatrix" title="cvxopt.spmatrix"><code class="xref py py-class docutils literal notranslate"><span class="pre">spmatrix</span></code></a> object <code class="docutils literal notranslate"><span class="pre">X</span></code>  of size
(<img class="math" src="_images/math/e11f2701c4a39c7fe543a6c4150b421d50f1c159.png" alt="n"/>, <img class="math" src="_images/math/e11f2701c4a39c7fe543a6c4150b421d50f1c159.png" alt="n"/>) and an
additional character argument <code class="docutils literal notranslate"><span class="pre">uplo</span></code> with possible values <code class="xref py py-const docutils literal notranslate"><span class="pre">'L'</span></code>
and <code class="xref py py-const docutils literal notranslate"><span class="pre">'U'</span></code>.  If <code class="docutils literal notranslate"><span class="pre">uplo</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'L'</span></code>, the lower triangular part
of <code class="docutils literal notranslate"><span class="pre">X</span></code> contains the lower triangular part of the symmetric or Hermitian
matrix, and the upper triangular matrix of <code class="docutils literal notranslate"><span class="pre">X</span></code> is ignored.  If <code class="docutils literal notranslate"><span class="pre">uplo</span></code>
is <code class="xref py py-const docutils literal notranslate"><span class="pre">'U'</span></code>, the upper triangular part of <code class="docutils literal notranslate"><span class="pre">X</span></code> contains the upper
triangular part of the matrix, and the lower triangular matrix of <code class="docutils literal notranslate"><span class="pre">X</span></code> is
ignored.</p>
<p>A general sparse square matrix of order <img class="math" src="_images/math/e11f2701c4a39c7fe543a6c4150b421d50f1c159.png" alt="n"/> is represented by an
<code class="xref py py-class docutils literal notranslate"><span class="pre">spmatrix</span></code> object of size (<img class="math" src="_images/math/e11f2701c4a39c7fe543a6c4150b421d50f1c159.png" alt="n"/>, <img class="math" src="_images/math/e11f2701c4a39c7fe543a6c4150b421d50f1c159.png" alt="n"/>).</p>
<p>Dense matrices, which appear as right-hand sides of equations, are
stored using the same conventions as in the BLAS and LAPACK modules.</p>
<div class="section" id="matrix-orderings">
<span id="s-orderings"></span><h2>Matrix Orderings<a class="headerlink" href="#matrix-orderings" title="Permalink to this headline">¶</a></h2>
<p>CVXOPT includes an interface to the AMD library for computing approximate
minimum degree orderings of sparse matrices.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li>P. R. Amestoy, T. A. Davis, I. S. Duff,  Algorithm 837: AMD, An
Approximate Minimum Degree Ordering Algorithm, ACM Transactions on
Mathematical Software, 30(3), 381-388, 2004.</li>
</ul>
</div>
<dl class="function">
<dt id="cvxopt.amd.order">
<code class="descclassname">cvxopt.amd.</code><code class="descname">order</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.amd.order" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the approximate mimimum degree ordering of a symmetric  sparse
matrix <img class="math" src="_images/math/0043fe6507e9b1d112e07a2801e24927e267dd50.png" alt="A"/>.  The ordering is returned as an integer dense matrix
with length equal to the order of <img class="math" src="_images/math/0043fe6507e9b1d112e07a2801e24927e267dd50.png" alt="A"/>.  Its entries specify a
permutation that reduces fill-in during the Cholesky factorization.
More precisely, if <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">order(A)</span></code> , then <code class="docutils literal notranslate"><span class="pre">A[p,</span> <span class="pre">p]</span></code> has
sparser Cholesky factors than <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
</dd></dl>

<p>As an example we consider the matrix</p>
<div class="math">
<p><img src="_images/math/e889033c88d6e990944a43933c03add058e92546.png" alt="\left[ \begin{array}{rrrr}
 10 &amp;  0 &amp; 3 &amp;  0 \\
  0 &amp;  5 &amp; 0 &amp; -2 \\
  3 &amp;  0 &amp; 5 &amp;  0 \\
  0 &amp; -2 &amp; 0 &amp;  2
\end{array}\right]."/></p>
</div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="k">import</span> <span class="n">spmatrix</span><span class="p">,</span> <span class="n">amd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">amd</span><span class="o">.</span><span class="n">order</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="go">[ 1]</span>
<span class="go">[ 0]</span>
<span class="go">[ 2]</span>
<span class="go">[ 3]</span>
</pre></div>
</div>
</div>
<div class="section" id="general-linear-equations">
<span id="s-umfpack"></span><h2>General Linear Equations<a class="headerlink" href="#general-linear-equations" title="Permalink to this headline">¶</a></h2>
<p>The module <code class="xref py py-mod docutils literal notranslate"><span class="pre">cvxopt.umfpack</span></code> includes four functions for solving
sparse non-symmetric sets of linear equations.  They call routines from
the UMFPACK library, with all control options set to the default values
described in the UMFPACK user guide.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li>T. A. Davis, Algorithm 832: UMFPACK – an unsymmetric-pattern
multifrontal method with a column pre-ordering strategy, ACM
Transactions on Mathematical Software, 30(2), 196-199, 2004.</li>
</ul>
</div>
<dl class="function">
<dt id="cvxopt.umfpack.linsolve">
<code class="descclassname">cvxopt.umfpack.</code><code class="descname">linsolve</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="optional">[</span>, <em>trans = 'N'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.umfpack.linsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a sparse set of linear equations</p>
<div class="math">
<p><img src="_images/math/aee0706bd00f21b4a276d87252aec9d4af767404.png" alt="AX &amp; = B \quad (\mathrm{trans} = \mathrm{'N'}), \\
A^TX &amp; = B \quad (\mathrm{trans} = \mathrm{'T'}), \\
A^HX &amp; = B \quad (\mathrm{trans} = \mathrm{'C'}),"/></p>
</div><p>where <img class="math" src="_images/math/0043fe6507e9b1d112e07a2801e24927e267dd50.png" alt="A"/> is a sparse matrix and <img class="math" src="_images/math/9805f44feec6f81d376d09e88b8236635edbb3c8.png" alt="B"/> is a dense matrix.
The arguments <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> must have the same type
(<code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> or <code class="xref py py-const docutils literal notranslate"><span class="pre">'z'</span></code>) as <code class="docutils literal notranslate"><span class="pre">A</span></code>.  On exit <code class="docutils literal notranslate"><span class="pre">B</span></code> contains
the solution.  Raises an <code class="xref py py-exc docutils literal notranslate"><span class="pre">ArithmeticError</span></code> if the coefficient
matrix is singular.</p>
</dd></dl>

<p>In the following example we solve an equation with coefficient matrix</p>
<div class="math" id="equation-e-sp-adef">
<p><span class="eqno">(1)<a class="headerlink" href="#equation-e-sp-adef" title="Permalink to this equation">¶</a></span><img src="_images/math/3efbb02413dbe3ace070038d8b70910f87001efc.png" alt="A = \left[\begin{array}{rrrrr}
    2 &amp; 3 &amp; 0 &amp; 0 &amp; 0 \\
    3 &amp; 0 &amp; 4 &amp; 0 &amp; 6 \\
    0 &amp;-1 &amp;-3 &amp; 2 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 4 &amp; 2 &amp; 0 &amp; 1
    \end{array}\right]."/></p>
</div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="k">import</span> <span class="n">spmatrix</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">umfpack</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">V</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">J</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">J</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">umfpack</span><span class="o">.</span><span class="n">linsolve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">[ 5.79e-01]</span>
<span class="go">[-5.26e-02]</span>
<span class="go">[ 1.00e+00]</span>
<span class="go">[ 1.97e+00]</span>
<span class="go">[-7.89e-01]</span>
</pre></div>
</div>
<p>The function <a class="reference internal" href="#cvxopt.umfpack.linsolve" title="cvxopt.umfpack.linsolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">linsolve</span></code></a>  is
equivalent to the following three functions called in sequence.</p>
<dl class="function">
<dt id="cvxopt.umfpack.symbolic">
<code class="descclassname">cvxopt.umfpack.</code><code class="descname">symbolic</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.umfpack.symbolic" title="Permalink to this definition">¶</a></dt>
<dd><p>Reorders the columns of <code class="docutils literal notranslate"><span class="pre">A</span></code> to reduce fill-in and performs a symbolic
LU factorization.  <code class="docutils literal notranslate"><span class="pre">A</span></code> is a sparse, possibly rectangular, matrix.
Returns the symbolic factorization as an opaque C object that can be
passed on to <a class="reference internal" href="#cvxopt.umfpack.numeric" title="cvxopt.umfpack.numeric"><code class="xref py py-func docutils literal notranslate"><span class="pre">numeric</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.umfpack.numeric">
<code class="descclassname">cvxopt.umfpack.</code><code class="descname">numeric</code><span class="sig-paren">(</span><em>A</em>, <em>F</em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.umfpack.numeric" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a numeric LU factorization of a sparse, possibly rectangular,
matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>.   The argument <code class="docutils literal notranslate"><span class="pre">F</span></code> is the symbolic factorization
computed by <a class="reference internal" href="#cvxopt.umfpack.symbolic" title="cvxopt.umfpack.symbolic"><code class="xref py py-func docutils literal notranslate"><span class="pre">symbolic</span></code></a>
applied to the matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>,
or another sparse matrix with the same sparsity pattern, dimensions,
and type.  The numeric factorization is returned as an opaque C object
that that can be passed on to
<a class="reference internal" href="#cvxopt.umfpack.solve" title="cvxopt.umfpack.solve"><code class="xref py py-func docutils literal notranslate"><span class="pre">solve</span></code></a>.  Raises an
<code class="xref py py-exc docutils literal notranslate"><span class="pre">ArithmeticError</span></code> if the matrix is singular.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.umfpack.solve">
<code class="descclassname">cvxopt.umfpack.</code><code class="descname">solve</code><span class="sig-paren">(</span><em>A</em>, <em>F</em>, <em>B</em><span class="optional">[</span>, <em>trans = 'N'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.umfpack.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a set of linear equations</p>
<div class="math">
<p><img src="_images/math/aee0706bd00f21b4a276d87252aec9d4af767404.png" alt="AX &amp; = B \quad (\mathrm{trans} = \mathrm{'N'}), \\
A^TX &amp; = B \quad (\mathrm{trans} = \mathrm{'T'}), \\
A^HX &amp; = B \quad (\mathrm{trans} = \mathrm{'C'}),"/></p>
</div><p>where <img class="math" src="_images/math/0043fe6507e9b1d112e07a2801e24927e267dd50.png" alt="A"/> is a sparse matrix and <img class="math" src="_images/math/9805f44feec6f81d376d09e88b8236635edbb3c8.png" alt="B"/> is a dense matrix.
The arguments <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> must have the same type.  The argument
<code class="docutils literal notranslate"><span class="pre">F</span></code> is a numeric factorization computed
by <a class="reference internal" href="#cvxopt.umfpack.numeric" title="cvxopt.umfpack.numeric"><code class="xref py py-func docutils literal notranslate"><span class="pre">numeric</span></code></a>.
On exit <code class="docutils literal notranslate"><span class="pre">B</span></code> is overwritten by the
solution.</p>
</dd></dl>

<p>These separate functions are useful for solving several sets of linear
equations with the same coefficient matrix and different right-hand sides,
or with coefficient matrices that share the same sparsity pattern.
The symbolic factorization depends only on the sparsity pattern of
the matrix, and not on the numerical values of the nonzero coefficients.
The numerical factorization on the other hand depends on the sparsity
pattern of the matrix and on its the numerical values.</p>
<p>As an example, suppose <img class="math" src="_images/math/0043fe6507e9b1d112e07a2801e24927e267dd50.png" alt="A"/> is the matrix <a class="reference internal" href="#equation-e-sp-adef">(1)</a> and</p>
<div class="math">
<p><img src="_images/math/46223c63c5cb3a98d23d5a2c39fc4a92d7bdd0b0.png" alt="B = \left[\begin{array}{rrrrr}
    4 &amp; 3 &amp; 0 &amp; 0 &amp; 0 \\
    3 &amp; 0 &amp; 4 &amp; 0 &amp; 6 \\
    0 &amp;-1 &amp;-3 &amp; 2 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 4 &amp; 2 &amp; 0 &amp; 2
    \end{array}\right],"/></p>
</div><p>which differs from <img class="math" src="_images/math/0043fe6507e9b1d112e07a2801e24927e267dd50.png" alt="A"/> in its first and last entries.  The following
code computes</p>
<div class="math">
<p><img src="_images/math/4555f864257035da7942169592454d5b8d3405f8.png" alt="\newcommand{\ones}{\mathbf 1}
x = A^{-T}B^{-1}A^{-1}\ones."/></p>
</div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="k">import</span> <span class="n">spmatrix</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">umfpack</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">VA</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">VB</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span>  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">J</span> <span class="o">=</span>  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">(</span><span class="n">VA</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">(</span><span class="n">VB</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Fs</span> <span class="o">=</span> <span class="n">umfpack</span><span class="o">.</span><span class="n">symbolic</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">FA</span> <span class="o">=</span> <span class="n">umfpack</span><span class="o">.</span><span class="n">numeric</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">Fs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">FB</span> <span class="o">=</span> <span class="n">umfpack</span><span class="o">.</span><span class="n">numeric</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">Fs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">umfpack</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">FA</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">umfpack</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">FB</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">umfpack</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">FA</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">trans</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[ 5.81e-01]</span>
<span class="go">[-2.37e-01]</span>
<span class="go">[ 1.63e+00]</span>
<span class="go">[ 8.07e+00]</span>
<span class="go">[-1.31e-01]</span>
</pre></div>
</div>
</div>
<div class="section" id="positive-definite-linear-equations">
<span id="s-cholmod"></span><h2>Positive Definite Linear Equations<a class="headerlink" href="#positive-definite-linear-equations" title="Permalink to this headline">¶</a></h2>
<p><code class="xref py py-mod docutils literal notranslate"><span class="pre">cvxopt.cholmod</span></code> is an interface to the Cholesky factorization routines
of the CHOLMOD package.  It includes functions for Cholesky factorization
of sparse positive definite matrices, and for solving sparse sets of linear
equations with positive definite matrices.
The routines can also be used for computing
<span class="raw-html">LDL<sup><small>T</small></sup></span>
(or
<span class="raw-html">LDL<sup><small>H</small></sup></span>
factorizations
of symmetric indefinite matrices (with <img class="math" src="_images/math/ae2b750f71e1fc0daaa3de9a85d42794d7cd1326.png" alt="L"/> unit lower-triangular and
<img class="math" src="_images/math/3cf5aa5abe312e6fd4996975341a43aa566e8d8d.png" alt="D"/> diagonal and nonsingular) if such a factorization exists.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li>Y. Chen, T. A. Davis, W. W. Hager, S. Rajamanickam,
Algorithm 887: CHOLMOD, Supernodal Sparse Cholesky Factorization
and Update/Downdate, ACM Transactions on Mathematical Software,
35(3), 22:1-22:14, 2008.</li>
</ul>
</div>
<dl class="function">
<dt id="cvxopt.cholmod.linsolve">
<code class="descclassname">cvxopt.cholmod.</code><code class="descname">linsolve</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="optional">[</span>, <em>p = None</em>, <em>uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.cholmod.linsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves</p>
<div class="math">
<p><img src="_images/math/59427484d9e039d9ed1ca3acc9158de7bf228f8c.png" alt="AX = B"/></p>
</div><p>with <img class="math" src="_images/math/0043fe6507e9b1d112e07a2801e24927e267dd50.png" alt="A"/> sparse and real symmetric or complex Hermitian.</p>
<p><code class="docutils literal notranslate"><span class="pre">B</span></code> is a dense matrix of the same type as <code class="docutils literal notranslate"><span class="pre">A</span></code>.  On exit it
is overwritten with the solution.  The argument <code class="docutils literal notranslate"><span class="pre">p</span></code> is an integer
matrix with length equal to the order of <img class="math" src="_images/math/0043fe6507e9b1d112e07a2801e24927e267dd50.png" alt="A"/>, and specifies an
optional reordering.
See the comment on
<code class="xref py py-attr docutils literal notranslate"><span class="pre">options['nmethods']</span></code> for details on which ordering is used
by CHOLMOD.</p>
<p>Raises an <code class="xref py py-exc docutils literal notranslate"><span class="pre">ArithmeticError</span></code> if the factorization does not exist.</p>
</dd></dl>

<p>As an  example, we solve</p>
<div class="math" id="equation-e-a-pd">
<p><span class="eqno">(2)<a class="headerlink" href="#equation-e-a-pd" title="Permalink to this equation">¶</a></span><img src="_images/math/10196df756ffbc52013aef9f1fed403b2c510049.png" alt="\left[ \begin{array}{rrrr}
        10 &amp;  0 &amp; 3 &amp;  0 \\
         0 &amp;  5 &amp; 0 &amp; -2 \\
         3 &amp;  0 &amp; 5 &amp;  0 \\
         0 &amp; -2 &amp; 0 &amp;  2
    \end{array}\right] X =
    \left[ \begin{array}{cc}
         0 &amp; 4 \\ 1 &amp; 5 \\ 2 &amp; 6 \\ 3 &amp; 7
    \end{array} \right]."/></p>
</div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="k">import</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">spmatrix</span><span class="p">,</span> <span class="n">cholmod</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cholmod</span><span class="o">.</span><span class="n">linsolve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">[-1.46e-01  4.88e-02]</span>
<span class="go">[ 1.33e+00  4.00e+00]</span>
<span class="go">[ 4.88e-01  1.17e+00]</span>
<span class="go">[ 2.83e+00  7.50e+00]</span>
</pre></div>
</div>
<dl class="function">
<dt id="cvxopt.cholmod.splinsolve">
<code class="descclassname">cvxopt.cholmod.</code><code class="descname">splinsolve</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="optional">[</span>, <em>p = None</em>, <em>uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.cholmod.splinsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to <a class="reference internal" href="#cvxopt.cholmod.linsolve" title="cvxopt.cholmod.linsolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">linsolve</span></code></a> except that
<code class="docutils literal notranslate"><span class="pre">B</span></code> is an <a class="reference internal" href="matrices.html#cvxopt.spmatrix" title="cvxopt.spmatrix"><code class="xref py py-class docutils literal notranslate"><span class="pre">spmatrix</span></code></a> and
that the solution is returned as an output argument (as a new
<code class="xref py py-class docutils literal notranslate"><span class="pre">spmatrix</span></code>).  <code class="docutils literal notranslate"><span class="pre">B</span></code> is not modified.
See the comment on
<code class="xref py py-attr docutils literal notranslate"><span class="pre">options['nmethods']</span></code> for details on which ordering is used
by CHOLMOD.</p>
</dd></dl>

<p>The following code computes the inverse of the coefficient matrix
in <a class="reference internal" href="#equation-e-a-pd">(2)</a> as a sparse matrix.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">cholmod</span><span class="o">.</span><span class="n">splinsolve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">spmatrix</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">[ 1.22e-01     0     -7.32e-02     0    ]</span>
<span class="go">[    0      3.33e-01     0      3.33e-01]</span>
<span class="go">[-7.32e-02     0      2.44e-01     0    ]</span>
<span class="go">[    0      3.33e-01     0      8.33e-01]</span>
</pre></div>
</div>
<p>The functions <a class="reference internal" href="#cvxopt.cholmod.linsolve" title="cvxopt.cholmod.linsolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">linsolve</span></code></a> and
<a class="reference internal" href="#cvxopt.cholmod.splinsolve" title="cvxopt.cholmod.splinsolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">splinsolve</span></code></a> are equivalent to
<a class="reference internal" href="#cvxopt.cholmod.symbolic" title="cvxopt.cholmod.symbolic"><code class="xref py py-func docutils literal notranslate"><span class="pre">symbolic</span></code></a> and
<a class="reference internal" href="#cvxopt.cholmod.numeric" title="cvxopt.cholmod.numeric"><code class="xref py py-func docutils literal notranslate"><span class="pre">numeric</span></code></a> called in sequence, followed by
<a class="reference internal" href="#cvxopt.cholmod.solve" title="cvxopt.cholmod.solve"><code class="xref py py-func docutils literal notranslate"><span class="pre">solve</span></code></a>, respectively,
<a class="reference internal" href="#cvxopt.cholmod.spsolve" title="cvxopt.cholmod.spsolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">spsolve</span></code></a>.</p>
<dl class="function">
<dt id="cvxopt.cholmod.symbolic">
<code class="descclassname">cvxopt.cholmod.</code><code class="descname">symbolic</code><span class="sig-paren">(</span><em>A</em><span class="optional">[</span>, <em>p = None</em>, <em>uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.cholmod.symbolic" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a symbolic analysis of a sparse real symmetric or
complex Hermitian matrix <img class="math" src="_images/math/0043fe6507e9b1d112e07a2801e24927e267dd50.png" alt="A"/> for one of the two factorizations:</p>
<div class="math" id="equation-e-chol-ll">
<p><span class="eqno">(3)<a class="headerlink" href="#equation-e-chol-ll" title="Permalink to this equation">¶</a></span><img src="_images/math/8028aa7af272108bb6496b539471d80301b0bff7.png" alt="PAP^T = LL^T, \qquad PAP^T = LL^H,"/></p>
</div><p>and</p>
<div class="math" id="equation-e-chol-ldl">
<p><span class="eqno">(4)<a class="headerlink" href="#equation-e-chol-ldl" title="Permalink to this equation">¶</a></span><img src="_images/math/48e50af0d2f7e8baffd74eb1f118505cd4927acc.png" alt="PAP^T = LDL^T, \qquad PAP^T = LDL^H,"/></p>
</div><p>where <img class="math" src="_images/math/9dcbbef8e0f76051d388013b90a95bec3069e484.png" alt="P"/> is a permutation matrix, <img class="math" src="_images/math/ae2b750f71e1fc0daaa3de9a85d42794d7cd1326.png" alt="L"/> is lower triangular
(unit lower triangular in the second factorization), and <img class="math" src="_images/math/3cf5aa5abe312e6fd4996975341a43aa566e8d8d.png" alt="D"/> is
nonsingular diagonal.  The type of factorization depends on the value
of <code class="xref py py-attr docutils literal notranslate"><span class="pre">options['supernodal']</span></code> (see below).</p>
<p>If <code class="docutils literal notranslate"><span class="pre">uplo</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'L'</span></code>, only the lower triangular part of <code class="docutils literal notranslate"><span class="pre">A</span></code>
is accessed and the upper triangular part is ignored.
If <code class="docutils literal notranslate"><span class="pre">uplo</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'U'</span></code>, only the upper triangular part of <code class="docutils literal notranslate"><span class="pre">A</span></code>
is accessed and the lower triangular part is ignored.</p>
<p>The symbolic factorization is returned as an opaque C object that
can be passed to <a class="reference internal" href="#cvxopt.cholmod.numeric" title="cvxopt.cholmod.numeric"><code class="xref py py-func docutils literal notranslate"><span class="pre">numeric</span></code></a>.</p>
<p>See the comment on
<code class="xref py py-attr docutils literal notranslate"><span class="pre">options['nmethods']</span></code> for details on which ordering is used
by CHOLMOD.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.cholmod.numeric">
<code class="descclassname">cvxopt.cholmod.</code><code class="descname">numeric</code><span class="sig-paren">(</span><em>A</em>, <em>F</em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.cholmod.numeric" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a numeric factorization of a sparse symmetric matrix
as <a class="reference internal" href="#equation-e-chol-ll">(3)</a> or <a class="reference internal" href="#equation-e-chol-ldl">(4)</a>.  The argument <code class="docutils literal notranslate"><span class="pre">F</span></code> is the
symbolic factorization computed by
<a class="reference internal" href="#cvxopt.cholmod.symbolic" title="cvxopt.cholmod.symbolic"><code class="xref py py-func docutils literal notranslate"><span class="pre">symbolic</span></code></a> applied to
the matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>, or to another sparse  matrix with the same sparsity
pattern and typecode, or by
<a class="reference internal" href="#cvxopt.cholmod.numeric" title="cvxopt.cholmod.numeric"><code class="xref py py-func docutils literal notranslate"><span class="pre">numeric</span></code></a> applied to a matrix
with the same sparsity pattern and typecode as <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">F</span></code> was created by a
<a class="reference internal" href="#cvxopt.cholmod.symbolic" title="cvxopt.cholmod.symbolic"><code class="xref py py-func docutils literal notranslate"><span class="pre">symbolic</span></code></a> with <code class="docutils literal notranslate"><span class="pre">uplo</span></code>
equal
to <code class="xref py py-const docutils literal notranslate"><span class="pre">'L'</span></code>, then only the lower triangular part of <code class="docutils literal notranslate"><span class="pre">A</span></code> is
accessed and the upper triangular part is ignored.  If it was created
with <code class="docutils literal notranslate"><span class="pre">uplo</span></code> equal to <code class="xref py py-const docutils literal notranslate"><span class="pre">'U'</span></code>, then only the upper triangular
part of <code class="docutils literal notranslate"><span class="pre">A</span></code> is accessed and the lower triangular part is ignored.</p>
<p>On successful exit, the factorization is stored in <code class="docutils literal notranslate"><span class="pre">F</span></code>.
Raises an <code class="xref py py-exc docutils literal notranslate"><span class="pre">ArithmeticError</span></code> if the factorization does not exist.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.cholmod.solve">
<code class="descclassname">cvxopt.cholmod.</code><code class="descname">solve</code><span class="sig-paren">(</span><em>F</em>, <em>B</em><span class="optional">[</span>, <em>sys = 0</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.cholmod.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves one of the following linear equations where <code class="docutils literal notranslate"><span class="pre">B</span></code> is a dense
matrix and <code class="docutils literal notranslate"><span class="pre">F</span></code> is the numeric factorization <a class="reference internal" href="#equation-e-chol-ll">(3)</a>
or <a class="reference internal" href="#equation-e-chol-ldl">(4)</a> computed by
<a class="reference internal" href="#cvxopt.cholmod.numeric" title="cvxopt.cholmod.numeric"><code class="xref py py-func docutils literal notranslate"><span class="pre">numeric</span></code></a>.
<code class="docutils literal notranslate"><span class="pre">sys</span></code> is an integer with values between 0 and 8.</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">sys</span></code></td>
<td>equation</td>
</tr>
<tr class="row-even"><td>0</td>
<td><img class="math" src="_images/math/d77e0813854d00a321e68060f73c1cf73f0a79cb.png" alt="AX = B"/></td>
</tr>
<tr class="row-odd"><td>1</td>
<td><img class="math" src="_images/math/4a92485769efc131c21ef19fa0f39242ce5b8dbc.png" alt="LDL^TX = B"/></td>
</tr>
<tr class="row-even"><td>2</td>
<td><img class="math" src="_images/math/d69f091a6a4afaeb38f7ba548495ee52ae2f4e7f.png" alt="LDX = B"/></td>
</tr>
<tr class="row-odd"><td>3</td>
<td><img class="math" src="_images/math/fbfdcbd7ea53f9cfc932ae393b8c423fa5e7a674.png" alt="DL^TX=B"/></td>
</tr>
<tr class="row-even"><td>4</td>
<td><img class="math" src="_images/math/313d5a3f8b736d1c4d5b948876005d9932bce253.png" alt="LX=B"/></td>
</tr>
<tr class="row-odd"><td>5</td>
<td><img class="math" src="_images/math/02fce4c8ae8731b85d0f428b16f945fcee39442d.png" alt="L^TX=B"/></td>
</tr>
<tr class="row-even"><td>6</td>
<td><img class="math" src="_images/math/6610c3549faee1423975e1af34f53e4449a84152.png" alt="DX=B"/></td>
</tr>
<tr class="row-odd"><td>7</td>
<td><img class="math" src="_images/math/c50f19b9760bf5950d395d65b58390bdb1e03916.png" alt="P^TX=B"/></td>
</tr>
<tr class="row-even"><td>8</td>
<td><img class="math" src="_images/math/06d393e05858b891619138cd70ec4c9d29ab3024.png" alt="PX=B"/></td>
</tr>
</tbody>
</table>
<p>(If <code class="docutils literal notranslate"><span class="pre">F</span></code> is a Cholesky factorization of the form <a class="reference internal" href="#equation-e-chol-ll">(3)</a>,
<img class="math" src="_images/math/3cf5aa5abe312e6fd4996975341a43aa566e8d8d.png" alt="D"/> is an identity matrix in this table.  If <code class="docutils literal notranslate"><span class="pre">A</span></code> is complex,
<img class="math" src="_images/math/a8ff71f5be8de0f0b80a4ee5033cb2efcfa86cce.png" alt="L^T"/> should be replaced by <img class="math" src="_images/math/bee11ec6e62981b655c4b0608fcd0aa4ffdaea53.png" alt="L^H"/>.)</p>
<p>The matrix <code class="docutils literal notranslate"><span class="pre">B</span></code> is a dense <code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> or <code class="xref py py-const docutils literal notranslate"><span class="pre">'z'</span></code> matrix, with
the same type as <code class="docutils literal notranslate"><span class="pre">A</span></code>.  On exit it is overwritten by the solution.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.cholmod.spsolve">
<code class="descclassname">cvxopt.cholmod.</code><code class="descname">spsolve</code><span class="sig-paren">(</span><em>F</em>, <em>B</em><span class="optional">[</span>, <em>sys = 0</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.cholmod.spsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to <a class="reference internal" href="#cvxopt.cholmod.solve" title="cvxopt.cholmod.solve"><code class="xref py py-func docutils literal notranslate"><span class="pre">solve</span></code></a>, except that <code class="docutils literal notranslate"><span class="pre">B</span></code> is
a class:<cite>spmatrix</cite>, and the solution is returned as an output argument
(as an <code class="xref py py-class docutils literal notranslate"><span class="pre">spmatrix</span></code>).  <code class="docutils literal notranslate"><span class="pre">B</span></code> must have the same typecode as <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
</dd></dl>

<p>For the same example as above:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">cholmod</span><span class="o">.</span><span class="n">symbolic</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cholmod</span><span class="o">.</span><span class="n">numeric</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cholmod</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">[-1.46e-01  4.88e-02]</span>
<span class="go">[ 1.33e+00  4.00e+00]</span>
<span class="go">[ 4.88e-01  1.17e+00]</span>
<span class="go">[ 2.83e+00  7.50e+00]</span>
</pre></div>
</div>
<dl class="function">
<dt id="cvxopt.cholmod.diag">
<code class="descclassname">cvxopt.cholmod.</code><code class="descname">diag</code><span class="sig-paren">(</span><em>F</em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.cholmod.diag" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the diagonal elements of the Cholesky factor <img class="math" src="_images/math/ae2b750f71e1fc0daaa3de9a85d42794d7cd1326.png" alt="L"/>
in <a class="reference internal" href="#equation-e-chol-ll">(3)</a>, as a dense matrix of the same type as <code class="docutils literal notranslate"><span class="pre">A</span></code>.
Note that this only applies to Cholesky factorizations.  The matrix
<img class="math" src="_images/math/3cf5aa5abe312e6fd4996975341a43aa566e8d8d.png" alt="D"/> in an <span class="raw-html">LDL<sup><small>T</small></sup></span>
factorization can be retrieved via <a class="reference internal" href="#cvxopt.cholmod.solve" title="cvxopt.cholmod.solve"><code class="xref py py-func docutils literal notranslate"><span class="pre">solve</span></code></a>
with <code class="docutils literal notranslate"><span class="pre">sys</span></code> equal to 6.</p>
</dd></dl>

<p>In the functions listed above, the default values of the control
parameters described in the CHOLMOD user guide are used, except for
<code class="xref c c-data docutils literal notranslate"><span class="pre">Common-&gt;print</span></code> which is set to 0 instead of 3 and
<code class="xref c c-data docutils literal notranslate"><span class="pre">Common-&gt;supernodal</span></code> which is set to 2 instead of 1.
These parameters (and a few others) can be modified by making an
entry in the dictionary <code class="xref py py-attr docutils literal notranslate"><span class="pre">cholmod.options</span></code>.
The meaning of the options <code class="xref py py-attr docutils literal notranslate"><span class="pre">options['supernodal']</span></code>  and
<code class="xref py py-attr docutils literal notranslate"><span class="pre">options['nmethods']</span></code> is summarized as follows (and described
in detail in the CHOLMOD user guide).</p>
<dl class="docutils">
<dt><code class="xref py py-attr docutils literal notranslate"><span class="pre">options['supernodal']</span></code></dt>
<dd>If equal to 0, a factorization <a class="reference internal" href="#equation-e-chol-ldl">(4)</a> is computed using a
simplicial algorithm.  If equal to 2, a factorization <a class="reference internal" href="#equation-e-chol-ll">(3)</a>
is computed using a supernodal algorithm.  If equal to 1, the most
efficient of the two factorizations is selected, based on the sparsity
pattern.  Default: 2.</dd>
<dt><code class="xref py py-attr docutils literal notranslate"><span class="pre">options['nmethods']</span></code></dt>
<dd>The default ordering used by the CHOLMOD is the ordering in the  AMD
library, but depending on the value of <code class="xref py py-attr docutils literal notranslate"><span class="pre">options['nmethods']</span></code>.
other orderings are also considered.
If <code class="docutils literal notranslate"><span class="pre">nmethods</span></code> is equal to 2, the ordering specified
by the user and the AMD ordering are compared, and the best of the two
orderings is used.  If the user does not specify an ordering, the AMD
ordering is used.
If equal to 1, the user must specify an ordering, and the ordering
provided by the user is used.
If equal to 0, all available orderings are compared and the best
ordering is used.  The available orderings include the AMD ordering,
the ordering specified by the user (if any), and possibly other
orderings if they are installed during the CHOLMOD installation.
Default: 0.</dd>
</dl>
<p>As an example that illustrates <a class="reference internal" href="#cvxopt.cholmod.diag" title="cvxopt.cholmod.diag"><code class="xref py py-func docutils literal notranslate"><span class="pre">diag</span></code></a> and the
use of <code class="xref py py-attr docutils literal notranslate"><span class="pre">cholmod.options</span></code>, we compute the logarithm of the determinant
of the coefficient matrix in <a class="reference internal" href="#equation-e-a-pd">(2)</a> by two methods.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">math</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt.cholmod</span> <span class="k">import</span> <span class="n">options</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="k">import</span> <span class="n">log</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">cholmod</span><span class="o">.</span><span class="n">symbolic</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cholmod</span><span class="o">.</span><span class="n">numeric</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">cholmod</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">F</span><span class="p">))))</span>
<span class="go">5.50533153593</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;supernodal&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">cholmod</span><span class="o">.</span><span class="n">symbolic</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cholmod</span><span class="o">.</span><span class="n">numeric</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Di</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cholmod</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">Di</span><span class="p">,</span> <span class="n">sys</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="o">-</span><span class="nb">sum</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">Di</span><span class="p">)))</span>
<span class="go">5.50533153593</span>
</pre></div>
</div>
</div>
<div class="section" id="example-covariance-selection">
<h2>Example: Covariance Selection<a class="headerlink" href="#example-covariance-selection" title="Permalink to this headline">¶</a></h2>
<p>This example illustrates the use of the routines for sparse Cholesky
factorization.  We consider the problem</p>
<div class="math" id="equation-e-covsel">
<p><span class="eqno">(5)<a class="headerlink" href="#equation-e-covsel" title="Permalink to this equation">¶</a></span><img src="_images/math/95c1874ffe7da911eda32dcd8f3a11aaff9eb8f1.png" alt="\newcommand{\Tr}{\mathop{\bf tr}}
\begin{array}{ll}
    \mbox{minimize} &amp; -\log\det K + \Tr(KY) \\
    \mbox{subject to} &amp; K_{ij}=0,\quad (i,j) \not \in S.
\end{array}"/></p>
</div><p>The optimization variable is a symmetric matrix <img class="math" src="_images/math/684381a21cd73ebbf43b63a087d3f7410ee99ce8.png" alt="K"/> of order
<img class="math" src="_images/math/e11f2701c4a39c7fe543a6c4150b421d50f1c159.png" alt="n"/> and the domain of the problem is the set of positive definite
matrices.  The matrix <img class="math" src="_images/math/0062c26909b3e07ee8f5a6285b2563d69bc979ff.png" alt="Y"/> and the index set <img class="math" src="_images/math/1dbc400fcc213305415872f9f625cd2828f97a00.png" alt="S"/> are given.
We assume that all the diagonal positions are included in <img class="math" src="_images/math/1dbc400fcc213305415872f9f625cd2828f97a00.png" alt="S"/>.
This problem arises in maximum likelihood estimation of the covariance
matrix of a zero-mean normal distribution, with constraints
that specify that pairs of variables are conditionally independent.</p>
<p>We can express <img class="math" src="_images/math/684381a21cd73ebbf43b63a087d3f7410ee99ce8.png" alt="K"/> as</p>
<div class="math">
<p><img src="_images/math/d07430c9b0d32e3c45ead32710178349359e6288.png" alt="\newcommand{\diag}{\mathop{\bf diag}}
K(x) = E_1\diag(x)E_2^T+E_2\diag(x)E_1^T"/></p>
</div><p>where <img class="math" src="_images/math/a59f68a4202623bb859a7093f0316bf466e6f75d.png" alt="x"/> are the nonzero elements in the lower triangular part of
<img class="math" src="_images/math/684381a21cd73ebbf43b63a087d3f7410ee99ce8.png" alt="K"/>, with the diagonal elements scaled by 1/2, and</p>
<div class="math">
<p><img src="_images/math/9fe98d3adb5924ecf0ac6bb3d26a6e833c1bdf9b.png" alt="E_1 = \left[ \begin{array}{cccc}
    e_{i_1} &amp; e_{i_2} &amp; \cdots &amp; e_{i_q} \end{array}\right], \qquad
E_2 = \left[ \begin{array}{cccc}
    e_{j_1} &amp; e_{j_2} &amp; \cdots &amp; e_{j_q} \end{array}\right],"/></p>
</div><p>where (<img class="math" src="_images/math/a729fab7b286b889be54824b0f442a84566370f4.png" alt="i_k"/>, <img class="math" src="_images/math/7e0c618eb33b8bed638496f82ad1152c65b48b25.png" alt="j_k"/>) are the positions of the nonzero entries
in the lower-triangular part of <img class="math" src="_images/math/684381a21cd73ebbf43b63a087d3f7410ee99ce8.png" alt="K"/>.  With this notation, we can
solve problem <a class="reference internal" href="#equation-e-covsel">(5)</a> by solving the unconstrained problem</p>
<div class="math">
<p><img src="_images/math/89632a9af2439abbfb901237915c93cce507e6f5.png" alt="\newcommand{\Tr}{\mathop{\bf tr}}
\begin{array}{ll}
\mbox{minimize} &amp; f(x) = -\log\det K(x) + \Tr(K(x)Y).
\end{array}"/></p>
</div><p>The code below implements Newton’s method with a backtracking line search.
The gradient and Hessian of the objective function are given by</p>
<div class="math">
<p><img src="_images/math/321edeeaaab544f55c8fc274ce9fb10c8a685143.png" alt="\newcommand{\diag}{\mathop{\bf diag}}
\begin{split}
\nabla f(x)
    &amp; = 2 \diag( E_1^T (Y - K(x)^{-1}) E_2)) \\
    &amp; = 2\diag(Y_{IJ} - \left(K(x)^{-1}\right)_{IJ}) \\
\nabla^2 f(x)
    &amp; = 2 (E_1^T K(x)^{-1} E_1) \circ (E_2^T K(x)^{-1} E_2)
        + 2 (E_1^T K(x)^{-1} E_2) \circ (E_2^T K(x)^{-1} E_1) \\
    &amp; = 2 \left(K(x)^{-1}\right)_{II} \circ \left(K(x)^{-1}\right)_{JJ}
        + 2 \left(K(x)^{-1}\right)_{IJ} \circ
        \left(K(x)^{-1}\right)_{JI},
\end{split}"/></p>
</div><p>where <img class="math" src="_images/math/8a5aab8ae56b127306339f23c81f7decf9adca3a.png" alt="\circ"/> denotes Hadamard product.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="k">import</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">spmatrix</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">mul</span><span class="p">,</span> <span class="n">blas</span><span class="p">,</span> <span class="n">lapack</span><span class="p">,</span> <span class="n">amd</span><span class="p">,</span> <span class="n">cholmod</span>

<span class="k">def</span> <span class="nf">covsel</span><span class="p">(</span><span class="n">Y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the solution of</span>

<span class="sd">         minimize    -log det K + Tr(KY)</span>
<span class="sd">         subject to  K_{ij}=0,  (i,j) not in indices listed in I,J.</span>

<span class="sd">    Y is a symmetric sparse matrix with nonzero diagonal elements.</span>
<span class="sd">    I = Y.I,  J = Y.J.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">I</span><span class="p">,</span> <span class="n">J</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="n">Y</span><span class="o">.</span><span class="n">J</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">I</span> <span class="o">+</span> <span class="n">J</span><span class="o">*</span><span class="n">n</span>         <span class="c1"># non-zero positions for one-argument indexing</span>
    <span class="n">D</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">if</span> <span class="n">I</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">==</span><span class="n">J</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>  <span class="c1"># position of diagonal elements</span>

    <span class="c1"># starting point: symmetric identity with nonzero pattern I,J</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">)</span>
    <span class="n">K</span><span class="p">[::</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="c1"># Kn is used in the line search</span>
    <span class="n">Kn</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">)</span>

    <span class="c1"># symbolic factorization of K</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">cholmod</span><span class="o">.</span><span class="n">symbolic</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>

    <span class="c1"># Kinv will be the inverse of K</span>
    <span class="n">Kinv</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">iters</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>

        <span class="c1"># numeric factorization of K</span>
        <span class="n">cholmod</span><span class="o">.</span><span class="n">numeric</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">cholmod</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>

        <span class="c1"># compute Kinv by solving K*X = I</span>
        <span class="n">Kinv</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">Kinv</span><span class="p">[::</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">cholmod</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">Kinv</span><span class="p">)</span>

        <span class="c1"># solve Newton system</span>
        <span class="n">grad</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">Y</span><span class="o">.</span><span class="n">V</span> <span class="o">-</span> <span class="n">Kinv</span><span class="p">[</span><span class="n">N</span><span class="p">])</span>
        <span class="n">hess</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">mul</span><span class="p">(</span><span class="n">Kinv</span><span class="p">[</span><span class="n">I</span><span class="p">,</span><span class="n">J</span><span class="p">],</span><span class="n">Kinv</span><span class="p">[</span><span class="n">J</span><span class="p">,</span><span class="n">I</span><span class="p">])</span> <span class="o">+</span> <span class="n">mul</span><span class="p">(</span><span class="n">Kinv</span><span class="p">[</span><span class="n">I</span><span class="p">,</span><span class="n">I</span><span class="p">],</span><span class="n">Kinv</span><span class="p">[</span><span class="n">J</span><span class="p">,</span><span class="n">J</span><span class="p">]))</span>
        <span class="n">v</span> <span class="o">=</span> <span class="o">-</span><span class="n">grad</span>
        <span class="n">lapack</span><span class="o">.</span><span class="n">posv</span><span class="p">(</span><span class="n">hess</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>

        <span class="c1"># stopping criterion</span>
        <span class="n">sqntdecr</span> <span class="o">=</span> <span class="o">-</span><span class="n">blas</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Newton decrement squared:</span><span class="si">%- 7.5e</span><span class="s2">&quot;</span> <span class="o">%</span><span class="n">sqntdecr</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sqntdecr</span> <span class="o">&lt;</span> <span class="mf">1e-12</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;number of iterations: &quot;</span><span class="p">,</span> <span class="n">iters</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">break</span>

        <span class="c1"># line search</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="o">+</span><span class="n">v</span>
        <span class="n">dx</span><span class="p">[</span><span class="n">D</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span>      <span class="c1"># scale the diagonal elems</span>
        <span class="n">f</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.0</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>    <span class="c1"># f = -log det K</span>
        <span class="n">s</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">lsiter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">50</span><span class="p">):</span>
            <span class="n">Kn</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">V</span> <span class="o">+</span> <span class="n">s</span><span class="o">*</span><span class="n">dx</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">cholmod</span><span class="o">.</span><span class="n">numeric</span><span class="p">(</span><span class="n">Kn</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ArithmeticError</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">*=</span> <span class="mf">0.5</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">cholmod</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
                <span class="n">fn</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.0</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="n">blas</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">Y</span><span class="o">.</span><span class="n">V</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">fn</span> <span class="o">&lt;</span> <span class="n">f</span> <span class="o">-</span> <span class="mf">0.01</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="n">sqntdecr</span><span class="p">):</span>
                     <span class="k">break</span>
                <span class="n">s</span> <span class="o">*=</span> <span class="mf">0.5</span>

        <span class="n">K</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="n">Kn</span><span class="o">.</span><span class="n">V</span>

    <span class="k">return</span> <span class="n">K</span>
</pre></div>
</div>
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="coneprog.html" class="btn btn-neutral float-right" title="Cone Programming">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="fftw.html" class="btn btn-neutral" title="Discrete Transforms"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; <a href="copyright.html">Copyright</a> 2004-2019, M.S. Andersen, J. Dahl, L. Vandenberghe.
      Last updated on Feb 05, 2019.
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.2.3',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  false
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
  
    <div class="footer">
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.2.
    </div>

</body>
</html>
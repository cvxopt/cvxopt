

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The LAPACK Interface &mdash; CVXOPT User&#39;s Guide</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="copyright" title="Copyright" href="copyright.html" />
    <link rel="next" title="Discrete Transforms" href="fftw.html" />
    <link rel="prev" title="The BLAS Interface" href="blas.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> CVXOPT User's Guide
          

          
          </a>

          
            
            
              <div class="version">
                1.2.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="copyright.html">Copyright and License</a></li>
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrices.html">Dense and Sparse Matrices</a></li>
<li class="toctree-l1"><a class="reference internal" href="blas.html">The BLAS Interface</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">The LAPACK Interface</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#general-linear-equations">General Linear Equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#positive-definite-linear-equations">Positive Definite Linear Equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#symmetric-and-hermitian-linear-equations">Symmetric and Hermitian Linear Equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#triangular-linear-equations">Triangular Linear Equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#least-squares-and-least-norm-problems">Least-Squares and Least-Norm Problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="#symmetric-and-hermitian-eigenvalue-decomposition">Symmetric and Hermitian Eigenvalue Decomposition</a></li>
<li class="toctree-l2"><a class="reference internal" href="#generalized-symmetric-definite-eigenproblems">Generalized Symmetric Definite Eigenproblems</a></li>
<li class="toctree-l2"><a class="reference internal" href="#singular-value-decomposition">Singular Value Decomposition</a></li>
<li class="toctree-l2"><a class="reference internal" href="#schur-and-generalized-schur-factorization">Schur and Generalized Schur Factorization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example-analytic-centering">Example: Analytic Centering</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="fftw.html">Discrete Transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="spsolvers.html">Sparse Linear Equations</a></li>
<li class="toctree-l1"><a class="reference internal" href="coneprog.html">Cone Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="solvers.html">Nonlinear Convex Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="modeling.html">Modeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="c-api.html">C API</a></li>
<li class="toctree-l1"><a class="reference internal" href="printing.html">Matrix Formatting</a></li>
<li class="toctree-l1"><a class="reference external" href="http://cvxopt.org">cvxopt.org</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">CVXOPT User's Guide</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>The LAPACK Interface</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="the-lapack-interface">
<span id="c-lapack"></span><h1>The LAPACK Interface<a class="headerlink" href="#the-lapack-interface" title="Permalink to this headline">¶</a></h1>
<p>The module <code class="xref py py-mod docutils literal notranslate"><span class="pre">cvxopt.lapack</span></code> includes functions for solving dense sets
of linear equations, for the corresponding matrix factorizations (LU,
Cholesky, <span class="raw-html">LDL<sup><small>T</small></sup></span>),
for solving least-squares and least-norm problems, for
QR factorization, for symmetric eigenvalue problems, singular value
decomposition, and Schur factorization.</p>
<p>In this chapter we briefly describe the Python calling sequences.  For
further details on the underlying LAPACK functions we refer to the LAPACK
Users’ Guide and manual pages.</p>
<p>The BLAS conventional storage scheme of the section <a class="reference internal" href="blas.html#s-conventions"><span class="std std-ref">Matrix Classes</span></a>
is used. As in the previous chapter, we omit from the function definitions
less important arguments that are useful for selecting submatrices.  The
complete definitions are documented in the docstrings in the source code.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="http://www.netlib.org/lapack/lug/lapack_lug.html">LAPACK Users’ Guide, Third Edition, SIAM, 1999</a></p>
</div>
<div class="section" id="general-linear-equations">
<h2>General Linear Equations<a class="headerlink" href="#general-linear-equations" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="cvxopt.lapack.gesv">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">gesv</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">B</em><span class="optional">[</span>, <em class="sig-param">ipiv = None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.gesv" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves</p>
<div class="math">
<p><img src="_images/math/3352e62eefabf4e08a86652e339b0ef936c86ced.png" alt="A X = B,"/></p>
</div><p>where <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> and <img class="math" src="_images/math/4bc3e94a67870b41b7c20179693e889251e2c136.png" alt="B"/> are real or complex matrices, with
<img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> square and nonsingular.</p>
<p>The arguments <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> must have the same type (<code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code>
or <code class="xref py py-const docutils literal notranslate"><span class="pre">'z'</span></code>).  On entry, <code class="docutils literal notranslate"><span class="pre">B</span></code>  contains the right-hand side
<img class="math" src="_images/math/4bc3e94a67870b41b7c20179693e889251e2c136.png" alt="B"/>; on exit it contains the solution <img class="math" src="_images/math/ed38fa24f1c94891bd312012aab3f6673be3eb83.png" alt="X"/>.  The optional
argument <code class="docutils literal notranslate"><span class="pre">ipiv</span></code> is an integer matrix of length at least <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>.
If <code class="docutils literal notranslate"><span class="pre">ipiv</span></code> is provided, then <a class="reference internal" href="#cvxopt.lapack.gesv" title="cvxopt.lapack.gesv"><code class="xref py py-func docutils literal notranslate"><span class="pre">gesv</span></code></a> solves the system, replaces
<code class="docutils literal notranslate"><span class="pre">A</span></code> with the triangular factors in an LU factorization, and returns
the permutation matrix in <code class="docutils literal notranslate"><span class="pre">ipiv</span></code>.  If <code class="docutils literal notranslate"><span class="pre">ipiv</span></code> is not specified,
then <a class="reference internal" href="#cvxopt.lapack.gesv" title="cvxopt.lapack.gesv"><code class="xref py py-func docutils literal notranslate"><span class="pre">gesv</span></code></a> solves the system but does not return the LU
factorization and does not modify <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
<p>Raises an <code class="xref py py-exc docutils literal notranslate"><span class="pre">ArithmeticError</span></code> if the matrix is singular.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.getrf">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">getrf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">ipiv</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.getrf" title="Permalink to this definition">¶</a></dt>
<dd><p>LU factorization of a general, possibly rectangular, real or
complex matrix,</p>
<div class="math">
<p><img src="_images/math/3ae50aaf765cd8eb0463a159845004ccae1c3cff.png" alt="A = PLU,"/></p>
</div><p>where <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> is <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> by <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>.</p>
<p>The argument <code class="docutils literal notranslate"><span class="pre">ipiv</span></code> is an integer matrix of length at least
min{<img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/>, <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>}.  On exit, the lower triangular part of
<code class="docutils literal notranslate"><span class="pre">A</span></code> is replaced by <img class="math" src="_images/math/19eef1966f7c545af3ac8c0fa486974d873e3c65.png" alt="L"/>, the upper triangular part by <img class="math" src="_images/math/9098c1c4618d7a0f321cee441aabee7f1b57a19b.png" alt="U"/>,
and the permutation matrix is returned in <code class="docutils literal notranslate"><span class="pre">ipiv</span></code>.</p>
<p>Raises an <code class="xref py py-exc docutils literal notranslate"><span class="pre">ArithmeticError</span></code> if the matrix is not full rank.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.getrs">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">getrs</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">ipiv</em>, <em class="sig-param">B</em><span class="optional">[</span>, <em class="sig-param">trans = 'N'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.getrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a general set of linear equations</p>
<div class="math">
<p><img src="_images/math/03da04b738c1b20d64d873e8f3c18eccc4c7bc84.png" alt="AX &amp; = B  \quad (\mathrm{trans} = \mathrm{'N'}), \\
A^TX &amp; = B \quad (\mathrm{trans} = \mathrm{'T'}), \\
A^HX &amp; = B \quad (\mathrm{trans} = \mathrm{'C'}),"/></p>
</div><p>given the LU factorization computed by
<a class="reference internal" href="#cvxopt.lapack.gesv" title="cvxopt.lapack.gesv"><code class="xref py py-func docutils literal notranslate"><span class="pre">gesv</span></code></a> or
<a class="reference internal" href="#cvxopt.lapack.getrf" title="cvxopt.lapack.getrf"><code class="xref py py-func docutils literal notranslate"><span class="pre">getrf</span></code></a>.</p>
<p>On entry, <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">ipiv</span></code> must contain the factorization as computed
by <a class="reference internal" href="#cvxopt.lapack.gesv" title="cvxopt.lapack.gesv"><code class="xref py py-func docutils literal notranslate"><span class="pre">gesv</span></code></a> or <a class="reference internal" href="#cvxopt.lapack.getrf" title="cvxopt.lapack.getrf"><code class="xref py py-func docutils literal notranslate"><span class="pre">getrf</span></code></a>.  On entry, <code class="docutils literal notranslate"><span class="pre">B</span></code> contains the
right-hand side <img class="math" src="_images/math/4bc3e94a67870b41b7c20179693e889251e2c136.png" alt="B"/>; on exit it contains the solution <img class="math" src="_images/math/ed38fa24f1c94891bd312012aab3f6673be3eb83.png" alt="X"/>.
<code class="docutils literal notranslate"><span class="pre">B</span></code> must have the same type as <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.getri">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">getri</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">ipiv</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.getri" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the inverse of a matrix.</p>
<p>On entry, <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">ipiv</span></code> must contain the factorization as computed
by <a class="reference internal" href="#cvxopt.lapack.gesv" title="cvxopt.lapack.gesv"><code class="xref py py-func docutils literal notranslate"><span class="pre">gesv</span></code></a> or
<a class="reference internal" href="#cvxopt.lapack.getrf" title="cvxopt.lapack.getrf"><code class="xref py py-func docutils literal notranslate"><span class="pre">getrf</span></code></a>.  On exit, <code class="docutils literal notranslate"><span class="pre">A</span></code> contains the
matrix inverse.</p>
</dd></dl>

<p>In the following example we compute</p>
<div class="math">
<p><img src="_images/math/15ccba8c9b68894aeb55e081c819b82da74b90ed.png" alt="x = (A^{-1} + A^{-T})b"/></p>
</div><p>for randomly generated problem data, factoring the coefficient matrix once.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">normal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt.lapack</span> <span class="kn">import</span> <span class="n">gesv</span><span class="p">,</span> <span class="n">getrs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">normal</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">normal</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ipiv</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="o">+</span><span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gesv</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">ipiv</span><span class="p">)</span>               <span class="c1"># x = A^{-1}*b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="o">+</span><span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getrs</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">ipiv</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">trans</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>  <span class="c1"># x2 = A^{-T}*b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">+=</span> <span class="n">x2</span>
</pre></div>
</div>
<p>Separate functions are provided for equations with band matrices.</p>
<dl class="py function">
<dt id="cvxopt.lapack.gbsv">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">gbsv</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">kl</em>, <em class="sig-param">B</em><span class="optional">[</span>, <em class="sig-param">ipiv = None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.gbsv" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves</p>
<div class="math">
<p><img src="_images/math/3352e62eefabf4e08a86652e339b0ef936c86ced.png" alt="A X = B,"/></p>
</div><p>where <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> and <img class="math" src="_images/math/4bc3e94a67870b41b7c20179693e889251e2c136.png" alt="B"/> are real or complex matrices, with
<img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> by <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> and banded with <img class="math" src="_images/math/801e28cfd4de6fd9c1e00f5e71e5ce7b29ad57f7.png" alt="k_l"/>
subdiagonals.</p>
<p>The arguments <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> must have the same type (<code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code>
or <code class="xref py py-const docutils literal notranslate"><span class="pre">'z'</span></code>).  On entry, <code class="docutils literal notranslate"><span class="pre">B</span></code> contains the right-hand side
<img class="math" src="_images/math/4bc3e94a67870b41b7c20179693e889251e2c136.png" alt="B"/>; on exit it contains the solution <img class="math" src="_images/math/ed38fa24f1c94891bd312012aab3f6673be3eb83.png" alt="X"/>.  The optional
argument <code class="docutils literal notranslate"><span class="pre">ipiv</span></code> is an integer matrix of length at least <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>.
If <code class="docutils literal notranslate"><span class="pre">ipiv</span></code> is provided, then <code class="docutils literal notranslate"><span class="pre">A</span></code> must have <img class="math" src="_images/math/ef10ae5e9279f912e2a62fa15fc274fee32bb7d1.png" alt="2k_l + k_u + 1"/>
rows.  On entry the diagonals of <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> are stored in rows
<img class="math" src="_images/math/e55e27c7fb666f42abe96fbf168eddf1fa6c9eb2.png" alt="k_l + 1"/> to <img class="math" src="_images/math/ef10ae5e9279f912e2a62fa15fc274fee32bb7d1.png" alt="2k_l + k_u + 1"/> of <code class="docutils literal notranslate"><span class="pre">A</span></code>, using the BLAS
format for general band matrices (see the section
<a class="reference internal" href="blas.html#s-conventions"><span class="std std-ref">Matrix Classes</span></a>).  On exit, the factorization is returned in
<code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">ipiv</span></code>.  If <code class="docutils literal notranslate"><span class="pre">ipiv</span></code> is not provided, then <code class="docutils literal notranslate"><span class="pre">A</span></code> must have
<img class="math" src="_images/math/a156920bb8825b9428df86c5bfe4e3ce5b51f0f8.png" alt="k_l + k_u + 1"/> rows.  On entry the diagonals of <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> are
stored in the rows of <code class="docutils literal notranslate"><span class="pre">A</span></code>, following the standard BLAS format for
general band matrices.  In this case, <a class="reference internal" href="#cvxopt.lapack.gbsv" title="cvxopt.lapack.gbsv"><code class="xref py py-func docutils literal notranslate"><span class="pre">gbsv</span></code></a> does not modify
<code class="docutils literal notranslate"><span class="pre">A</span></code> and does not return the factorization.</p>
<p>Raises an <code class="xref py py-exc docutils literal notranslate"><span class="pre">ArithmeticError</span></code> if the matrix is singular.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.gbtrf">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">gbtrf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">kl</span></em>, <em class="sig-param"><span class="n">ipiv</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.gbtrf" title="Permalink to this definition">¶</a></dt>
<dd><p>LU factorization of a general <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> by <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> real or complex
band matrix with <img class="math" src="_images/math/801e28cfd4de6fd9c1e00f5e71e5ce7b29ad57f7.png" alt="k_l"/> subdiagonals.</p>
<p>The matrix is stored using the BLAS format for general band matrices
(see the section <a class="reference internal" href="blas.html#s-conventions"><span class="std std-ref">Matrix Classes</span></a>), by providing the diagonals
(stored as rows of a <img class="math" src="_images/math/07478b8108c1b9d0c0317e8bc57b8776263d0a85.png" alt="k_u + k_l + 1"/> by <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>),
the number of rows <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/>, and the number of subdiagonals
<img class="math" src="_images/math/801e28cfd4de6fd9c1e00f5e71e5ce7b29ad57f7.png" alt="k_l"/>.  The argument <code class="docutils literal notranslate"><span class="pre">ipiv</span></code> is an integer matrix of length at
least min{<img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/>, <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>}.  On exit, <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">ipiv</span></code> contain
the details of the factorization.</p>
<p>Raises an <code class="xref py py-exc docutils literal notranslate"><span class="pre">ArithmeticError</span></code> if the matrix is not full rank.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.gbtrs">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">gbtrs</code><span class="sig-paren">(</span><em class="sig-param">{A</em>, <em class="sig-param">kl</em>, <em class="sig-param">ipiv</em>, <em class="sig-param">B</em><span class="optional">[</span>, <em class="sig-param">trans = 'N'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.gbtrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a set of linear equations</p>
<div class="math">
<p><img src="_images/math/34a857941bc037025e34cfc7d5ddf0cba068c3f7.png" alt="AX   &amp; = B \quad (\mathrm{trans} = \mathrm{'N'}), \\
A^TX &amp; = B \quad (\mathrm{trans} = \mathrm{'T'}), \\
A^HX &amp; = B \quad (\mathrm{trans} = \mathrm{'C'}),"/></p>
</div><p>with <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> a general band matrix with <img class="math" src="_images/math/801e28cfd4de6fd9c1e00f5e71e5ce7b29ad57f7.png" alt="k_l"/> subdiagonals,
given the LU factorization computed by
<a class="reference internal" href="#cvxopt.lapack.gbsv" title="cvxopt.lapack.gbsv"><code class="xref py py-func docutils literal notranslate"><span class="pre">gbsv</span></code></a> or
<a class="reference internal" href="#cvxopt.lapack.gbtrf" title="cvxopt.lapack.gbtrf"><code class="xref py py-func docutils literal notranslate"><span class="pre">gbtrf</span></code></a>.</p>
<p>On entry, <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">ipiv</span></code> must contain the factorization as computed
by <a class="reference internal" href="#cvxopt.lapack.gbsv" title="cvxopt.lapack.gbsv"><code class="xref py py-func docutils literal notranslate"><span class="pre">gbsv</span></code></a> or <a class="reference internal" href="#cvxopt.lapack.gbtrf" title="cvxopt.lapack.gbtrf"><code class="xref py py-func docutils literal notranslate"><span class="pre">gbtrf</span></code></a>.  On entry, <code class="docutils literal notranslate"><span class="pre">B</span></code> contains the
right-hand side <img class="math" src="_images/math/4bc3e94a67870b41b7c20179693e889251e2c136.png" alt="B"/>; on exit it contains the solution <img class="math" src="_images/math/ed38fa24f1c94891bd312012aab3f6673be3eb83.png" alt="X"/>.
<code class="docutils literal notranslate"><span class="pre">B</span></code> must have the same type as <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
</dd></dl>

<p>As an example, we solve a linear equation with</p>
<div class="math">
<p><img src="_images/math/870c60a6ab1247468ddfc5be8f68ffbe3479dfda.png" alt="A = \left[ \begin{array}{cccc}
    1 &amp; 2 &amp; 0 &amp; 0 \\
    3 &amp; 4 &amp; 5 &amp; 0 \\
    6 &amp; 7 &amp; 8 &amp; 9 \\
    0 &amp; 10 &amp; 11 &amp; 12
    \end{array}\right], \qquad
B = \left[\begin{array}{c} 1 \\ 1 \\ 1 \\ 1 \end{array}\right]."/></p>
</div><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt.lapack</span> <span class="kn">import</span> <span class="n">gbsv</span><span class="p">,</span> <span class="n">gbtrf</span><span class="p">,</span> <span class="n">gbtrs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="p">,</span> <span class="n">kl</span><span class="p">,</span> <span class="n">ku</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">],</span> <span class="p">[</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">,</span> <span class="mf">7.</span><span class="p">,</span> <span class="mf">10.</span><span class="p">],</span> <span class="p">[</span><span class="mf">5.</span><span class="p">,</span> <span class="mf">8.</span><span class="p">,</span> <span class="mf">11.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">9.</span><span class="p">,</span> <span class="mf">12.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gbsv</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">kl</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[ 7.14e-02]</span>
<span class="go">[ 4.64e-01]</span>
<span class="go">[-2.14e-01]</span>
<span class="go">[-1.07e-01]</span>
</pre></div>
</div>
<p>The code below illustrates how one can reuse the factorization returned
by <a class="reference internal" href="#cvxopt.lapack.gbsv" title="cvxopt.lapack.gbsv"><code class="xref py py-func docutils literal notranslate"><span class="pre">gbsv</span></code></a>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Ac</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">kl</span><span class="o">+</span><span class="n">ku</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Ac</span><span class="p">[</span><span class="n">kl</span><span class="p">:,:]</span> <span class="o">=</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ipiv</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gbsv</span><span class="p">(</span><span class="n">Ac</span><span class="p">,</span> <span class="n">kl</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">ipiv</span><span class="p">)</span>                 <span class="c1"># solves A*x = 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[ 7.14e-02]</span>
<span class="go">[ 4.64e-01]</span>
<span class="go">[-2.14e-01]</span>
<span class="go">[-1.07e-01]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gbtrs</span><span class="p">(</span><span class="n">Ac</span><span class="p">,</span> <span class="n">kl</span><span class="p">,</span> <span class="n">ipiv</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">trans</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>     <span class="c1"># solve A^T*x = 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[ 7.14e-02]</span>
<span class="go">[ 2.38e-02]</span>
<span class="go">[ 1.43e-01]</span>
<span class="go">[-2.38e-02]</span>
</pre></div>
</div>
<p>An alternative method uses <a class="reference internal" href="#cvxopt.lapack.gbtrf" title="cvxopt.lapack.gbtrf"><code class="xref py py-func docutils literal notranslate"><span class="pre">gbtrf</span></code></a> for the
factorization.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Ac</span><span class="p">[</span><span class="n">kl</span><span class="p">:,:]</span> <span class="o">=</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gbtrf</span><span class="p">(</span><span class="n">Ac</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">kl</span><span class="p">,</span> <span class="n">ipiv</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gbtrs</span><span class="p">(</span><span class="n">Ac</span><span class="p">,</span> <span class="n">kl</span><span class="p">,</span> <span class="n">ipiv</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>                <span class="c1"># solve A^T*x = 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[ 7.14e-02]</span>
<span class="go">[ 4.64e-01]</span>
<span class="go">[-2.14e-01]</span>
<span class="go">[-1.07e-01]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gbtrs</span><span class="p">(</span><span class="n">Ac</span><span class="p">,</span> <span class="n">kl</span><span class="p">,</span> <span class="n">ipiv</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">trans</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>     <span class="c1"># solve A^T*x = 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[ 7.14e-02]</span>
<span class="go">[ 2.38e-02]</span>
<span class="go">[ 1.43e-01]</span>
<span class="go">[-2.38e-02]</span>
</pre></div>
</div>
<p>The following functions can be used for tridiagonal matrices. They use a
simpler matrix format, with the diagonals stored in three separate vectors.</p>
<dl class="py function">
<dt id="cvxopt.lapack.gtsv">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">gtsv</code><span class="sig-paren">(</span><em class="sig-param">dl</em>, <em class="sig-param">d</em>, <em class="sig-param">du</em>, <em class="sig-param">B)</em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.gtsv" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves</p>
<div class="math">
<p><img src="_images/math/3352e62eefabf4e08a86652e339b0ef936c86ced.png" alt="A X = B,"/></p>
</div><p>where <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> is an <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> by <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> tridiagonal matrix.</p>
<p>The subdiagonal of <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> is stored as a matrix <code class="docutils literal notranslate"><span class="pre">dl</span></code> of length
<img class="math" src="_images/math/a44c09dc69d687fd66b7a1a12197c0299aa5db1c.png" alt="n-1"/>, the diagonal is stored as a matrix <code class="docutils literal notranslate"><span class="pre">d</span></code> of length
<img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>, and the superdiagonal is stored as a matrix <code class="docutils literal notranslate"><span class="pre">du</span></code> of
length <img class="math" src="_images/math/a44c09dc69d687fd66b7a1a12197c0299aa5db1c.png" alt="n-1"/>.  The four arguments must have the same type
(<code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> or <code class="xref py py-const docutils literal notranslate"><span class="pre">'z'</span></code>).  On exit <code class="docutils literal notranslate"><span class="pre">dl</span></code>, <code class="docutils literal notranslate"><span class="pre">d</span></code>, <code class="docutils literal notranslate"><span class="pre">du</span></code> are
overwritten with the details of the LU factorization of <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/>.
On entry, <code class="docutils literal notranslate"><span class="pre">B</span></code> contains the right-hand side <img class="math" src="_images/math/4bc3e94a67870b41b7c20179693e889251e2c136.png" alt="B"/>; on exit it
contains the solution <img class="math" src="_images/math/ed38fa24f1c94891bd312012aab3f6673be3eb83.png" alt="X"/>.</p>
<p>Raises an <code class="xref py py-exc docutils literal notranslate"><span class="pre">ArithmeticError</span></code> if the matrix is singular.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.gttrf">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">gttrf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dl</span></em>, <em class="sig-param"><span class="n">d</span></em>, <em class="sig-param"><span class="n">du</span></em>, <em class="sig-param"><span class="n">du2</span></em>, <em class="sig-param"><span class="n">ipiv</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.gttrf" title="Permalink to this definition">¶</a></dt>
<dd><p>LU factorization of an <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> by <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> tridiagonal matrix.</p>
<p>The subdiagonal of <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> is stored as a matrix <code class="docutils literal notranslate"><span class="pre">dl</span></code> of length
<img class="math" src="_images/math/a44c09dc69d687fd66b7a1a12197c0299aa5db1c.png" alt="n-1"/>, the diagonal is stored as a matrix <code class="docutils literal notranslate"><span class="pre">d</span></code> of length
<img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>, and the superdiagonal is stored as a matrix <code class="docutils literal notranslate"><span class="pre">du</span></code> of length
<img class="math" src="_images/math/a44c09dc69d687fd66b7a1a12197c0299aa5db1c.png" alt="n-1"/>.  <code class="docutils literal notranslate"><span class="pre">dl</span></code>, <code class="docutils literal notranslate"><span class="pre">d</span></code> and <code class="docutils literal notranslate"><span class="pre">du</span></code> must have the same type.
<code class="docutils literal notranslate"><span class="pre">du2</span></code> is a matrix of length <img class="math" src="_images/math/7046228257af6ebbbde8ef7c8f944119e0a768d0.png" alt="n-2"/>, and of the same type as
<code class="docutils literal notranslate"><span class="pre">dl</span></code>.  <code class="docutils literal notranslate"><span class="pre">ipiv</span></code> is an <code class="xref py py-const docutils literal notranslate"><span class="pre">'i'</span></code> matrix of length <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>.
On exit, the five arguments contain the details of the factorization.</p>
<p>Raises an <code class="xref py py-exc docutils literal notranslate"><span class="pre">ArithmeticError</span></code> if the matrix is singular.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.gttrs">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">gttrs</code><span class="sig-paren">(</span><em class="sig-param">dl</em>, <em class="sig-param">d</em>, <em class="sig-param">du</em>, <em class="sig-param">du2</em>, <em class="sig-param">ipiv</em>, <em class="sig-param">B</em><span class="optional">[</span>, <em class="sig-param">trans = 'N'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.gttrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a set of linear equations</p>
<div class="math">
<p><img src="_images/math/34a857941bc037025e34cfc7d5ddf0cba068c3f7.png" alt="AX   &amp; = B \quad (\mathrm{trans} = \mathrm{'N'}), \\
A^TX &amp; = B \quad (\mathrm{trans} = \mathrm{'T'}), \\
A^HX &amp; = B \quad (\mathrm{trans} = \mathrm{'C'}),"/></p>
</div><p>where <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> is an <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> by <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> tridiagonal matrix.</p>
<p>The arguments <code class="docutils literal notranslate"><span class="pre">dl</span></code>, <code class="docutils literal notranslate"><span class="pre">d</span></code>, <code class="docutils literal notranslate"><span class="pre">du</span></code>, <code class="docutils literal notranslate"><span class="pre">du2</span></code>, and <code class="docutils literal notranslate"><span class="pre">ipiv</span></code> contain
the details of the LU factorization as returned by
<a class="reference internal" href="#cvxopt.lapack.gttrf" title="cvxopt.lapack.gttrf"><code class="xref py py-func docutils literal notranslate"><span class="pre">gttrf</span></code></a>.
On entry, <code class="docutils literal notranslate"><span class="pre">B</span></code> contains the right-hand side <img class="math" src="_images/math/4bc3e94a67870b41b7c20179693e889251e2c136.png" alt="B"/>; on exit it
contains the solution <img class="math" src="_images/math/ed38fa24f1c94891bd312012aab3f6673be3eb83.png" alt="X"/>.  <code class="docutils literal notranslate"><span class="pre">B</span></code> must have the same type as
the other arguments.</p>
</dd></dl>

</div>
<div class="section" id="positive-definite-linear-equations">
<h2>Positive Definite Linear Equations<a class="headerlink" href="#positive-definite-linear-equations" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="cvxopt.lapack.posv">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">posv</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">B</em><span class="optional">[</span>, <em class="sig-param">uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.posv" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves</p>
<div class="math">
<p><img src="_images/math/3352e62eefabf4e08a86652e339b0ef936c86ced.png" alt="A X = B,"/></p>
</div><p>where <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> is a real symmetric or complex Hermitian positive
definite matrix.</p>
<p>On exit, <code class="docutils literal notranslate"><span class="pre">B</span></code> is replaced by the solution, and <code class="docutils literal notranslate"><span class="pre">A</span></code> is overwritten
with the Cholesky factor.  The matrices <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> must have
the same type (<code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> or <code class="xref py py-const docutils literal notranslate"><span class="pre">'z'</span></code>).</p>
<p>Raises an <code class="xref py py-exc docutils literal notranslate"><span class="pre">ArithmeticError</span></code> if the matrix is not positive
definite.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.potrf">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">potrf</code><span class="sig-paren">(</span><em class="sig-param">A</em><span class="optional">[</span>, <em class="sig-param">uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.potrf" title="Permalink to this definition">¶</a></dt>
<dd><p>Cholesky factorization</p>
<div class="math">
<p><img src="_images/math/887be39f02687d3e3a1565193924f04d7ccbb743.png" alt="A = LL^T \qquad \mbox{or} \qquad A = LL^H"/></p>
</div><p>of a positive definite real symmetric or complex Hermitian matrix
<img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/>.</p>
<p>On exit, the lower triangular part of <code class="docutils literal notranslate"><span class="pre">A</span></code> (if <code class="docutils literal notranslate"><span class="pre">uplo</span></code> is
<code class="xref py py-const docutils literal notranslate"><span class="pre">'L'</span></code>) or the upper triangular part (if <code class="docutils literal notranslate"><span class="pre">uplo</span></code> is
<code class="xref py py-const docutils literal notranslate"><span class="pre">'U'</span></code>) is overwritten with the Cholesky factor or its
(conjugate) transpose.</p>
<p>Raises an <code class="xref py py-exc docutils literal notranslate"><span class="pre">ArithmeticError</span></code> if the matrix is not positive
definite.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.potrs">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">potrs</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">B</em><span class="optional">[</span>, <em class="sig-param">uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.potrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a set of linear equations</p>
<div class="math">
<p><img src="_images/math/e44d29f0cbcc5fa7a0f3f83d3bddc988f9b022ea.png" alt="AX = B"/></p>
</div><p>with a positive definite real symmetric or complex Hermitian matrix,
given the Cholesky factorization computed by
<a class="reference internal" href="#cvxopt.lapack.posv" title="cvxopt.lapack.posv"><code class="xref py py-func docutils literal notranslate"><span class="pre">posv</span></code></a> or
<a class="reference internal" href="#cvxopt.lapack.potrf" title="cvxopt.lapack.potrf"><code class="xref py py-func docutils literal notranslate"><span class="pre">potrf</span></code></a>.</p>
<p>On entry, <code class="docutils literal notranslate"><span class="pre">A</span></code> contains the triangular factor, as computed by
<a class="reference internal" href="#cvxopt.lapack.posv" title="cvxopt.lapack.posv"><code class="xref py py-func docutils literal notranslate"><span class="pre">posv</span></code></a> or <a class="reference internal" href="#cvxopt.lapack.potrf" title="cvxopt.lapack.potrf"><code class="xref py py-func docutils literal notranslate"><span class="pre">potrf</span></code></a>.  On exit, <code class="docutils literal notranslate"><span class="pre">B</span></code> is replaced by the
solution.  <code class="docutils literal notranslate"><span class="pre">B</span></code> must have the same type as <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.potri">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">potri</code><span class="sig-paren">(</span><em class="sig-param">A</em><span class="optional">[</span>, <em class="sig-param">uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.potri" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the inverse of a positive definite matrix.</p>
<p>On entry, <code class="docutils literal notranslate"><span class="pre">A</span></code> contains the Cholesky factorization computed by
<a class="reference internal" href="#cvxopt.lapack.potri" title="cvxopt.lapack.potri"><code class="xref py py-func docutils literal notranslate"><span class="pre">potrf</span></code></a> or
<a class="reference internal" href="#cvxopt.lapack.posv" title="cvxopt.lapack.posv"><code class="xref py py-func docutils literal notranslate"><span class="pre">posv</span></code></a>.  On exit, it contains the matrix
inverse.</p>
</dd></dl>

<p>As an example, we use <a class="reference internal" href="#cvxopt.lapack.posv" title="cvxopt.lapack.posv"><code class="xref py py-func docutils literal notranslate"><span class="pre">posv</span></code></a> to solve the
linear system</p>
<div class="math" id="equation-e-kkt-example">
<p><span class="eqno">(1)<a class="headerlink" href="#equation-e-kkt-example" title="Permalink to this equation">¶</a></span><img src="_images/math/973e7149b3e7c5fd4b7a92e36771cc6c2d6e620b.png" alt="\newcommand{\diag}{\mathop{\bf diag}}
\left[ \begin{array}{cc}
    -\diag(d)^2  &amp; A \\ A^T  &amp; 0
\end{array} \right]
\left[ \begin{array}{c} x_1 \\ x_2 \end{array} \right]
=
\left[ \begin{array}{c} b_1 \\ b_2 \end{array} \right]"/></p>
</div><p>by block-elimination.  We first pick a random problem.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">div</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="n">uniform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt.blas</span> <span class="kn">import</span> <span class="n">syrk</span><span class="p">,</span> <span class="n">gemv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt.lapack</span> <span class="kn">import</span> <span class="n">posv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">normal</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">normal</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="n">normal</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">uniform</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>We then solve the equations</p>
<div class="math">
<p><img src="_images/math/895591ad55b7e2cec6ade3bbb0bb1a0b76fe0910.png" alt="\newcommand{\diag}{\mathop{\bf diag}}
\begin{split}
A^T \diag(d)^{-2}A x_2 &amp; = b_2 + A^T \diag(d)^{-2} b_1 \\
\diag(d)^2 x_1 &amp; = Ax_2 - b_1.
\end{split}"/></p>
</div><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Asc</span> <span class="o">=</span> <span class="n">div</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">d</span><span class="p">[:,</span> <span class="n">n</span><span class="o">*</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>                <span class="c1"># Asc := diag(d)^{-1}*A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">syrk</span><span class="p">(</span><span class="n">Asc</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">trans</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>                  <span class="c1"># B := Asc^T * Asc = A^T * diag(d)^{-2} * A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span> <span class="o">=</span> <span class="n">div</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>                          <span class="c1"># x1 := diag(d)^{-1}*b1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="o">+</span><span class="n">b2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gemv</span><span class="p">(</span><span class="n">Asc</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">trans</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>   <span class="c1"># x2 := x2 + Asc^T*x1 = b2 + A^T*diag(d)^{-2}*b1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">posv</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>                              <span class="c1"># x2 := B^{-1}*x2 = B^{-1}*(b2 + A^T*diag(d)^{-2}*b1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gemv</span><span class="p">(</span><span class="n">Asc</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">beta</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">)</span>             <span class="c1"># x1 := Asc*x2 - x1 = diag(d)^{-1} * (A*x2 - b1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span> <span class="o">=</span> <span class="n">div</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>                          <span class="c1"># x1 := diag(d)^{-1}*x1 = diag(d)^{-2} * (A*x2 - b1)</span>
</pre></div>
</div>
<p>There are separate routines for equations with positive definite band
matrices.</p>
<dl class="py function">
<dt id="cvxopt.lapack.pbsv">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">pbsv</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">B</em><span class="optional">[</span>, <em class="sig-param">uplo='L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.pbsv" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves</p>
<div class="math">
<p><img src="_images/math/e44d29f0cbcc5fa7a0f3f83d3bddc988f9b022ea.png" alt="AX = B"/></p>
</div><p>where <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> is a real symmetric or complex Hermitian positive
definite band matrix.</p>
<p>On entry, the diagonals of <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> are stored in <code class="docutils literal notranslate"><span class="pre">A</span></code>, using the
BLAS format for symmetric or Hermitian band matrices (see
section <a class="reference internal" href="blas.html#s-conventions"><span class="std std-ref">Matrix Classes</span></a>).  On exit, <code class="docutils literal notranslate"><span class="pre">B</span></code> is replaced by the
solution, and <code class="docutils literal notranslate"><span class="pre">A</span></code> is overwritten with the Cholesky factor (in the
BLAS format for triangular band matrices).  The matrices <code class="docutils literal notranslate"><span class="pre">A</span></code> and
<code class="docutils literal notranslate"><span class="pre">B</span></code> must have the same type (<code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> or <code class="xref py py-const docutils literal notranslate"><span class="pre">'z'</span></code>).</p>
<p>Raises an <code class="xref py py-exc docutils literal notranslate"><span class="pre">ArithmeticError</span></code> if the matrix is not positive
definite.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.pbtrf">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">pbtrf</code><span class="sig-paren">(</span><em class="sig-param">A</em><span class="optional">[</span>, <em class="sig-param">uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.pbtrf" title="Permalink to this definition">¶</a></dt>
<dd><p>Cholesky factorization</p>
<div class="math">
<p><img src="_images/math/887be39f02687d3e3a1565193924f04d7ccbb743.png" alt="A = LL^T \qquad \mbox{or} \qquad A = LL^H"/></p>
</div><p>of a positive definite real symmetric or complex Hermitian band matrix
<img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/>.</p>
<p>On entry, the diagonals of <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> are stored in <code class="docutils literal notranslate"><span class="pre">A</span></code>, using the
BLAS format for symmetric or Hermitian band matrices.  On exit, <code class="docutils literal notranslate"><span class="pre">A</span></code>
contains the Cholesky factor, in the BLAS format for triangular band
matrices.</p>
<p>Raises an <code class="xref py py-exc docutils literal notranslate"><span class="pre">ArithmeticError</span></code> if the matrix is not positive
definite.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.pbtrs">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">pbtrs</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">B</em><span class="optional">[</span>, <em class="sig-param">uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.pbtrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a set of linear equations</p>
<div class="math">
<p><img src="_images/math/f2cb671262e4538a530f4241ee603253c3e01118.png" alt="AX=B"/></p>
</div><p>with a positive definite real symmetric or complex Hermitian band
matrix, given the Cholesky factorization computed by
<a class="reference internal" href="#cvxopt.lapack.pbsv" title="cvxopt.lapack.pbsv"><code class="xref py py-func docutils literal notranslate"><span class="pre">pbsv</span></code></a> or
<a class="reference internal" href="#cvxopt.lapack.pbtrf" title="cvxopt.lapack.pbtrf"><code class="xref py py-func docutils literal notranslate"><span class="pre">pbtrf</span></code></a>.</p>
<p>On entry, <code class="docutils literal notranslate"><span class="pre">A</span></code> contains the triangular factor, as computed by
<a class="reference internal" href="#cvxopt.lapack.pbsv" title="cvxopt.lapack.pbsv"><code class="xref py py-func docutils literal notranslate"><span class="pre">pbsv</span></code></a> or <a class="reference internal" href="#cvxopt.lapack.pbtrf" title="cvxopt.lapack.pbtrf"><code class="xref py py-func docutils literal notranslate"><span class="pre">pbtrf</span></code></a>.  On exit, <code class="docutils literal notranslate"><span class="pre">B</span></code> is replaced by the
solution.  <code class="docutils literal notranslate"><span class="pre">B</span></code> must have the same type as <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
</dd></dl>

<p>The following functions are useful for tridiagonal systems.</p>
<dl class="py function">
<dt id="cvxopt.lapack.ptsv">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">ptsv</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d</span></em>, <em class="sig-param"><span class="n">e</span></em>, <em class="sig-param"><span class="n">B</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.ptsv" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves</p>
<div class="math">
<p><img src="_images/math/3352e62eefabf4e08a86652e339b0ef936c86ced.png" alt="A X = B,"/></p>
</div><p>where <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> is an <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> by <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> positive definite real
symmetric or complex Hermitian tridiagonal matrix.</p>
<p>The diagonal of <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> is stored as a <code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> matrix <code class="docutils literal notranslate"><span class="pre">d</span></code> of
length <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> and its subdiagonal as a <code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> or <code class="xref py py-const docutils literal notranslate"><span class="pre">'z'</span></code>
matrix <code class="docutils literal notranslate"><span class="pre">e</span></code> of length <img class="math" src="_images/math/a44c09dc69d687fd66b7a1a12197c0299aa5db1c.png" alt="n-1"/>.  The arguments <code class="docutils literal notranslate"><span class="pre">e</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code>
must have the same type.  On exit <code class="docutils literal notranslate"><span class="pre">d</span></code> contains the diagonal elements
of <img class="math" src="_images/math/0fcab9067b50b87e868c4fd70f213a086addb964.png" alt="D"/> in the
<span class="raw-html">LDL<sup><small>T</small></sup></span>
or
<span class="raw-html">LDL<sup><small>H</small></sup></span>
factorization of <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/>, and
<code class="docutils literal notranslate"><span class="pre">e</span></code> contains the subdiagonal elements of the unit lower bidiagonal
matrix <img class="math" src="_images/math/19eef1966f7c545af3ac8c0fa486974d873e3c65.png" alt="L"/>.  <code class="docutils literal notranslate"><span class="pre">B</span></code> is overwritten with the solution <img class="math" src="_images/math/ed38fa24f1c94891bd312012aab3f6673be3eb83.png" alt="X"/>.
Raises an <code class="xref py py-exc docutils literal notranslate"><span class="pre">ArithmeticError</span></code> if the matrix is singular.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.pttrf">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">pttrf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d</span></em>, <em class="sig-param"><span class="n">e</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.pttrf" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="raw-html">LDL<sup><small>T</small></sup></span>
or
<span class="raw-html">LDL<sup><small>H</small></sup></span>
factorization of an <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> by <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> positive
definite real symmetric or complex Hermitian tridiagonal matrix
<img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/>.</p>
<p>On entry, the argument <code class="docutils literal notranslate"><span class="pre">d</span></code> is a <code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> matrix with the diagonal
elements of <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/>.  The argument <code class="docutils literal notranslate"><span class="pre">e</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> or
<code class="xref py py-const docutils literal notranslate"><span class="pre">'z'</span></code> matrix containing the subdiagonal of <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/>.  On exit
<code class="docutils literal notranslate"><span class="pre">d</span></code> contains the diagonal elements of <img class="math" src="_images/math/0fcab9067b50b87e868c4fd70f213a086addb964.png" alt="D"/>, and <code class="docutils literal notranslate"><span class="pre">e</span></code> contains
the subdiagonal elements of the unit lower bidiagonal matrix <img class="math" src="_images/math/19eef1966f7c545af3ac8c0fa486974d873e3c65.png" alt="L"/>.</p>
<p>Raises an <code class="xref py py-exc docutils literal notranslate"><span class="pre">ArithmeticError</span></code> if the matrix is singular.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.pttrs">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">pttrs</code><span class="sig-paren">(</span><em class="sig-param">d</em>, <em class="sig-param">e</em>, <em class="sig-param">B</em><span class="optional">[</span>, <em class="sig-param">uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.pttrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a set of linear equations</p>
<div class="math">
<p><img src="_images/math/e44d29f0cbcc5fa7a0f3f83d3bddc988f9b022ea.png" alt="AX = B"/></p>
</div><p>where <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> is an <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> by <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> positive definite real
symmetric or complex Hermitian tridiagonal matrix, given its
<span class="raw-html">LDL<sup><small>T</small></sup></span>
or
<span class="raw-html">LDL<sup><small>H</small></sup></span>
factorization.</p>
<p>The argument <code class="docutils literal notranslate"><span class="pre">d</span></code> is the diagonal of the diagonal matrix <img class="math" src="_images/math/0fcab9067b50b87e868c4fd70f213a086addb964.png" alt="D"/>.
The argument <code class="docutils literal notranslate"><span class="pre">uplo</span></code> only matters for complex matrices.  If <code class="docutils literal notranslate"><span class="pre">uplo</span></code>
is <code class="xref py py-const docutils literal notranslate"><span class="pre">'L'</span></code>, then on exit <code class="docutils literal notranslate"><span class="pre">e</span></code> contains the subdiagonal elements
of the unit bidiagonal matrix <img class="math" src="_images/math/19eef1966f7c545af3ac8c0fa486974d873e3c65.png" alt="L"/>.  If <code class="docutils literal notranslate"><span class="pre">uplo</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'U'</span></code>,
then <code class="docutils literal notranslate"><span class="pre">e</span></code> contains the complex conjugates of the elements of the unit
bidiagonal matrix <img class="math" src="_images/math/19eef1966f7c545af3ac8c0fa486974d873e3c65.png" alt="L"/>.  On exit, <code class="docutils literal notranslate"><span class="pre">B</span></code> is overwritten with the
solution <img class="math" src="_images/math/ed38fa24f1c94891bd312012aab3f6673be3eb83.png" alt="X"/>.  <code class="docutils literal notranslate"><span class="pre">B</span></code> must have the same type as <code class="docutils literal notranslate"><span class="pre">e</span></code>.</p>
</dd></dl>

</div>
<div class="section" id="symmetric-and-hermitian-linear-equations">
<h2>Symmetric and Hermitian Linear Equations<a class="headerlink" href="#symmetric-and-hermitian-linear-equations" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="cvxopt.lapack.sysv">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">sysv</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">B</em><span class="optional">[</span>, <em class="sig-param">ipiv = None</em>, <em class="sig-param">uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.sysv" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves</p>
<div class="math">
<p><img src="_images/math/e44d29f0cbcc5fa7a0f3f83d3bddc988f9b022ea.png" alt="AX = B"/></p>
</div><p>where <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> is a real or complex symmetric matrix  of order
<img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>.</p>
<p>On exit, <code class="docutils literal notranslate"><span class="pre">B</span></code> is replaced by the solution.  The matrices <code class="docutils literal notranslate"><span class="pre">A</span></code> and
<code class="docutils literal notranslate"><span class="pre">B</span></code> must have the same type (<code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> or <code class="xref py py-const docutils literal notranslate"><span class="pre">'z'</span></code>).  The
optional argument <code class="docutils literal notranslate"><span class="pre">ipiv</span></code> is an integer matrix of length at least
equal to <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>.  If <code class="docutils literal notranslate"><span class="pre">ipiv</span></code> is provided, <a class="reference internal" href="#cvxopt.lapack.sysv" title="cvxopt.lapack.sysv"><code class="xref py py-func docutils literal notranslate"><span class="pre">sysv</span></code></a> solves the
system and returns the factorization in <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">ipiv</span></code>.  If
<code class="docutils literal notranslate"><span class="pre">ipiv</span></code> is not specified, <a class="reference internal" href="#cvxopt.lapack.sysv" title="cvxopt.lapack.sysv"><code class="xref py py-func docutils literal notranslate"><span class="pre">sysv</span></code></a> solves the system but does not
return the factorization and does not modify <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
<p>Raises an <code class="xref py py-exc docutils literal notranslate"><span class="pre">ArithmeticError</span></code> if the matrix is singular.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.sytrf">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">sytrf</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">ipiv</em><span class="optional">[</span>, <em class="sig-param">uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.sytrf" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="raw-html">LDL<sup><small>T</small></sup></span>
factorization</p>
<div class="math">
<p><img src="_images/math/4568da7a353653545f711003d54f38db128766df.png" alt="PAP^T = LDL^T"/></p>
</div><p>of a real or complex symmetric matrix <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> of order <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>.</p>
<p><code class="docutils literal notranslate"><span class="pre">ipiv</span></code> is an <code class="xref py py-const docutils literal notranslate"><span class="pre">'i'</span></code> matrix of length at least <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>.  On
exit, <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">ipiv</span></code> contain the factorization.</p>
<p>Raises an <code class="xref py py-exc docutils literal notranslate"><span class="pre">ArithmeticError</span></code> if the matrix is singular.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.sytrs">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">sytrs</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">ipiv</em>, <em class="sig-param">B</em><span class="optional">[</span>, <em class="sig-param">uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.sytrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves</p>
<div class="math">
<p><img src="_images/math/acc14817c5834249a732434e2919dfd4f708fffc.png" alt="A X = B"/></p>
</div><p>given the
<span class="raw-html">LDL<sup><small>T</small></sup></span>
factorization computed by
<a class="reference internal" href="#cvxopt.lapack.sytrf" title="cvxopt.lapack.sytrf"><code class="xref py py-func docutils literal notranslate"><span class="pre">sytrf</span></code></a> or
<a class="reference internal" href="#cvxopt.lapack.sysv" title="cvxopt.lapack.sysv"><code class="xref py py-func docutils literal notranslate"><span class="pre">sysv</span></code></a>. <code class="docutils literal notranslate"><span class="pre">B</span></code> must have the same type as
<code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.sytri">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">sytri</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">ipiv</em><span class="optional">[</span>, <em class="sig-param">uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.sytri" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the inverse of a real or complex symmetric matrix.</p>
<p>On entry, <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">ipiv</span></code> contain the
<span class="raw-html">LDL<sup><small>T</small></sup></span>
factorization computed by <a class="reference internal" href="#cvxopt.lapack.sytrf" title="cvxopt.lapack.sytrf"><code class="xref py py-func docutils literal notranslate"><span class="pre">sytrf</span></code></a> or
<a class="reference internal" href="#cvxopt.lapack.sysv" title="cvxopt.lapack.sysv"><code class="xref py py-func docutils literal notranslate"><span class="pre">sysv</span></code></a>.
On exit, <code class="docutils literal notranslate"><span class="pre">A</span></code> contains the inverse.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.hesv">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">hesv</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">B</em><span class="optional">[</span>, <em class="sig-param">ipiv = None</em>, <em class="sig-param">uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.hesv" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves</p>
<div class="math">
<p><img src="_images/math/acc14817c5834249a732434e2919dfd4f708fffc.png" alt="A X = B"/></p>
</div><p>where <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> is a real symmetric or complex Hermitian of order
<img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>.</p>
<p>On exit, <code class="docutils literal notranslate"><span class="pre">B</span></code> is replaced by the solution.  The matrices <code class="docutils literal notranslate"><span class="pre">A</span></code> and
<code class="docutils literal notranslate"><span class="pre">B</span></code> must have the same type (<code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> or <code class="xref py py-const docutils literal notranslate"><span class="pre">'z'</span></code>).  The
optional argument <code class="docutils literal notranslate"><span class="pre">ipiv</span></code> is an integer matrix of length at least
<img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>.  If <code class="docutils literal notranslate"><span class="pre">ipiv</span></code> is provided, then <a class="reference internal" href="#cvxopt.lapack.hesv" title="cvxopt.lapack.hesv"><code class="xref py py-func docutils literal notranslate"><span class="pre">hesv</span></code></a> solves the
system and returns the factorization in <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">ipiv</span></code>.  If
<code class="docutils literal notranslate"><span class="pre">ipiv</span></code> is not specified, then <a class="reference internal" href="#cvxopt.lapack.hesv" title="cvxopt.lapack.hesv"><code class="xref py py-func docutils literal notranslate"><span class="pre">hesv</span></code></a> solves the system but does
not return the factorization and does not modify <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
<p>Raises an <code class="xref py py-exc docutils literal notranslate"><span class="pre">ArithmeticError</span></code> if the matrix is singular.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.hetrf">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">hetrf</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">ipiv</em><span class="optional">[</span>, <em class="sig-param">uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.hetrf" title="Permalink to this definition">¶</a></dt>
<dd><p><span class="raw-html">LDL<sup><small>H</small></sup></span>
factorization</p>
<div class="math">
<p><img src="_images/math/9f2f3a7e9359d5459533e3d50282ebae0ca36465.png" alt="PAP^T = LDL^H"/></p>
</div><p>of a real symmetric or complex Hermitian matrix of order <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>.
<code class="docutils literal notranslate"><span class="pre">ipiv</span></code> is an <code class="xref py py-const docutils literal notranslate"><span class="pre">'i'</span></code> matrix of length at least <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>.
On exit, <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">ipiv</span></code> contain the factorization.</p>
<p>Raises an <code class="xref py py-exc docutils literal notranslate"><span class="pre">ArithmeticError</span></code> if the matrix is singular.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.hetrs">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">hetrs</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">ipiv</em>, <em class="sig-param">B</em><span class="optional">[</span>, <em class="sig-param">uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.hetrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves</p>
<div class="math">
<p><img src="_images/math/acc14817c5834249a732434e2919dfd4f708fffc.png" alt="A X = B"/></p>
</div><p>given the
<span class="raw-html">LDL<sup><small>H</small></sup></span>
factorization computed by
<a class="reference internal" href="#cvxopt.lapack.hetrf" title="cvxopt.lapack.hetrf"><code class="xref py py-func docutils literal notranslate"><span class="pre">hetrf</span></code></a> or
<a class="reference internal" href="#cvxopt.lapack.hesv" title="cvxopt.lapack.hesv"><code class="xref py py-func docutils literal notranslate"><span class="pre">hesv</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.hetri">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">hetri</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">ipiv</em><span class="optional">[</span>, <em class="sig-param">uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.hetri" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the inverse of a real symmetric or complex Hermitian  matrix.</p>
<p>On entry, <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">ipiv</span></code> contain the
<span class="raw-html">LDL<sup><small>H</small></sup></span>
factorization computed
by <a class="reference internal" href="#cvxopt.lapack.hetrf" title="cvxopt.lapack.hetrf"><code class="xref py py-func docutils literal notranslate"><span class="pre">hetrf</span></code></a> or
<a class="reference internal" href="#cvxopt.lapack.hesv" title="cvxopt.lapack.hesv"><code class="xref py py-func docutils literal notranslate"><span class="pre">hesv</span></code></a>.  On exit, <code class="docutils literal notranslate"><span class="pre">A</span></code> contains the
inverse.</p>
</dd></dl>

<p>As an example we solve the KKT system <a class="reference internal" href="#equation-e-kkt-example">(1)</a>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt.lapack</span> <span class="kn">import</span> <span class="n">sysv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="o">+</span><span class="n">n</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span><span class="p">[:</span> <span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">m</span> <span class="p">:</span> <span class="n">m</span><span class="o">+</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">d</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span><span class="p">[:</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">:]</span> <span class="o">=</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[:</span><span class="n">m</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">m</span><span class="p">:]</span> <span class="o">=</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sysv</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">uplo</span><span class="o">=</span><span class="s1">&#39;U&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="triangular-linear-equations">
<h2>Triangular Linear Equations<a class="headerlink" href="#triangular-linear-equations" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="cvxopt.lapack.trtrs">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">trtrs</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">B</em><span class="optional">[</span>, <em class="sig-param">uplo = 'L'</em>, <em class="sig-param">trans = 'N'</em>, <em class="sig-param">diag = 'N'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.trtrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a triangular set of equations</p>
<div class="math">
<p><img src="_images/math/34a857941bc037025e34cfc7d5ddf0cba068c3f7.png" alt="AX   &amp; = B \quad (\mathrm{trans} = \mathrm{'N'}), \\
A^TX &amp; = B \quad (\mathrm{trans} = \mathrm{'T'}), \\
A^HX &amp; = B \quad (\mathrm{trans} = \mathrm{'C'}),"/></p>
</div><p>where <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> is real or complex and triangular of order <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>,
and <img class="math" src="_images/math/4bc3e94a67870b41b7c20179693e889251e2c136.png" alt="B"/> is a matrix with <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> rows.</p>
<p><code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> are matrices with the same type (<code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> or
<code class="xref py py-const docutils literal notranslate"><span class="pre">'z'</span></code>).  <a class="reference internal" href="#cvxopt.lapack.trtrs" title="cvxopt.lapack.trtrs"><code class="xref py py-func docutils literal notranslate"><span class="pre">trtrs</span></code></a> is similar to
<a class="reference internal" href="blas.html#cvxopt.blas.trsm" title="cvxopt.blas.trsm"><code class="xref py py-func docutils literal notranslate"><span class="pre">blas.trsm</span></code></a>, except
that it raises an <code class="xref py py-exc docutils literal notranslate"><span class="pre">ArithmeticError</span></code> if a diagonal element of <code class="docutils literal notranslate"><span class="pre">A</span></code>
is zero (whereas <code class="xref py py-func docutils literal notranslate"><span class="pre">blas.trsm</span></code> returns <code class="xref py py-const docutils literal notranslate"><span class="pre">inf</span></code> values).</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.trtri">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">trtri</code><span class="sig-paren">(</span><em class="sig-param">A</em><span class="optional">[</span>, <em class="sig-param">uplo = 'L'</em>, <em class="sig-param">diag = 'N'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.trtri" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the inverse of a real or complex triangular matrix <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/>.
On exit, <code class="docutils literal notranslate"><span class="pre">A</span></code> contains the inverse.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.tbtrs">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">tbtrs</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">B</em><span class="optional">[</span>, <em class="sig-param">uplo = 'L'</em>, <em class="sig-param">trans = 'T'</em>, <em class="sig-param">diag = 'N'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.tbtrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a triangular set of equations</p>
<div class="math">
<p><img src="_images/math/34a857941bc037025e34cfc7d5ddf0cba068c3f7.png" alt="AX   &amp; = B \quad (\mathrm{trans} = \mathrm{'N'}), \\
A^TX &amp; = B \quad (\mathrm{trans} = \mathrm{'T'}), \\
A^HX &amp; = B \quad (\mathrm{trans} = \mathrm{'C'}),"/></p>
</div><p>where <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> is real or complex triangular band matrix of order
<img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>, and <img class="math" src="_images/math/4bc3e94a67870b41b7c20179693e889251e2c136.png" alt="B"/> is a matrix with <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> rows.</p>
<p>The diagonals of <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> are stored in <code class="docutils literal notranslate"><span class="pre">A</span></code> using the BLAS
conventions for triangular band matrices.  <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> are
matrices with the same type (<code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> or <code class="xref py py-const docutils literal notranslate"><span class="pre">'z'</span></code>).  On exit,
<code class="docutils literal notranslate"><span class="pre">B</span></code> is replaced by the solution <img class="math" src="_images/math/ed38fa24f1c94891bd312012aab3f6673be3eb83.png" alt="X"/>.</p>
</dd></dl>

</div>
<div class="section" id="least-squares-and-least-norm-problems">
<h2>Least-Squares and Least-Norm Problems<a class="headerlink" href="#least-squares-and-least-norm-problems" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="cvxopt.lapack.gels">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">gels</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">B</em><span class="optional">[</span>, <em class="sig-param">trans = 'N'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.gels" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves least-squares and least-norm problems with a full rank <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/>
by <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> matrix <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/>.</p>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">trans</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'N'</span></code>.  If <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> is greater than or equal
to <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>, <a class="reference internal" href="#cvxopt.lapack.gels" title="cvxopt.lapack.gels"><code class="xref py py-func docutils literal notranslate"><span class="pre">gels</span></code></a> solves the least-squares problem</p>
<div class="math">
<p><img src="_images/math/296e9942f8952b0eda9b312b690a6662f47008e9.png" alt="\begin{array}{ll}
\mbox{minimize} &amp; \|AX-B\|_F.
\end{array}"/></p>
</div><p>If <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> is less than or equal to <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>, <a class="reference internal" href="#cvxopt.lapack.gels" title="cvxopt.lapack.gels"><code class="xref py py-func docutils literal notranslate"><span class="pre">gels</span></code></a> solves
the least-norm problem</p>
<div class="math">
<p><img src="_images/math/8c51b26db8908731ed17a76ed86a9fe1c99aa02b.png" alt="\begin{array}{ll}
\mbox{minimize} &amp; \|X\|_F \\
\mbox{subject to} &amp; AX = B.
\end{array}"/></p>
</div></li>
<li><p><code class="docutils literal notranslate"><span class="pre">trans</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'T'</span></code> or <code class="xref py py-const docutils literal notranslate"><span class="pre">'C'</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> are
real.  If <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> is greater than or equal to <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>,
<a class="reference internal" href="#cvxopt.lapack.gels" title="cvxopt.lapack.gels"><code class="xref py py-func docutils literal notranslate"><span class="pre">gels</span></code></a> solves the least-norm problem</p>
<div class="math">
<p><img src="_images/math/e97fe83d126fdd192e9bc593cea89698fb36ffe5.png" alt="\begin{array}{ll}
\mbox{minimize} &amp; \|X\|_F \\
\mbox{subject to} &amp; A^TX=B.
\end{array}"/></p>
</div><p>If <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> is less than or equal to <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>, <a class="reference internal" href="#cvxopt.lapack.gels" title="cvxopt.lapack.gels"><code class="xref py py-func docutils literal notranslate"><span class="pre">gels</span></code></a> solves
the least-squares problem</p>
<div class="math">
<p><img src="_images/math/bd041563b2dc47337d212c089f31e14b6b95e033.png" alt="\begin{array}{ll}
\mbox{minimize} &amp; \|A^TX-B\|_F.
\end{array}"/></p>
</div></li>
<li><p><code class="docutils literal notranslate"><span class="pre">trans</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'C'</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> are complex. If
<img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> is greater than or equal to <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>, <a class="reference internal" href="#cvxopt.lapack.gels" title="cvxopt.lapack.gels"><code class="xref py py-func docutils literal notranslate"><span class="pre">gels</span></code></a> solves
the least-norm problem</p>
<div class="math">
<p><img src="_images/math/aa4d3057edd3aea1af61b5571a9e06258b978843.png" alt="\begin{array}{ll}
\mbox{minimize} &amp; \|X\|_F \\
\mbox{subject to} &amp; A^HX=B.
\end{array}"/></p>
</div><p>If <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> is less than or equal to <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>, <a class="reference internal" href="#cvxopt.lapack.gels" title="cvxopt.lapack.gels"><code class="xref py py-func docutils literal notranslate"><span class="pre">gels</span></code></a> solves
the least-squares problem</p>
<div class="math">
<p><img src="_images/math/66599856ec5735a610623bbe8242fc777d5f4100.png" alt="\begin{array}{ll}
\mbox{minimize} &amp; \|A^HX-B\|_F.
\end{array}"/></p>
</div></li>
</ol>
<p><code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> must have the same typecode (<code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> or
<code class="xref py py-const docutils literal notranslate"><span class="pre">'z'</span></code>).  <code class="docutils literal notranslate"><span class="pre">trans</span></code> = <code class="xref py py-const docutils literal notranslate"><span class="pre">'T'</span></code> is not allowed if <code class="docutils literal notranslate"><span class="pre">A</span></code> is
complex.  On exit, the solution <img class="math" src="_images/math/ed38fa24f1c94891bd312012aab3f6673be3eb83.png" alt="X"/> is stored as the leading
submatrix of <code class="docutils literal notranslate"><span class="pre">B</span></code>.  The matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> is overwritten with details of
the QR or the LQ factorization of <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/>.</p>
<p>Note that <a class="reference internal" href="#cvxopt.lapack.gels" title="cvxopt.lapack.gels"><code class="xref py py-func docutils literal notranslate"><span class="pre">gels</span></code></a> does not check whether <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> is full rank.</p>
</dd></dl>

<p>The following functions compute QR and LQ factorizations.</p>
<dl class="py function">
<dt id="cvxopt.lapack.geqrf">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">geqrf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">tau</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.geqrf" title="Permalink to this definition">¶</a></dt>
<dd><p>QR factorization of a real or complex matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>:</p>
<div class="math">
<p><img src="_images/math/8b5c5ce382e60258664c8b9eef58be7dad76daf3.png" alt="A = Q R."/></p>
</div><p>If <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> is <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> by <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>, then <img class="math" src="_images/math/90cab5ae70bdb6e45756490226ba488f522c4c4e.png" alt="Q"/> is <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> by
<img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> and orthogonal/unitary, and <img class="math" src="_images/math/1ebe654cc7b8f2a0d8100aa5825cf2b9021adbbc.png" alt="R"/> is <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> by
<img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> and upper triangular (if <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> is greater than or equal
to <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>), or upper trapezoidal (if <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> is less than or
equal to <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>).</p>
<p><code class="docutils literal notranslate"><span class="pre">tau</span></code>  is a matrix of the same type as <code class="docutils literal notranslate"><span class="pre">A</span></code> and of length
min{<img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/>, <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>}.  On exit, <img class="math" src="_images/math/1ebe654cc7b8f2a0d8100aa5825cf2b9021adbbc.png" alt="R"/> is stored in the upper
triangular/trapezoidal part of <code class="docutils literal notranslate"><span class="pre">A</span></code>.  The matrix <img class="math" src="_images/math/90cab5ae70bdb6e45756490226ba488f522c4c4e.png" alt="Q"/> is stored
as a product of min{<img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/>, <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>} elementary reflectors in
the first min{<img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/>, <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>} columns of <code class="docutils literal notranslate"><span class="pre">A</span></code> and in <code class="docutils literal notranslate"><span class="pre">tau</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.gelqf">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">gelqf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">tau</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.gelqf" title="Permalink to this definition">¶</a></dt>
<dd><p>LQ factorization of a real or complex matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>:</p>
<div class="math">
<p><img src="_images/math/a45d21a76729b863a1a60fe7ebb40a96a4ec69e5.png" alt="A = L Q."/></p>
</div><p>If <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> is <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> by <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>, then <img class="math" src="_images/math/90cab5ae70bdb6e45756490226ba488f522c4c4e.png" alt="Q"/> is <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> by
<img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> and orthogonal/unitary, and <img class="math" src="_images/math/19eef1966f7c545af3ac8c0fa486974d873e3c65.png" alt="L"/> is <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> by
<img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> and lower triangular (if <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> is less than or equal to
<img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>), or lower trapezoidal (if <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> is greater than or equal
to <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>).</p>
<p><code class="docutils literal notranslate"><span class="pre">tau</span></code>  is a matrix of the same type as <code class="docutils literal notranslate"><span class="pre">A</span></code> and of length
min{<img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/>, <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>}.  On exit, <img class="math" src="_images/math/19eef1966f7c545af3ac8c0fa486974d873e3c65.png" alt="L"/> is stored in the lower
triangular/trapezoidal part of <code class="docutils literal notranslate"><span class="pre">A</span></code>.  The matrix <img class="math" src="_images/math/90cab5ae70bdb6e45756490226ba488f522c4c4e.png" alt="Q"/> is stored
as a product of min{<img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/>, <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>} elementary reflectors in the
first min{<img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/>, <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>} rows of <code class="docutils literal notranslate"><span class="pre">A</span></code> and in <code class="docutils literal notranslate"><span class="pre">tau</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.geqp3">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">geqp3</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">jpvt</span></em>, <em class="sig-param"><span class="n">tau</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.geqp3" title="Permalink to this definition">¶</a></dt>
<dd><p>QR factorization with column pivoting of a real or complex matrix
<img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/>:</p>
<div class="math">
<p><img src="_images/math/022ccd45e165efaafd4897b98a41553943db3f05.png" alt="A P = Q R."/></p>
</div><p>If <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> is <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> by <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>, then <img class="math" src="_images/math/90cab5ae70bdb6e45756490226ba488f522c4c4e.png" alt="Q"/> is <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/>
by <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> and orthogonal/unitary, and <img class="math" src="_images/math/1ebe654cc7b8f2a0d8100aa5825cf2b9021adbbc.png" alt="R"/> is <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> by
<img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> and upper triangular (if <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> is greater than or equal
to <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>), or upper trapezoidal (if <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> is less than or equal
to <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>).</p>
<p><code class="docutils literal notranslate"><span class="pre">tau</span></code> is a matrix of the same type as <code class="docutils literal notranslate"><span class="pre">A</span></code> and of length
min{<img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/>, <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>}.  <code class="docutils literal notranslate"><span class="pre">jpvt</span></code> is an integer matrix of
length <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>.  On entry, if <code class="docutils literal notranslate"><span class="pre">jpvt[k]</span></code> is nonzero, then
column <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/> of <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> is permuted to the front of <img class="math" src="_images/math/8adc14b919839192224a68d21c0cae3a8b783c04.png" alt="AP"/>.
Otherwise, column <img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/> is a free column.</p>
<p>On exit, <code class="docutils literal notranslate"><span class="pre">jpvt</span></code> contains the permutation <img class="math" src="_images/math/c2aa3dff9bffb099e9dff196fd36aed56ec16baf.png" alt="P"/>:  the operation
<img class="math" src="_images/math/8adc14b919839192224a68d21c0cae3a8b783c04.png" alt="AP"/> is equivalent to <code class="docutils literal notranslate"><span class="pre">A[:,</span> <span class="pre">jpvt-1]</span></code>.  <img class="math" src="_images/math/1ebe654cc7b8f2a0d8100aa5825cf2b9021adbbc.png" alt="R"/> is stored
in the upper triangular/trapezoidal part of <code class="docutils literal notranslate"><span class="pre">A</span></code>.  The matrix
<img class="math" src="_images/math/90cab5ae70bdb6e45756490226ba488f522c4c4e.png" alt="Q"/> is stored as a product of min{<img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/>, <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>}
elementary reflectors in the first min{<img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/>,:math:<cite>n</cite>} columns
of <code class="docutils literal notranslate"><span class="pre">A</span></code> and in <code class="docutils literal notranslate"><span class="pre">tau</span></code>.</p>
</dd></dl>

<p>In most applications, the matrix <img class="math" src="_images/math/90cab5ae70bdb6e45756490226ba488f522c4c4e.png" alt="Q"/> is not needed explicitly, and
it is sufficient to be able to make products with <img class="math" src="_images/math/90cab5ae70bdb6e45756490226ba488f522c4c4e.png" alt="Q"/> or its
transpose.  The functions <a class="reference internal" href="#cvxopt.lapack.unmqr" title="cvxopt.lapack.unmqr"><code class="xref py py-func docutils literal notranslate"><span class="pre">unmqr</span></code></a> and
<a class="reference internal" href="#cvxopt.lapack.ormqr" title="cvxopt.lapack.ormqr"><code class="xref py py-func docutils literal notranslate"><span class="pre">ormqr</span></code></a> multiply a matrix
with the orthogonal matrix computed by
<a class="reference internal" href="#cvxopt.lapack.geqrf" title="cvxopt.lapack.geqrf"><code class="xref py py-func docutils literal notranslate"><span class="pre">geqrf</span></code></a>.</p>
<dl class="py function">
<dt id="cvxopt.lapack.unmqr">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">unmqr</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">tau</em>, <em class="sig-param">C</em><span class="optional">[</span>, <em class="sig-param">side = 'L'</em>, <em class="sig-param">trans = 'N'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.unmqr" title="Permalink to this definition">¶</a></dt>
<dd><p>Product with a real orthogonal or complex unitary matrix:</p>
<div class="math">
<p><img src="_images/math/04b02267d8a264913c39b04bf73ab88181b03cfc.png" alt="\newcommand{\op}{\mathop{\mathrm{op}}}
\begin{split}
C &amp; := \op(Q)C \quad (\mathrm{side} = \mathrm{'L'}), \\
C &amp; := C\op(Q) \quad (\mathrm{side} = \mathrm{'R'}), \\
\end{split}"/></p>
</div><p>where</p>
<div class="math">
<p><img src="_images/math/a4594eb66f65c9a3e69736f82fdb072d08b8ddcc.png" alt="\newcommand{\op}{\mathop{\mathrm{op}}}
\op(Q) =  \left\{ \begin{array}{ll}
    Q &amp; \mathrm{trans} = \mathrm{'N'} \\
    Q^T &amp; \mathrm{trans} = \mathrm{'T'} \\
    Q^H &amp; \mathrm{trans} = \mathrm{'C'}.
\end{array}\right."/></p>
</div><p>If <code class="docutils literal notranslate"><span class="pre">A</span></code> is <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> by <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>, then <img class="math" src="_images/math/90cab5ae70bdb6e45756490226ba488f522c4c4e.png" alt="Q"/> is square of order
<img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> and orthogonal or unitary.  <img class="math" src="_images/math/90cab5ae70bdb6e45756490226ba488f522c4c4e.png" alt="Q"/> is stored in the first
min{<img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/>, <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>} columns of <code class="docutils literal notranslate"><span class="pre">A</span></code> and in <code class="docutils literal notranslate"><span class="pre">tau</span></code> as a
product of min{<img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/>, <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>} elementary reflectors, as
computed by <a class="reference internal" href="#cvxopt.lapack.geqrf" title="cvxopt.lapack.geqrf"><code class="xref py py-func docutils literal notranslate"><span class="pre">geqrf</span></code></a>.
The matrices <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">tau</span></code>, and <code class="docutils literal notranslate"><span class="pre">C</span></code>
must have the same type.  <code class="docutils literal notranslate"><span class="pre">trans</span></code> = <code class="xref py py-const docutils literal notranslate"><span class="pre">'T'</span></code> is only allowed if
the typecode is <code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.ormqr">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">ormqr</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">tau</em>, <em class="sig-param">C</em><span class="optional">[</span>, <em class="sig-param">side = 'L'</em>, <em class="sig-param">trans = 'N'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.ormqr" title="Permalink to this definition">¶</a></dt>
<dd><p>Identical to <a class="reference internal" href="#cvxopt.lapack.unmqr" title="cvxopt.lapack.unmqr"><code class="xref py py-func docutils literal notranslate"><span class="pre">unmqr</span></code></a> but works only for
real matrices, and the
possible values of <code class="docutils literal notranslate"><span class="pre">trans</span></code> are <code class="xref py py-const docutils literal notranslate"><span class="pre">'N'</span></code> and <code class="xref py py-const docutils literal notranslate"><span class="pre">'T'</span></code>.</p>
</dd></dl>

<p>As an example, we solve a least-squares problem by a direct call to
<a class="reference internal" href="#cvxopt.lapack.gels" title="cvxopt.lapack.gels"><code class="xref py py-func docutils literal notranslate"><span class="pre">gels</span></code></a>, and by separate calls to
<a class="reference internal" href="#cvxopt.lapack.geqrf" title="cvxopt.lapack.geqrf"><code class="xref py py-func docutils literal notranslate"><span class="pre">geqrf</span></code></a>,
<a class="reference internal" href="#cvxopt.lapack.ormqr" title="cvxopt.lapack.ormqr"><code class="xref py py-func docutils literal notranslate"><span class="pre">ormqr</span></code></a>, and
<a class="reference internal" href="#cvxopt.lapack.trtrs" title="cvxopt.lapack.trtrs"><code class="xref py py-func docutils literal notranslate"><span class="pre">trtrs</span></code></a>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">blas</span><span class="p">,</span> <span class="n">lapack</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">normal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">normal</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">),</span> <span class="n">normal</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span> <span class="o">=</span> <span class="o">+</span><span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lapack</span><span class="o">.</span><span class="n">gels</span><span class="p">(</span><span class="o">+</span><span class="n">A</span><span class="p">,</span> <span class="n">x1</span><span class="p">)</span>                  <span class="c1"># x1[:n] minimizes || A*x - b ||_2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tau</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lapack</span><span class="o">.</span><span class="n">geqrf</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">tau</span><span class="p">)</span>                 <span class="c1"># A = [Q1, Q2] * [R1; 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="o">+</span><span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lapack</span><span class="o">.</span><span class="n">ormqr</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">trans</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>  <span class="c1"># x2 := [Q1, Q2]&#39; * x2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lapack</span><span class="o">.</span><span class="n">trtrs</span><span class="p">(</span><span class="n">A</span><span class="p">[:</span><span class="n">n</span><span class="p">,:],</span> <span class="n">x2</span><span class="p">,</span> <span class="n">uplo</span><span class="o">=</span><span class="s1">&#39;U&#39;</span><span class="p">)</span>  <span class="c1"># x2[:n] := R1^{-1} * x2[:n]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blas</span><span class="o">.</span><span class="n">nrm2</span><span class="p">(</span><span class="n">x1</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">x2</span><span class="p">[:</span><span class="n">n</span><span class="p">])</span>
<span class="go">3.0050798580569307e-16</span>
</pre></div>
</div>
<p>The next two functions make products with the orthogonal matrix computed
by <a class="reference internal" href="#cvxopt.lapack.gelqf" title="cvxopt.lapack.gelqf"><code class="xref py py-func docutils literal notranslate"><span class="pre">gelqf</span></code></a>.</p>
<dl class="py function">
<dt id="cvxopt.lapack.unmlq">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">unmlq</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">tau</em>, <em class="sig-param">C</em><span class="optional">[</span>, <em class="sig-param">side = 'L'</em>, <em class="sig-param">trans = 'N'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.unmlq" title="Permalink to this definition">¶</a></dt>
<dd><p>Product with a real orthogonal or complex unitary matrix:</p>
<div class="math">
<p><img src="_images/math/04b02267d8a264913c39b04bf73ab88181b03cfc.png" alt="\newcommand{\op}{\mathop{\mathrm{op}}}
\begin{split}
C &amp; := \op(Q)C \quad (\mathrm{side} = \mathrm{'L'}), \\
C &amp; := C\op(Q) \quad (\mathrm{side} = \mathrm{'R'}), \\
\end{split}"/></p>
</div><p>where</p>
<div class="math">
<p><img src="_images/math/dba423937c7e0c09118ccac03f01a4a3be60e2c3.png" alt="\newcommand{\op}{\mathop{\mathrm{op}}}
    \op(Q) =  \left\{ \begin{array}{ll}
        Q &amp; \mathrm{trans} = \mathrm{'N'}, \\
        Q^T &amp; \mathrm{trans} = \mathrm{'T'}, \\
        Q^H &amp; \mathrm{trans} = \mathrm{'C'}.
    \end{array}\right."/></p>
</div><p>If <code class="docutils literal notranslate"><span class="pre">A</span></code> is <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> by <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>, then <img class="math" src="_images/math/90cab5ae70bdb6e45756490226ba488f522c4c4e.png" alt="Q"/> is square of order
<img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> and orthogonal or unitary.  <img class="math" src="_images/math/90cab5ae70bdb6e45756490226ba488f522c4c4e.png" alt="Q"/> is stored in the first
min{<img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/>, <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>} rows of <code class="docutils literal notranslate"><span class="pre">A</span></code> and in <code class="docutils literal notranslate"><span class="pre">tau</span></code> as a product of
min{<img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/>, <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>} elementary reflectors, as computed by
<a class="reference internal" href="#cvxopt.lapack.gelqf" title="cvxopt.lapack.gelqf"><code class="xref py py-func docutils literal notranslate"><span class="pre">gelqf</span></code></a>.
The matrices <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">tau</span></code>, and <code class="docutils literal notranslate"><span class="pre">C</span></code> must have the
same type.  <code class="docutils literal notranslate"><span class="pre">trans</span></code> = <code class="xref py py-const docutils literal notranslate"><span class="pre">'T'</span></code> is only allowed if the typecode
is <code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.ormlq">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">ormlq</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">tau</em>, <em class="sig-param">C</em><span class="optional">[</span>, <em class="sig-param">side = 'L'</em>, <em class="sig-param">trans = 'N'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.ormlq" title="Permalink to this definition">¶</a></dt>
<dd><p>Identical to <a class="reference internal" href="#cvxopt.lapack.unmlq" title="cvxopt.lapack.unmlq"><code class="xref py py-func docutils literal notranslate"><span class="pre">unmlq</span></code></a> but works only for
real matrices, and the
possible values of <code class="docutils literal notranslate"><span class="pre">trans</span></code> or <code class="xref py py-const docutils literal notranslate"><span class="pre">'N'</span></code> and <code class="xref py py-const docutils literal notranslate"><span class="pre">'T'</span></code>.</p>
</dd></dl>

<p>As an example, we solve a least-norm problem by a direct call to
<a class="reference internal" href="#cvxopt.lapack.gels" title="cvxopt.lapack.gels"><code class="xref py py-func docutils literal notranslate"><span class="pre">gels</span></code></a>, and by separate calls to
<a class="reference internal" href="#cvxopt.lapack.gelqf" title="cvxopt.lapack.gelqf"><code class="xref py py-func docutils literal notranslate"><span class="pre">gelqf</span></code></a>,
<a class="reference internal" href="#cvxopt.lapack.ormlq" title="cvxopt.lapack.ormlq"><code class="xref py py-func docutils literal notranslate"><span class="pre">ormlq</span></code></a>,
and <a class="reference internal" href="#cvxopt.lapack.trtrs" title="cvxopt.lapack.trtrs"><code class="xref py py-func docutils literal notranslate"><span class="pre">trtrs</span></code></a>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">blas</span><span class="p">,</span> <span class="n">lapack</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">normal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">normal</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">),</span> <span class="n">normal</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span><span class="p">[:</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lapack</span><span class="o">.</span><span class="n">gels</span><span class="p">(</span><span class="o">+</span><span class="n">A</span><span class="p">,</span> <span class="n">x1</span><span class="p">)</span>                  <span class="c1"># x1 minimizes ||x||_2 subject to A*x = b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tau</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lapack</span><span class="o">.</span><span class="n">gelqf</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">tau</span><span class="p">)</span>                 <span class="c1"># A = [L1, 0] * [Q1; Q2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span><span class="p">[:</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>                           <span class="c1"># x2 = [b; 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lapack</span><span class="o">.</span><span class="n">trtrs</span><span class="p">(</span><span class="n">A</span><span class="p">[:,:</span><span class="n">m</span><span class="p">],</span> <span class="n">x2</span><span class="p">)</span>            <span class="c1"># x2[:m] := L1^{-1} * x2[:m]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lapack</span><span class="o">.</span><span class="n">ormlq</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">trans</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>  <span class="c1"># x2 := [Q1, Q2]&#39; * x2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blas</span><span class="o">.</span><span class="n">nrm2</span><span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x2</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p>Finally, if the matrix <img class="math" src="_images/math/90cab5ae70bdb6e45756490226ba488f522c4c4e.png" alt="Q"/> is needed explicitly, it can be generated
from the output of <a class="reference internal" href="#cvxopt.lapack.geqrf" title="cvxopt.lapack.geqrf"><code class="xref py py-func docutils literal notranslate"><span class="pre">geqrf</span></code></a> and
<a class="reference internal" href="#cvxopt.lapack.gelqf" title="cvxopt.lapack.gelqf"><code class="xref py py-func docutils literal notranslate"><span class="pre">gelqf</span></code></a> using one of the following functions.</p>
<dl class="py function">
<dt id="cvxopt.lapack.ungqr">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">ungqr</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">tau</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.ungqr" title="Permalink to this definition">¶</a></dt>
<dd><p>If <code class="docutils literal notranslate"><span class="pre">A</span></code> has size <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> by <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>, and <code class="docutils literal notranslate"><span class="pre">tau</span></code> has length
<img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/>, then, on entry, the first <code class="docutils literal notranslate"><span class="pre">k</span></code> columns of the matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>
and the entries of <code class="docutils literal notranslate"><span class="pre">tau</span></code> contai an unitary or orthogonal matrix
<img class="math" src="_images/math/90cab5ae70bdb6e45756490226ba488f522c4c4e.png" alt="Q"/> of order <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/>, as computed by
<a class="reference internal" href="#cvxopt.lapack.geqrf" title="cvxopt.lapack.geqrf"><code class="xref py py-func docutils literal notranslate"><span class="pre">geqrf</span></code></a>.  On exit,
the first min{<img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/>, <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>} columns of <img class="math" src="_images/math/90cab5ae70bdb6e45756490226ba488f522c4c4e.png" alt="Q"/> are contained
in the leading columns of <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.orgqr">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">orgqr</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">tau</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.orgqr" title="Permalink to this definition">¶</a></dt>
<dd><p>Identical to <a class="reference internal" href="#cvxopt.lapack.ungqr" title="cvxopt.lapack.ungqr"><code class="xref py py-func docutils literal notranslate"><span class="pre">ungqr</span></code></a> but works only for
real matrices.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.unglq">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">unglq</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">tau</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.unglq" title="Permalink to this definition">¶</a></dt>
<dd><p>If <code class="docutils literal notranslate"><span class="pre">A</span></code> has size <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> by <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>, and <code class="docutils literal notranslate"><span class="pre">tau</span></code> has length
<img class="math" src="_images/math/9630132210b904754c9ab272b61cb527d12263ca.png" alt="k"/>, then, on entry, the first <code class="docutils literal notranslate"><span class="pre">k</span></code> rows of the matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>
and the entries of <code class="docutils literal notranslate"><span class="pre">tau</span></code> contain a unitary or orthogonal matrix
<img class="math" src="_images/math/90cab5ae70bdb6e45756490226ba488f522c4c4e.png" alt="Q"/> of order <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>, as computed by
<a class="reference internal" href="#cvxopt.lapack.gelqf" title="cvxopt.lapack.gelqf"><code class="xref py py-func docutils literal notranslate"><span class="pre">gelqf</span></code></a>.
On exit, the first min{<img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/>, <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>} rows of <img class="math" src="_images/math/90cab5ae70bdb6e45756490226ba488f522c4c4e.png" alt="Q"/> are
contained in the leading rows of <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.orglq">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">orglq</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">tau</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.orglq" title="Permalink to this definition">¶</a></dt>
<dd><p>Identical to <a class="reference internal" href="#cvxopt.lapack.unglq" title="cvxopt.lapack.unglq"><code class="xref py py-func docutils literal notranslate"><span class="pre">unglq</span></code></a> but works only for
real matrices.</p>
</dd></dl>

<p>We illustrate this with the QR factorization of the matrix</p>
<div class="math">
<p><img src="_images/math/ae6d9abfed9fac62837d0c88a97a8afc81b5e712.png" alt="A = \left[\begin{array}{rrr}
    6 &amp; -5 &amp; 4 \\ 6 &amp; 3 &amp; -4 \\ 19 &amp; -2 &amp; 7 \\ 6 &amp; -10 &amp; -5
    \end{array} \right]
  = \left[\begin{array}{cc}
    Q_1 &amp; Q_2 \end{array}\right]
    \left[\begin{array}{c} R \\ 0 \end{array}\right]."/></p>
</div><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">lapack</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span> <span class="p">[</span><span class="mf">6.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">,</span> <span class="mf">19.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">5.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="o">-</span><span class="mf">10.</span><span class="p">],</span> <span class="p">[</span><span class="mf">4.</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.</span><span class="p">,</span> <span class="mf">7.</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">]</span> <span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">size</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tau</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lapack</span><span class="o">.</span><span class="n">geqrf</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">tau</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">[:</span><span class="n">n</span><span class="p">,</span> <span class="p">:])</span>              <span class="c1"># Upper triangular part is R.</span>
<span class="go">[-2.17e+01  5.08e+00 -4.76e+00]</span>
<span class="go">[ 2.17e-01 -1.06e+01 -2.66e+00]</span>
<span class="go">[ 6.87e-01  3.12e-01 -8.74e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Q1</span> <span class="o">=</span> <span class="o">+</span><span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lapack</span><span class="o">.</span><span class="n">orgqr</span><span class="p">(</span><span class="n">Q1</span><span class="p">,</span> <span class="n">tau</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Q1</span><span class="p">)</span>
<span class="go">[-2.77e-01  3.39e-01 -4.10e-01]</span>
<span class="go">[-2.77e-01 -4.16e-01  7.35e-01]</span>
<span class="go">[-8.77e-01 -2.32e-01 -2.53e-01]</span>
<span class="go">[-2.77e-01  8.11e-01  4.76e-01]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Q</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">m</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Q</span><span class="p">[:,</span> <span class="p">:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lapack</span><span class="o">.</span><span class="n">orgqr</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">tau</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>                     <span class="c1"># Q = [ Q1, Q2]</span>
<span class="go">[-2.77e-01  3.39e-01 -4.10e-01 -8.00e-01]</span>
<span class="go">[-2.77e-01 -4.16e-01  7.35e-01 -4.58e-01]</span>
<span class="go">[-8.77e-01 -2.32e-01 -2.53e-01  3.35e-01]</span>
<span class="go">[-2.77e-01  8.11e-01  4.76e-01  1.96e-01]</span>
</pre></div>
</div>
<p>The orthogonal matrix in the factorization</p>
<div class="math">
<p><img src="_images/math/767b9280eb4c7a6ad46be67cb9782508dc6d1f22.png" alt="A = \left[ \begin{array}{rrrr}
    3 &amp; -16 &amp; -10 &amp; -1 \\
   -2 &amp; -12 &amp;  -3 &amp;  4 \\
    9 &amp;  19 &amp;   6 &amp; -6
    \end{array}\right]
  = Q \left[\begin{array}{cc} R_1 &amp; R_2 \end{array}\right]"/></p>
</div><p>can be generated as follows.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span> <span class="p">[</span><span class="mf">3.</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">9.</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">16.</span><span class="p">,</span> <span class="o">-</span><span class="mf">12.</span><span class="p">,</span> <span class="mf">19.</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">10.</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">,</span> <span class="o">-</span><span class="mf">6.</span><span class="p">]</span> <span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">size</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tau</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lapack</span><span class="o">.</span><span class="n">geqrf</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">tau</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="o">+</span><span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>                     <span class="c1"># Upper trapezoidal part is [R1, R2].</span>
<span class="go">[-9.70e+00 -1.52e+01 -3.09e+00  6.70e+00]</span>
<span class="go">[-1.58e-01  2.30e+01  1.14e+01 -1.92e+00]</span>
<span class="go">[ 7.09e-01 -5.57e-01  2.26e+00  2.09e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lapack</span><span class="o">.</span><span class="n">orgqr</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">tau</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">[:,</span> <span class="p">:</span><span class="n">m</span><span class="p">])</span>              <span class="c1"># Q is in the first m columns of A.</span>
<span class="go">[-3.09e-01 -8.98e-01 -3.13e-01]</span>
<span class="go">[ 2.06e-01 -3.85e-01  9.00e-01]</span>
<span class="go">[-9.28e-01  2.14e-01  3.04e-01]</span>
</pre></div>
</div>
</div>
<div class="section" id="symmetric-and-hermitian-eigenvalue-decomposition">
<h2>Symmetric and Hermitian Eigenvalue Decomposition<a class="headerlink" href="#symmetric-and-hermitian-eigenvalue-decomposition" title="Permalink to this headline">¶</a></h2>
<p>The first four routines compute all or selected  eigenvalues and
eigenvectors of a real symmetric matrix <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/>:</p>
<div class="math">
<p><img src="_images/math/08390710b56f1bdd0cf7346dd20ee9b3a5984ea1.png" alt="\newcommand{\diag}{\mathop{\bf diag}}
A = V\diag(\lambda)V^T,\qquad  V^TV = I."/></p>
</div><dl class="py function">
<dt id="cvxopt.lapack.syev">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">syev</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">W</em><span class="optional">[</span>, <em class="sig-param">jobz = 'N'</em>, <em class="sig-param">uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.syev" title="Permalink to this definition">¶</a></dt>
<dd><p>Eigenvalue decomposition of a real symmetric matrix of order <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>.</p>
<p><code class="docutils literal notranslate"><span class="pre">W</span></code> is a real matrix of length at least <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>.  On exit, <code class="docutils literal notranslate"><span class="pre">W</span></code>
contains the eigenvalues in ascending order.  If <code class="docutils literal notranslate"><span class="pre">jobz</span></code> is
<code class="xref py py-const docutils literal notranslate"><span class="pre">'V'</span></code>, the eigenvectors are also computed and returned in <code class="docutils literal notranslate"><span class="pre">A</span></code>.
If <code class="docutils literal notranslate"><span class="pre">jobz</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'N'</span></code>, the eigenvectors are not returned and the
contents of <code class="docutils literal notranslate"><span class="pre">A</span></code> are destroyed.</p>
<p>Raises an <code class="xref py py-exc docutils literal notranslate"><span class="pre">ArithmeticError</span></code> if the eigenvalue decomposition fails.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.syevd">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">syevd</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">W</em><span class="optional">[</span>, <em class="sig-param">jobz = 'N'</em>, <em class="sig-param">uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.syevd" title="Permalink to this definition">¶</a></dt>
<dd><p>This is an alternative to <a class="reference internal" href="#cvxopt.lapack.syev" title="cvxopt.lapack.syev"><code class="xref py py-func docutils literal notranslate"><span class="pre">syev</span></code></a>, based
on a different
algorithm.  It is faster on large problems, but also uses more memory.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.syevx">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">syevx</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">W</em><span class="optional">[</span>, <em class="sig-param">jobz = 'N'</em>, <em class="sig-param">range = 'A'</em>, <em class="sig-param">uplo = 'L'</em>, <em class="sig-param">vl = 0.0</em>, <em class="sig-param">vu = 0.0</em>, <em class="sig-param">il = 1</em>, <em class="sig-param">iu = 1</em>, <em class="sig-param">Z = None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.syevx" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes selected eigenvalues and eigenvectors of a real symmetric
matrix of order <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>.</p>
<p><code class="docutils literal notranslate"><span class="pre">W</span></code> is a real matrix of length at least <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>.  On exit, <code class="docutils literal notranslate"><span class="pre">W</span></code>
contains the eigenvalues in ascending order.  If <code class="docutils literal notranslate"><span class="pre">range</span></code> is
<code class="xref py py-const docutils literal notranslate"><span class="pre">'A'</span></code>, all the eigenvalues are computed.  If <code class="docutils literal notranslate"><span class="pre">range</span></code> is
<code class="xref py py-const docutils literal notranslate"><span class="pre">'I'</span></code>, eigenvalues <img class="math" src="_images/math/97f89cf71150cd2020df53f6aabca4a64f63eb5f.png" alt="i_l"/> through <img class="math" src="_images/math/3bb6de8fbb6eb7f9723920dea5cd674c8c713f45.png" alt="i_u"/> are
computed, where <img class="math" src="_images/math/aadbbd5ab63719ff3a6c78a984dd3702cf3174c7.png" alt="1 \leq i_l \leq i_u \leq n"/>.  If <code class="docutils literal notranslate"><span class="pre">range</span></code> is
<code class="xref py py-const docutils literal notranslate"><span class="pre">'V'</span></code>, the eigenvalues in the interval <img class="math" src="_images/math/f3a047615f8cef5f6ce18b309a433eb73ef8e13b.png" alt="(v_l, v_u]"/> are
computed.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">jobz</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'V'</span></code>, the (normalized) eigenvectors are
computed, and returned in <code class="docutils literal notranslate"><span class="pre">Z</span></code>.  If <code class="docutils literal notranslate"><span class="pre">jobz</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'N'</span></code>, the
eigenvectors are not computed.  In both cases, the contents of <code class="docutils literal notranslate"><span class="pre">A</span></code>
are destroyed on exit.</p>
<p><code class="docutils literal notranslate"><span class="pre">Z</span></code> is optional (and not referenced) if <code class="docutils literal notranslate"><span class="pre">jobz</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'N'</span></code>.
It is required if <code class="docutils literal notranslate"><span class="pre">jobz</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'V'</span></code> and must have at least
<img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> columns if <code class="docutils literal notranslate"><span class="pre">range</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'A'</span></code> or <code class="xref py py-const docutils literal notranslate"><span class="pre">'V'</span></code> and  at
least <img class="math" src="_images/math/812c22f26f3cabffdd7214c59716aef9a9fedca2.png" alt="i_u - i_l + 1"/> columns if <code class="docutils literal notranslate"><span class="pre">range</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'I'</span></code>.</p>
<p><a class="reference internal" href="#cvxopt.lapack.syevx" title="cvxopt.lapack.syevx"><code class="xref py py-func docutils literal notranslate"><span class="pre">syevx</span></code></a> returns the number of computed eigenvalues.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.syevr">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">syevr</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">W</em><span class="optional">[</span>, <em class="sig-param">jobz = 'N'</em>, <em class="sig-param">range = 'A'</em>, <em class="sig-param">uplo = 'L'</em>, <em class="sig-param">vl = 0.0</em>, <em class="sig-param">vu = 0.0</em>, <em class="sig-param">il = 1</em>, <em class="sig-param">iu = n</em>, <em class="sig-param">Z =  None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.syevr" title="Permalink to this definition">¶</a></dt>
<dd><p>This is an alternative to <a class="reference internal" href="#cvxopt.lapack.syevr" title="cvxopt.lapack.syevr"><code class="xref py py-func docutils literal notranslate"><span class="pre">syevx</span></code></a>.
<a class="reference internal" href="#cvxopt.lapack.syevr" title="cvxopt.lapack.syevr"><code class="xref py py-func docutils literal notranslate"><span class="pre">syevr</span></code></a> is the most
recent LAPACK routine for symmetric eigenvalue problems, and expected
to supersede the three other routines in future releases.</p>
</dd></dl>

<p>The next four routines can be used to compute eigenvalues and eigenvectors
for complex Hermitian matrices:</p>
<div class="math">
<p><img src="_images/math/4798110dbfdeb1ecd95e4f30fe61ccf31ce4f503.png" alt="\newcommand{\diag}{\mathop{\bf diag}}
A = V\diag(\lambda)V^H,\qquad  V^HV = I."/></p>
</div><p>For real symmetric matrices they are identical to the corresponding
<code class="xref py py-func docutils literal notranslate"><span class="pre">syev*</span></code> routines.</p>
<dl class="py function">
<dt id="cvxopt.lapack.heev">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">heev</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">W</em><span class="optional">[</span>, <em class="sig-param">jobz = 'N'</em>, <em class="sig-param">uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.heev" title="Permalink to this definition">¶</a></dt>
<dd><p>Eigenvalue decomposition of a real symmetric or complex Hermitian
matrix of order <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>.</p>
<p>The calling sequence is identical to
<a class="reference internal" href="#cvxopt.lapack.syev" title="cvxopt.lapack.syev"><code class="xref py py-func docutils literal notranslate"><span class="pre">syev</span></code></a>,
except that <code class="docutils literal notranslate"><span class="pre">A</span></code> can be real or complex.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.heevd">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">heevd</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">W</em><span class="optional">[</span>, <em class="sig-param">jobz = 'N'</em><span class="optional">[</span>, <em class="sig-param">uplo = 'L'</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.heevd" title="Permalink to this definition">¶</a></dt>
<dd><p>This is an alternative to <a class="reference internal" href="#cvxopt.lapack.heevd" title="cvxopt.lapack.heevd"><code class="xref py py-func docutils literal notranslate"><span class="pre">heev</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.heevx">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">heevx</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">W</em><span class="optional">[</span>, <em class="sig-param">jobz = 'N'</em>, <em class="sig-param">range = 'A'</em>, <em class="sig-param">uplo = 'L'</em>, <em class="sig-param">vl = 0.0</em>, <em class="sig-param">vu = 0.0</em>, <em class="sig-param">il = 1</em>, <em class="sig-param">iu = n</em>, <em class="sig-param">Z = None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.heevx" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes selected eigenvalues and eigenvectors of a real symmetric
or complex Hermitian matrix.</p>
<p>The calling sequence is identical to
<a class="reference internal" href="#cvxopt.lapack.syevx" title="cvxopt.lapack.syevx"><code class="xref py py-func docutils literal notranslate"><span class="pre">syevx</span></code></a>, except that <code class="docutils literal notranslate"><span class="pre">A</span></code>
can be real or complex.  <code class="docutils literal notranslate"><span class="pre">Z</span></code> must have the same type as <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.heevr">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">heevr</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">W</em><span class="optional">[</span>, <em class="sig-param">jobz = 'N'</em>, <em class="sig-param">range = 'A'</em>, <em class="sig-param">uplo = 'L'</em>, <em class="sig-param">vl = 0.0</em>, <em class="sig-param">vu = 0.0</em>, <em class="sig-param">il = 1</em>, <em class="sig-param">iu = n</em>, <em class="sig-param">Z = None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.heevr" title="Permalink to this definition">¶</a></dt>
<dd><p>This is an alternative to <a class="reference internal" href="#cvxopt.lapack.heevx" title="cvxopt.lapack.heevx"><code class="xref py py-func docutils literal notranslate"><span class="pre">heevx</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="generalized-symmetric-definite-eigenproblems">
<h2>Generalized Symmetric Definite Eigenproblems<a class="headerlink" href="#generalized-symmetric-definite-eigenproblems" title="Permalink to this headline">¶</a></h2>
<p>Three types of generalized eigenvalue problems can be solved:</p>
<div class="math" id="equation-e-gevd">
<p><span class="eqno">(2)<a class="headerlink" href="#equation-e-gevd" title="Permalink to this equation">¶</a></span><img src="_images/math/385dad5a2df2ddd65900bef4c4ab58d4a4a0829d.png" alt="\newcommand{\diag}{\mathop{\bf diag}}
\begin{split}
    AZ  &amp; = BZ\diag(\lambda)\quad \mbox{(type 1)}, \\
    ABZ &amp; = Z\diag(\lambda) \quad \mbox{(type 2)}, \\
    BAZ &amp; = Z\diag(\lambda) \quad \mbox{(type 3)},
\end{split}"/></p>
</div><p>with <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> and <img class="math" src="_images/math/4bc3e94a67870b41b7c20179693e889251e2c136.png" alt="B"/> real symmetric or complex Hermitian, and
<img class="math" src="_images/math/4bc3e94a67870b41b7c20179693e889251e2c136.png" alt="B"/> is positive definite.  The matrix of eigenvectors is normalized
as follows:</p>
<div class="math">
<p><img src="_images/math/d246dde9fc63993c5b8df2eaccfa78ef89ad875d.png" alt="Z^H BZ = I \quad \mbox{(types 1 and 2)}, \qquad
Z^H B^{-1}Z = I \quad \mbox{(type 3)}."/></p>
</div><dl class="py function">
<dt id="cvxopt.lapack.sygv">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">sygv</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">B</em>, <em class="sig-param">W</em><span class="optional">[</span>, <em class="sig-param">itype = 1</em>, <em class="sig-param">jobz = 'N'</em>, <em class="sig-param">uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.sygv" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves the generalized eigenproblem <a class="reference internal" href="#equation-e-gevd">(2)</a> for real symmetric
matrices of order <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>, stored in real matrices <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code>.
<code class="docutils literal notranslate"><span class="pre">itype</span></code> is an integer with possible values 1, 2, 3, and specifies
the type of eigenproblem.  <code class="docutils literal notranslate"><span class="pre">W</span></code> is a real matrix of length at least
<img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>.  On exit, it contains the eigenvalues in ascending order.
On exit, <code class="docutils literal notranslate"><span class="pre">B</span></code> contains the Cholesky factor of <img class="math" src="_images/math/4bc3e94a67870b41b7c20179693e889251e2c136.png" alt="B"/>.  If <code class="docutils literal notranslate"><span class="pre">jobz</span></code>
is <code class="xref py py-const docutils literal notranslate"><span class="pre">'V'</span></code>, the eigenvectors are computed and returned in <code class="docutils literal notranslate"><span class="pre">A</span></code>.
If <code class="docutils literal notranslate"><span class="pre">jobz</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'N'</span></code>, the eigenvectors are not returned and the
contents of <code class="docutils literal notranslate"><span class="pre">A</span></code> are destroyed.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.hegv">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">hegv</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">B</em>, <em class="sig-param">W</em><span class="optional">[</span>, <em class="sig-param">itype = 1</em>, <em class="sig-param">jobz = 'N'</em>, <em class="sig-param">uplo = 'L'</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.hegv" title="Permalink to this definition">¶</a></dt>
<dd><p>Generalized eigenvalue problem <a class="reference internal" href="#equation-e-gevd">(2)</a> of real symmetric or
complex Hermitian matrix of order <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>.  The calling sequence is
identical to <a class="reference internal" href="#cvxopt.lapack.sygv" title="cvxopt.lapack.sygv"><code class="xref py py-func docutils literal notranslate"><span class="pre">sygv</span></code></a>, except that
<code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> can be real or complex.</p>
</dd></dl>

</div>
<div class="section" id="singular-value-decomposition">
<h2>Singular Value Decomposition<a class="headerlink" href="#singular-value-decomposition" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="cvxopt.lapack.gesvd">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">gesvd</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">S</em><span class="optional">[</span>, <em class="sig-param">jobu = 'N'</em>, <em class="sig-param">jobvt = 'N'</em>, <em class="sig-param">U = None</em>, <em class="sig-param">Vt = None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.gesvd" title="Permalink to this definition">¶</a></dt>
<dd><p>Singular value decomposition</p>
<div class="math">
<p><img src="_images/math/738092734154893db4338bbdedae2ef8c48eade3.png" alt="A = U \Sigma V^T, \qquad A = U \Sigma V^H"/></p>
</div><p>of a real or complex <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> by <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> matrix <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/>.</p>
<p><code class="docutils literal notranslate"><span class="pre">S</span></code> is a real matrix of length at least min{<img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/>, <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>}.
On exit, its first  min{<img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/>, <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>} elements are the
singular values in descending order.</p>
<p>The argument <code class="docutils literal notranslate"><span class="pre">jobu</span></code> controls how many left singular vectors are
computed.  The possible values are <code class="xref py py-const docutils literal notranslate"><span class="pre">'N'</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">'A'</span></code>,
<code class="xref py py-const docutils literal notranslate"><span class="pre">'S'</span></code> and <code class="xref py py-const docutils literal notranslate"><span class="pre">'O'</span></code>.  If <code class="docutils literal notranslate"><span class="pre">jobu</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'N'</span></code>, no left
singular vectors are computed.  If <code class="docutils literal notranslate"><span class="pre">jobu</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'A'</span></code>, all left
singular vectors are computed and returned as columns of <code class="docutils literal notranslate"><span class="pre">U</span></code>.
If <code class="docutils literal notranslate"><span class="pre">jobu</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'S'</span></code>, the first min{<img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/>, <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>} left
singular vectors are computed and returned as columns of <code class="docutils literal notranslate"><span class="pre">U</span></code>.
If <code class="docutils literal notranslate"><span class="pre">jobu</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'O'</span></code>, the first min{<img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/>, <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>} left
singular vectors are computed and returned as columns of <code class="docutils literal notranslate"><span class="pre">A</span></code>.
The argument <code class="docutils literal notranslate"><span class="pre">U</span></code> is None(if <code class="docutils literal notranslate"><span class="pre">jobu</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'N'</span></code>
or <code class="xref py py-const docutils literal notranslate"><span class="pre">'A'</span></code>) or a matrix of the same type as <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
<p>The argument <code class="docutils literal notranslate"><span class="pre">jobvt</span></code> controls how many right singular vectors are
computed.  The possible values are <code class="xref py py-const docutils literal notranslate"><span class="pre">'N'</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">'A'</span></code>,
<code class="xref py py-const docutils literal notranslate"><span class="pre">'S'</span></code> and <code class="xref py py-const docutils literal notranslate"><span class="pre">'O'</span></code>.  If <code class="docutils literal notranslate"><span class="pre">jobvt</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'N'</span></code>, no right
singular vectors are computed.  If <code class="docutils literal notranslate"><span class="pre">jobvt</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'A'</span></code>, all right
singular vectors are computed and returned as rows of <code class="docutils literal notranslate"><span class="pre">Vt</span></code>.
If <code class="docutils literal notranslate"><span class="pre">jobvt</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'S'</span></code>, the first min{<img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/>, <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>}
right singular vectors are computed and their (conjugate) transposes
are returned as rows of <code class="docutils literal notranslate"><span class="pre">Vt</span></code>.  If <code class="docutils literal notranslate"><span class="pre">jobvt</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'O'</span></code>, the
first min{<img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/>, <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>} right singular vectors are computed
and their (conjugate) transposes are returned as rows of <code class="docutils literal notranslate"><span class="pre">A</span></code>.
Note that the (conjugate) transposes of the right singular vectors
(i.e., the matrix <img class="math" src="_images/math/9de723874f4fca54fc9d4a4bf2f19c1b305b5a74.png" alt="V^H"/>) are returned in <code class="docutils literal notranslate"><span class="pre">Vt</span></code> or <code class="docutils literal notranslate"><span class="pre">A</span></code>.
The argument <code class="docutils literal notranslate"><span class="pre">Vt</span></code> can be <code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code> (if <code class="docutils literal notranslate"><span class="pre">jobvt</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'N'</span></code>
or <code class="xref py py-const docutils literal notranslate"><span class="pre">'A'</span></code>) or a matrix of the same type as <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
<p>On exit, the contents of <code class="docutils literal notranslate"><span class="pre">A</span></code> are destroyed.</p>
</dd></dl>

<dl class="py function">
<dt id="cvxopt.lapack.gesdd">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">gesdd</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">S</em><span class="optional">[</span>, <em class="sig-param">jobz = 'N'</em>, <em class="sig-param">U = None</em>, <em class="sig-param">Vt = None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.gesdd" title="Permalink to this definition">¶</a></dt>
<dd><p>Singular value decomposition of a real or complex <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> by
<img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> matrix..  This function is based on a divide-and-conquer
algorithm and is faster than <a class="reference internal" href="#cvxopt.lapack.gesdd" title="cvxopt.lapack.gesdd"><code class="xref py py-func docutils literal notranslate"><span class="pre">gesvd</span></code></a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">S</span></code> is a real matrix of length at least min{<img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/>, <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>}.
On exit, its first min{<img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/>, <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>} elements are the
singular values in descending order.</p>
<p>The argument <code class="docutils literal notranslate"><span class="pre">jobz</span></code> controls how many singular vectors are computed.
The possible values are <code class="xref py py-const docutils literal notranslate"><span class="pre">'N'</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">'A'</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">'S'</span></code> and
<code class="xref py py-const docutils literal notranslate"><span class="pre">'O'</span></code>.  If <code class="docutils literal notranslate"><span class="pre">jobz</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'N'</span></code>, no singular vectors are
computed.  If <code class="docutils literal notranslate"><span class="pre">jobz</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'A'</span></code>, all <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> left singular
vectors are computed and returned as columns of <code class="docutils literal notranslate"><span class="pre">U</span></code> and all
<img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> right singular vectors are computed and returned as rows of
<code class="docutils literal notranslate"><span class="pre">Vt</span></code>.  If <code class="docutils literal notranslate"><span class="pre">jobz</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'S'</span></code>, the first
min{<img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/>, <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>} left and right singular vectors are computed
and returned as columns of <code class="docutils literal notranslate"><span class="pre">U</span></code> and rows of <code class="docutils literal notranslate"><span class="pre">Vt</span></code>.
If <code class="docutils literal notranslate"><span class="pre">jobz</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'O'</span></code> and <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> is greater than or equal
to <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>, the first <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> left singular vectors are returned as
columns of <code class="docutils literal notranslate"><span class="pre">A</span></code> and the <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> right singular vectors are returned
as rows of <code class="docutils literal notranslate"><span class="pre">Vt</span></code>.  If <code class="docutils literal notranslate"><span class="pre">jobz</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'O'</span></code> and <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> is less
than <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>, the <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> left singular vectors are returned as
columns of <code class="docutils literal notranslate"><span class="pre">U</span></code> and the first <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> right singular vectors are
returned as rows of <code class="docutils literal notranslate"><span class="pre">A</span></code>.  Note that the (conjugate) transposes of
the right singular vectors are returned in <code class="docutils literal notranslate"><span class="pre">Vt</span></code> or <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
<p>The argument <code class="docutils literal notranslate"><span class="pre">U</span></code> can be <code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code> (if <code class="docutils literal notranslate"><span class="pre">jobz</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'N'</span></code>
or <code class="xref py py-const docutils literal notranslate"><span class="pre">'A'</span></code> of <code class="docutils literal notranslate"><span class="pre">jobz</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'O'</span></code> and <img class="math" src="_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> is greater
than or equal to  <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>)  or a matrix of the same type as <code class="docutils literal notranslate"><span class="pre">A</span></code>.
The argument <code class="docutils literal notranslate"><span class="pre">Vt</span></code> can be None(if <code class="docutils literal notranslate"><span class="pre">jobz</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'N'</span></code>
or <code class="xref py py-const docutils literal notranslate"><span class="pre">'A'</span></code> or <code class="docutils literal notranslate"><span class="pre">jobz</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'O'</span></code> and :math`m` is less than
<img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>) or a matrix of the same type as <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
<p>On exit, the contents of <code class="docutils literal notranslate"><span class="pre">A</span></code> are destroyed.</p>
</dd></dl>

</div>
<div class="section" id="schur-and-generalized-schur-factorization">
<h2>Schur and Generalized Schur Factorization<a class="headerlink" href="#schur-and-generalized-schur-factorization" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="cvxopt.lapack.gees">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">gees</code><span class="sig-paren">(</span><em class="sig-param">A</em><span class="optional">[</span>, <em class="sig-param">w = None</em>, <em class="sig-param">V = None</em>, <em class="sig-param">select = None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.gees" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Schur factorization</p>
<div class="math">
<p><img src="_images/math/86384124ce2e714ba7b80c295f44157d2da07413.png" alt="A = V S V^T \quad \mbox{($A$ real)}, \qquad
A = V S V^H \quad \mbox{($A$ complex)}"/></p>
</div><p>of a real or complex <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> by <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> matrix <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/>.</p>
<p>If <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> is real, the matrix of Schur vectors <img class="math" src="_images/math/e4762cec46619bf7781cae62216214f909395368.png" alt="V"/> is
orthogonal, and <img class="math" src="_images/math/b988975be41fd13b4d091c10202ba19374643586.png" alt="S"/> is a real upper quasi-triangular matrix with
1 by 1 or 2 by 2 diagonal blocks.  The 2 by 2 blocks correspond to
complex conjugate pairs of eigenvalues of <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/>.
If <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> is complex, the matrix of Schur vectors <img class="math" src="_images/math/e4762cec46619bf7781cae62216214f909395368.png" alt="V"/> is
unitary, and <img class="math" src="_images/math/b988975be41fd13b4d091c10202ba19374643586.png" alt="S"/> is a complex upper triangular matrix with the
eigenvalues of <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> on the diagonal.</p>
<p>The optional argument <code class="docutils literal notranslate"><span class="pre">w</span></code> is a complex matrix of length at least
<img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>.  If it is provided, the eigenvalues of <code class="docutils literal notranslate"><span class="pre">A</span></code> are returned
in <code class="docutils literal notranslate"><span class="pre">w</span></code>.  The optional argument <code class="docutils literal notranslate"><span class="pre">V</span></code> is an <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> by <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>
matrix of the same type as <code class="docutils literal notranslate"><span class="pre">A</span></code>.  If it is provided, then the Schur
vectors are returned in <code class="docutils literal notranslate"><span class="pre">V</span></code>.</p>
<p>The argument <code class="docutils literal notranslate"><span class="pre">select</span></code> is an optional ordering routine.  It must be a
Python function that can be called as <code class="docutils literal notranslate"><span class="pre">f(s)</span></code> with a complex
argument <code class="docutils literal notranslate"><span class="pre">s</span></code>, and returns <code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code> or <code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code>.  The
eigenvalues for which <code class="docutils literal notranslate"><span class="pre">select</span></code> returns <code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code> will be selected
to appear first along the diagonal.  (In the real Schur factorization,
if either one of a complex conjugate pair of eigenvalues is selected,
then both are selected.)</p>
<p>On exit, <code class="docutils literal notranslate"><span class="pre">A</span></code> is replaced with the matrix <img class="math" src="_images/math/b988975be41fd13b4d091c10202ba19374643586.png" alt="S"/>.  The function
<a class="reference internal" href="#cvxopt.lapack.gees" title="cvxopt.lapack.gees"><code class="xref py py-func docutils literal notranslate"><span class="pre">gees</span></code></a> returns an integer equal to the number of eigenvalues
that were selected by the ordering routine.  If <code class="docutils literal notranslate"><span class="pre">select</span></code> is
<code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code>, then <a class="reference internal" href="#cvxopt.lapack.gees" title="cvxopt.lapack.gees"><code class="xref py py-func docutils literal notranslate"><span class="pre">gees</span></code></a> returns 0.</p>
</dd></dl>

<p>As an example we compute the complex Schur form of the matrix</p>
<div class="math">
<p><img src="_images/math/b3b09dbd48529f16a62f1020d2172bb9551e3296.png" alt="A = \left[\begin{array}{rrrrr}
    -7 &amp;  -11 &amp; -6  &amp; -4 &amp;  11 \\
     5 &amp;  -3  &amp;  3  &amp; -12 &amp; 0 \\
    11 &amp;  11  &amp; -5  &amp; -14 &amp; 9 \\
    -4 &amp;   8  &amp;  0  &amp;  8 &amp;  6 \\
    13 &amp; -19  &amp; -12 &amp; -8 &amp; 10
    \end{array}\right]."/></p>
</div><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="o">-</span><span class="mf">7.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">,</span> <span class="mf">11.</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.</span><span class="p">,</span> <span class="mf">13.</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">11.</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">11.</span><span class="p">,</span> <span class="mf">8.</span><span class="p">,</span> <span class="o">-</span><span class="mf">19.</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">6.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">12.</span><span class="p">],</span>
<span class="go">                [-4., -12., -14., 8., -8.], [11., 0., 9., 6., 10.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">tc</span><span class="o">=</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lapack</span><span class="o">.</span><span class="n">gees</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="go">[ 5.67e+00+j1.69e+01 -2.13e+01+j2.85e+00  1.40e+00+j5.88e+00 -4.19e+00+j2.05e-01  3.19e+00-j1.01e+01]</span>
<span class="go">[ 0.00e+00-j0.00e+00  5.67e+00-j1.69e+01  1.09e+01+j5.93e-01 -3.29e+00-j1.26e+00 -1.26e+01+j7.80e+00]</span>
<span class="go">[ 0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  1.27e+01+j3.43e-17 -6.83e+00+j2.18e+00  5.31e+00-j1.69e+00]</span>
<span class="go">[ 0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  0.00e+00-j0.00e+00 -1.31e+01-j0.00e+00 -2.60e-01-j0.00e+00]</span>
<span class="go">[ 0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  0.00e+00-j0.00e+00 -7.86e+00-j0.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
<span class="go">[ 5.67e+00+j1.69e+01]</span>
<span class="go">[ 5.67e+00-j1.69e+01]</span>
<span class="go">[ 1.27e+01+j3.43e-17]</span>
<span class="go">[-1.31e+01-j0.00e+00]</span>
<span class="go">[-7.86e+00-j0.00e+00]</span>
</pre></div>
</div>
<p>An ordered Schur factorization with the eigenvalues in the left half of
the complex plane ordered first, can be computed as follows.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">tc</span><span class="o">=</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">real</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lapack</span><span class="o">.</span><span class="n">gees</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">select</span> <span class="o">=</span> <span class="n">F</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="go">[-1.31e+01-j0.00e+00 -1.72e-01+j7.93e-02 -2.81e+00+j1.46e+00  3.79e+00-j2.67e-01  5.14e+00-j4.84e+00]</span>
<span class="go">[ 0.00e+00-j0.00e+00 -7.86e+00-j0.00e+00 -1.43e+01+j8.31e+00  5.17e+00+j8.79e+00  2.35e+00-j7.86e-01]</span>
<span class="go">[ 0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  5.67e+00+j1.69e+01 -1.71e+01-j1.41e+01  1.83e+00-j4.63e+00]</span>
<span class="go">[ 0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  5.67e+00-j1.69e+01 -8.75e+00+j2.88e+00]</span>
<span class="go">[ 0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  1.27e+01+j3.43e-17]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
<span class="go">[-1.31e+01-j0.00e+00]</span>
<span class="go">[-7.86e+00-j0.00e+00]</span>
<span class="go">[ 5.67e+00+j1.69e+01]</span>
<span class="go">[ 5.67e+00-j1.69e+01]</span>
<span class="go">[ 1.27e+01+j3.43e-17]</span>
</pre></div>
</div>
<dl class="py function">
<dt id="cvxopt.lapack.gges">
<code class="sig-prename descclassname">cvxopt.lapack.</code><code class="sig-name descname">gges</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">B</em><span class="optional">[</span>, <em class="sig-param">a = None</em>, <em class="sig-param">b = None</em>, <em class="sig-param">Vl = None</em>, <em class="sig-param">Vr = None</em>, <em class="sig-param">select = None</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.lapack.gges" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the generalized Schur factorization</p>
<div class="math">
<p><img src="_images/math/d504b5e2a3245798a6ad5678ea1951fc914e8fac.png" alt="A = V_l S V_r^T, \quad B = V_l T V_r^T \quad
    \mbox{($A$ and $B$ real)},

A = V_l S V_r^H, \quad B = V_l T V_r^H, \quad
    \mbox{($A$ and $B$ complex)}"/></p>
</div><p>of a pair of real or complex <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> by <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> matrices
<img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/>, <img class="math" src="_images/math/4bc3e94a67870b41b7c20179693e889251e2c136.png" alt="B"/>.</p>
<p>If <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> and <img class="math" src="_images/math/4bc3e94a67870b41b7c20179693e889251e2c136.png" alt="B"/> are real, then the matrices of left and
right Schur vectors <img class="math" src="_images/math/808724526b9ab0aff711bd48855599a13f4f41c5.png" alt="V_l"/> and <img class="math" src="_images/math/4bcdc64a07db3d7711bc2889fe6459e2ae4e65d6.png" alt="V_r"/> are orthogonal,
<img class="math" src="_images/math/b988975be41fd13b4d091c10202ba19374643586.png" alt="S"/> is a real upper quasi-triangular matrix with 1 by 1 or 2 by
2 diagonal blocks, and <img class="math" src="_images/math/e8dea8254118f111b5fb20895b03528c17566f06.png" alt="T"/> is a real triangular matrix with
nonnegative diagonal.  The 2 by 2 blocks along the diagonal of
<img class="math" src="_images/math/b988975be41fd13b4d091c10202ba19374643586.png" alt="S"/> correspond to complex conjugate pairs of generalized
eigenvalues of <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/>, <img class="math" src="_images/math/4bc3e94a67870b41b7c20179693e889251e2c136.png" alt="B"/>.  If <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> and <img class="math" src="_images/math/4bc3e94a67870b41b7c20179693e889251e2c136.png" alt="B"/> are
complex, the matrices of left and right Schur vectors <img class="math" src="_images/math/808724526b9ab0aff711bd48855599a13f4f41c5.png" alt="V_l"/> and
<img class="math" src="_images/math/4bcdc64a07db3d7711bc2889fe6459e2ae4e65d6.png" alt="V_r"/> are unitary, <img class="math" src="_images/math/b988975be41fd13b4d091c10202ba19374643586.png" alt="S"/> is complex upper triangular, and
<img class="math" src="_images/math/e8dea8254118f111b5fb20895b03528c17566f06.png" alt="T"/> is complex upper triangular with nonnegative real diagonal.</p>
<p>The optional arguments <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> are <code class="xref py py-const docutils literal notranslate"><span class="pre">'z'</span></code> and
<code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> matrices of length at least <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/>.  If these are
provided, the generalized eigenvalues of <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code> are returned in
<code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>.  (The generalized eigenvalues are the ratios
<code class="docutils literal notranslate"><span class="pre">a[k]</span> <span class="pre">/</span> <span class="pre">b[k]</span></code>.)  The optional arguments <code class="docutils literal notranslate"><span class="pre">Vl</span></code> and <code class="docutils literal notranslate"><span class="pre">Vr</span></code> are
<img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> by <img class="math" src="_images/math/5a939c5280da7202ca4531f175a7780ad5e1f80a.png" alt="n"/> matrices of the same type as <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code>.
If they are provided, then the left Schur vectors are returned in
<code class="docutils literal notranslate"><span class="pre">Vl</span></code> and the right Schur vectors are returned in <code class="docutils literal notranslate"><span class="pre">Vr</span></code>.</p>
<p>The argument <code class="docutils literal notranslate"><span class="pre">select</span></code> is an optional ordering routine.  It must be
a Python function that can be called as <code class="docutils literal notranslate"><span class="pre">f(x,y)</span></code> with a complex
argument <code class="docutils literal notranslate"><span class="pre">x</span></code> and a real argument <code class="docutils literal notranslate"><span class="pre">y</span></code>, and returns <code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code> or
<code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code>.  The eigenvalues for which <code class="docutils literal notranslate"><span class="pre">select</span></code> returns
<code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code> will be selected to appear first on the diagonal.
(In the real Schur factorization, if either one of a complex conjugate
pair of eigenvalues is selected, then both are selected.)</p>
<p>On exit, <code class="docutils literal notranslate"><span class="pre">A</span></code> is replaced with the matrix <img class="math" src="_images/math/b988975be41fd13b4d091c10202ba19374643586.png" alt="S"/> and <code class="docutils literal notranslate"><span class="pre">B</span></code> is
replaced with the matrix <img class="math" src="_images/math/e8dea8254118f111b5fb20895b03528c17566f06.png" alt="T"/>.  The function <a class="reference internal" href="#cvxopt.lapack.gges" title="cvxopt.lapack.gges"><code class="xref py py-func docutils literal notranslate"><span class="pre">gges</span></code></a> returns
an integer equal to the number of eigenvalues that were selected by
the ordering routine.  If <code class="docutils literal notranslate"><span class="pre">select</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code>, then
<a class="reference internal" href="#cvxopt.lapack.gges" title="cvxopt.lapack.gges"><code class="xref py py-func docutils literal notranslate"><span class="pre">gges</span></code></a> returns 0.</p>
</dd></dl>

<p>As an example, we compute the generalized complex Schur form of the
matrix <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> of the previous example, and</p>
<div class="math">
<p><img src="_images/math/0e7509809ae807b340e6d7cd64cc157ce0c8a4ff.png" alt="B = \left[\begin{array}{ccccc}
    1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0
    \end{array}\right]."/></p>
</div><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="o">-</span><span class="mf">7.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">,</span> <span class="mf">11.</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.</span><span class="p">,</span> <span class="mf">13.</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">11.</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">11.</span><span class="p">,</span> <span class="mf">8.</span><span class="p">,</span> <span class="o">-</span><span class="mf">19.</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">6.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">12.</span><span class="p">],</span>
<span class="go">                [-4., -12., -14., 8., -8.], [11., 0., 9., 6., 10.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="p">[:</span><span class="mi">19</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">tc</span><span class="o">=</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">tc</span><span class="o">=</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lapack</span><span class="o">.</span><span class="n">gges</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="go">[ 6.64e+00-j8.87e+00 -7.81e+00-j7.53e+00  6.16e+00-j8.51e-01  1.18e+00+j9.17e+00  5.88e+00-j4.51e+00]</span>
<span class="go">[ 0.00e+00-j0.00e+00  8.48e+00+j1.13e+01 -2.12e-01+j1.00e+01  5.68e+00+j2.40e+00 -2.47e+00+j9.38e+00]</span>
<span class="go">[ 0.00e+00-j0.00e+00  0.00e+00-j0.00e+00 -1.39e+01-j0.00e+00  6.78e+00-j0.00e+00  1.09e+01-j0.00e+00]</span>
<span class="go">[ 0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  0.00e+00-j0.00e+00 -6.62e+00-j0.00e+00 -2.28e-01-j0.00e+00]</span>
<span class="go">[ 0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  0.00e+00-j0.00e+00 -2.89e+01-j0.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="go">[ 6.46e-01-j0.00e+00  4.29e-01-j4.79e-02  2.02e-01-j3.71e-01  1.08e-01-j1.98e-01 -1.95e-01+j3.58e-01]</span>
<span class="go">[ 0.00e+00-j0.00e+00  8.25e-01-j0.00e+00 -2.17e-01+j3.11e-01 -1.16e-01+j1.67e-01  2.10e-01-j3.01e-01]</span>
<span class="go">[ 0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  7.41e-01-j0.00e+00 -3.25e-01-j0.00e+00  5.87e-01-j0.00e+00]</span>
<span class="go">[ 0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  8.75e-01-j0.00e+00  4.84e-01-j0.00e+00]</span>
<span class="go">[ 0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  0.00e+00-j0.00e+00  0.00e+00-j0.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">[ 6.64e+00-j8.87e+00]</span>
<span class="go">[ 8.48e+00+j1.13e+01]</span>
<span class="go">[-1.39e+01-j0.00e+00]</span>
<span class="go">[-6.62e+00-j0.00e+00]</span>
<span class="go">[-2.89e+01-j0.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">[ 6.46e-01]</span>
<span class="go">[ 8.25e-01]</span>
<span class="go">[ 7.41e-01]</span>
<span class="go">[ 8.75e-01]</span>
<span class="go">[ 0.00e+00]</span>
</pre></div>
</div>
</div>
<div class="section" id="example-analytic-centering">
<h2>Example: Analytic Centering<a class="headerlink" href="#example-analytic-centering" title="Permalink to this headline">¶</a></h2>
<p>The analytic centering problem is defined as</p>
<div class="math">
<p><img src="_images/math/82d7fac4e1442a73c02aa8bd6fedab161db0f758.png" alt="\begin{array}{ll}
    \mbox{minimize} &amp; -\sum\limits_{i=1}^m \log(b_i-a_i^Tx).
\end{array}"/></p>
</div><p>In the code below we solve the problem using Newton’s method.  At each
iteration the Newton direction is computed by solving a positive definite
set of linear equations</p>
<div class="math">
<p><img src="_images/math/00e8f621cc91c8f430e504b66fb085743c4814cb.png" alt="\newcommand{\diag}{\mathop{\bf diag}}
\newcommand{\ones}{\mathbf 1}
A^T \diag(b-Ax)^{-2} A v = -\diag(b-Ax)^{-1}\ones"/></p>
</div><p>(where <img class="math" src="_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.png" alt="A"/> has rows <img class="math" src="_images/math/58dfeba24c101319ed253c88f1b03e306ab30e1f.png" alt="a_i^T"/>), and a suitable step size is
determined by a backtracking line search.</p>
<p>We use the level-3 BLAS function <a class="reference internal" href="blas.html#cvxopt.blas.syrk" title="cvxopt.blas.syrk"><code class="xref py py-func docutils literal notranslate"><span class="pre">blas.syrk</span></code></a> to
form the Hessian
matrix and the LAPACK function <a class="reference internal" href="#cvxopt.lapack.posv" title="cvxopt.lapack.posv"><code class="xref py py-func docutils literal notranslate"><span class="pre">posv</span></code></a> to
solve the Newton system.
The code can be further optimized by replacing the matrix-vector products
with the level-2 BLAS function <a class="reference internal" href="blas.html#cvxopt.blas.gemv" title="cvxopt.blas.gemv"><code class="xref py py-func docutils literal notranslate"><span class="pre">blas.gemv</span></code></a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">mul</span><span class="p">,</span> <span class="n">div</span><span class="p">,</span> <span class="n">blas</span><span class="p">,</span> <span class="n">lapack</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span>

<span class="k">def</span> <span class="nf">acent</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the analytic center of A*x &lt;= b.</span>
<span class="sd">    We assume that b &gt; 0 and the feasible set is bounded.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">MAXITERS</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="n">ALPHA</span> <span class="o">=</span> <span class="mf">0.01</span>
    <span class="n">BETA</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="n">TOL</span> <span class="o">=</span> <span class="mf">1e-8</span>

    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">size</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>

    <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">MAXITERS</span><span class="p">):</span>

        <span class="c1"># Gradient is g = A^T * (1./(b-A*x)).</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">A</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">**-</span><span class="mi">1</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">d</span>

        <span class="c1"># Hessian is H = A^T * diag(d)^2 * A.</span>
        <span class="n">Asc</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span> <span class="n">d</span><span class="p">[:,</span><span class="n">n</span><span class="o">*</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">A</span> <span class="p">)</span>
        <span class="n">blas</span><span class="o">.</span><span class="n">syrk</span><span class="p">(</span><span class="n">Asc</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">trans</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

        <span class="c1"># Newton step is v = -H^-1 * g.</span>
        <span class="n">v</span> <span class="o">=</span> <span class="o">-</span><span class="n">g</span>
        <span class="n">lapack</span><span class="o">.</span><span class="n">posv</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

        <span class="c1"># Terminate if Newton decrement is less than TOL.</span>
        <span class="n">lam</span> <span class="o">=</span> <span class="n">blas</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">lam</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">TOL</span><span class="p">:</span> <span class="k">return</span> <span class="n">x</span>

        <span class="c1"># Backtracking line search.</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
        <span class="n">step</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">while</span> <span class="mi">1</span><span class="o">-</span><span class="n">step</span><span class="o">*</span><span class="nb">max</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">step</span> <span class="o">*=</span> <span class="n">BETA</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="o">-</span><span class="nb">sum</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">step</span><span class="o">*</span><span class="n">y</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">ALPHA</span><span class="o">*</span><span class="n">step</span><span class="o">*</span><span class="n">lam</span><span class="p">:</span> <span class="k">break</span>
            <span class="n">step</span> <span class="o">*=</span> <span class="n">BETA</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="n">step</span><span class="o">*</span><span class="n">v</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="fftw.html" class="btn btn-neutral float-right" title="Discrete Transforms" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="blas.html" class="btn btn-neutral float-left" title="The BLAS Interface" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; <a href="copyright.html">Copyright</a> 2004-2020, M.S. Andersen, J. Dahl, L. Vandenberghe
      <span class="lastupdated">
        Last updated on Apr 16, 2020.
      </span>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
    <div class="footer">
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 3.0.1.
    </div>

</body>
</html>
<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Modeling &mdash; CVXOPT User&#39;s Guide</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="search" title="Search" href="search.html" />
    <link rel="copyright" title="Copyright" href="copyright.html" />
    <link rel="next" title="C API" href="c-api.html" />
    <link rel="prev" title="Nonlinear Convex Optimization" href="solvers.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> CVXOPT User's Guide
          </a>
              <div class="version">
                1.3.2
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="copyright.html">Copyright and License</a></li>
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrices.html">Dense and Sparse Matrices</a></li>
<li class="toctree-l1"><a class="reference internal" href="blas.html">The BLAS Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="lapack.html">The LAPACK Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="fftw.html">Discrete Transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="spsolvers.html">Sparse Linear Equations</a></li>
<li class="toctree-l1"><a class="reference internal" href="coneprog.html">Cone Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="solvers.html">Nonlinear Convex Optimization</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Modeling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#variables">Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="#functions">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#constraints">Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="#optimization-problems">Optimization Problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="#examples">Examples</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="c-api.html">C API</a></li>
<li class="toctree-l1"><a class="reference internal" href="printing.html">Matrix Formatting</a></li>
<li class="toctree-l1"><a class="reference external" href="http://cvxopt.org">cvxopt.org</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">CVXOPT User's Guide</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Modeling</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="modeling">
<span id="c-modeling"></span><h1>Modeling<a class="headerlink" href="#modeling" title="Permalink to this heading"></a></h1>
<p>The module <code class="xref py py-mod docutils literal notranslate"><span class="pre">cvxopt.modeling</span></code>  can be used to specify and solve
optimization problems  with convex piecewise-linear objective and
constraint functions.  Using this modeling tool, one can specify an
optimization problem by first defining the optimization variables (see the
section <a class="reference internal" href="#s-variables"><span class="std std-ref">Variables</span></a>), and then specifying the objective and
constraint functions using linear operations (vector addition and
subtraction, matrix-vector multiplication, indexing and slicing)
and nested evaluations of <code class="xref py py-func docutils literal notranslate"><span class="pre">max</span></code>,
<code class="xref py py-func docutils literal notranslate"><span class="pre">min</span></code>,
<code class="xref py py-func docutils literal notranslate"><span class="pre">abs</span></code> and
<a class="reference internal" href="#cvxopt.modeling.sum" title="cvxopt.modeling.sum"><code class="xref py py-func docutils literal notranslate"><span class="pre">sum</span></code></a> (see the section <a class="reference internal" href="#s-functions"><span class="std std-ref">Functions</span></a>).</p>
<p>A more general Python convex modeling package is
<a class="reference external" href="http://cvxpy.org">CVXPY</a>.</p>
<section id="variables">
<span id="s-variables"></span><h2>Variables<a class="headerlink" href="#variables" title="Permalink to this heading"></a></h2>
<p>Optimization variables are represented by <code class="xref py py-class docutils literal notranslate"><span class="pre">variable</span></code> objects.</p>
<dl class="py function">
<dt class="sig sig-object py" id="cvxopt.modeling.variable">
<span class="sig-prename descclassname"><span class="pre">cvxopt.modeling.</span></span><span class="sig-name descname"><span class="pre">variable</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.modeling.variable" title="Permalink to this definition"></a></dt>
<dd><p>A vector variable.  The first argument is the dimension of the vector
(a positive integer with default value 1).  The second argument is a
string with a name for the variable.  The name is optional and has
default value <code class="xref py py-const docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>. It is only used when displaying variables
(or objects that depend on variables, such as functions or constraints)
using <code class="xref py py-func docutils literal notranslate"><span class="pre">print</span></code> statements, when calling the built-in functions
<code class="xref py py-func docutils literal notranslate"><span class="pre">repr</span></code>  or <code class="xref py py-func docutils literal notranslate"><span class="pre">str</span></code>, or when writing linear programs to MPS
files.</p>
</dd></dl>

<p>The function <code class="xref py py-func docutils literal notranslate"><span class="pre">len</span></code> returns the length of a <code class="xref py py-class docutils literal notranslate"><span class="pre">variable</span></code>.
A <code class="xref py py-class docutils literal notranslate"><span class="pre">variable</span></code> <code class="docutils literal notranslate"><span class="pre">x</span></code> has two attributes.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="variable.name">
<span class="sig-prename descclassname"><span class="pre">variable.</span></span><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#variable.name" title="Permalink to this definition"></a></dt>
<dd><p>The name of the variable.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="variable.value">
<span class="sig-prename descclassname"><span class="pre">variable.</span></span><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#variable.value" title="Permalink to this definition"></a></dt>
<dd><p>Either <code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code> or a dense <code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> matrix of size
<code class="docutils literal notranslate"><span class="pre">len(x)</span></code> by 1.</p>
<p>The attribute <code class="docutils literal notranslate"><span class="pre">x.value</span></code> is set to <code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code> when the variable
<code class="docutils literal notranslate"><span class="pre">x</span></code> is created.   It can be given a numerical value later, typically
by solving an LP that has <code class="docutils literal notranslate"><span class="pre">x</span></code> as one of its variables.  One can also
make an explicit assignment <code class="docutils literal notranslate"><span class="pre">x.value</span> <span class="pre">=</span> <span class="pre">y</span></code>.  The assigned value
<code class="docutils literal notranslate"><span class="pre">y</span></code> must be an integer or float, or a dense <code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> matrix of
size <code class="docutils literal notranslate"><span class="pre">(len(x),</span> <span class="pre">1)</span></code>.  If <code class="docutils literal notranslate"><span class="pre">y</span></code> is an integer or float, all the
elements of <code class="docutils literal notranslate"><span class="pre">x.value</span></code> are set to the value of <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
</dd></dl>

<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt.modeling</span> <span class="kn">import</span> <span class="n">variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">variable</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="go">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">,</span><span class="mf">3.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">[ 1.00e+00]</span>
<span class="go">[ 2.00e+00]</span>
<span class="go">[ 3.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">[ 1.00e+00]</span>
<span class="go">[ 1.00e+00]</span>
<span class="go">[ 1.00e+00]</span>
</pre></div>
</div>
</section>
<section id="functions">
<span id="s-functions"></span><h2>Functions<a class="headerlink" href="#functions" title="Permalink to this heading"></a></h2>
<p>Objective and constraint functions can be defined via overloaded operations
on variables and other functions.  A function <code class="docutils literal notranslate"><span class="pre">f</span></code> is interpreted as a
column vector, with length <code class="docutils literal notranslate"><span class="pre">len(f)</span></code> and with a value that depends on
the values of its variables.  Functions have two public attributes.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="id0">
<span class="sig-name descname"><span class="pre">variables</span></span><a class="headerlink" href="#id0" title="Permalink to this definition"></a></dt>
<dd><p>Returns a copy of the list of variables of the function.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="value">
<span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#value" title="Permalink to this definition"></a></dt>
<dd><p>The function value.  If any of the variables of <code class="docutils literal notranslate"><span class="pre">f</span></code> has value
<code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code>, then <code class="docutils literal notranslate"><span class="pre">f.value()</span></code> returns <code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code>.  Otherwise,
it returns a dense <code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> matrix of size <code class="docutils literal notranslate"><span class="pre">(len(f),1)</span></code> with
the function value computed from the <a class="reference internal" href="#value" title="value"><code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code></a> attributes of the
variables of <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p>
</dd></dl>

<p>Three types of functions are supported: affine, convex piecewise-linear,
and concave piecewise-linear.</p>
<p><strong>Affine functions</strong> represent vector valued functions of the form</p>
<div class="math">
<p><img src="_images/math/e3a50552a1b736116240d899eea184ca3106ba0c.png" alt="f(x_1,\ldots,x_n) = A_1 x_1 + \cdots + A_n x_n + b."/></p>
</div><p>The coefficients can be scalars or dense or sparse matrices. The
constant term is a scalar or a column vector.</p>
<p>Affine functions result from the following operations.</p>
<dl>
<dt><strong>Unary operations</strong></dt><dd><p>For a variable <code class="docutils literal notranslate"><span class="pre">x</span></code>, the unary operation <code class="docutils literal notranslate"><span class="pre">+x</span></code> results in an
affine function with <code class="docutils literal notranslate"><span class="pre">x</span></code> as variable, coefficient 1.0, and constant
term 0.0.  The unary operation <code class="docutils literal notranslate"><span class="pre">-x</span></code> returns an affine function
with <code class="docutils literal notranslate"><span class="pre">x</span></code> as variable, coefficient -1.0, and constant term 0.0.  For
an affine function <code class="docutils literal notranslate"><span class="pre">f</span></code>, <code class="docutils literal notranslate"><span class="pre">+f</span></code> is a copy of <code class="docutils literal notranslate"><span class="pre">f</span></code>, and
<code class="docutils literal notranslate"><span class="pre">-f</span></code> is a copy of <code class="docutils literal notranslate"><span class="pre">f</span></code> with the signs of its coefficients and
constant term reversed.</p>
</dd>
<dt><strong>Addition and subtraction</strong></dt><dd><p>Sums and differences of affine functions, variables and constants result
in new affine functions.  The constant terms in the sum can be of type
integer or float, or dense or sparse <code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> matrices with one
column.</p>
<p>The rules for addition and subtraction follow the conventions for
matrix addition and subtraction in the section <a class="reference internal" href="matrices.html#s-arithmetic"><span class="std std-ref">Arithmetic Operations</span></a>,
with variables and affine functions interpreted as dense <code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code>
matrices with one column.  In particular, a scalar term (integer, float,
1 by 1 dense <code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> matrix, variable of length 1, or affine
function of length 1) can be added to an affine function or variable of
length greater than 1.</p>
</dd>
<dt><strong>Multiplication</strong></dt><dd><p>Suppose <code class="docutils literal notranslate"><span class="pre">v</span></code> is an affine function or a variable, and <code class="docutils literal notranslate"><span class="pre">a</span></code> is an
integer, float, sparse or dense <code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> matrix.  The products
<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">v</span></code> and  <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">*</span> <span class="pre">a</span></code> are valid affine functions whenever
the product is allowed under the rules for matrix and scalar
multiplication of the section <a class="reference internal" href="matrices.html#s-arithmetic"><span class="std std-ref">Arithmetic Operations</span></a>, with <code class="docutils literal notranslate"><span class="pre">v</span></code>
interpreted
as a <code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> matrix with one column.  In particular, the product
<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">v</span></code> is defined if <code class="docutils literal notranslate"><span class="pre">a</span></code> is a scalar (integer, float, or
1 by 1 dense <code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> matrix), or a matrix (dense or sparse) with
<code class="docutils literal notranslate"><span class="pre">a.size[1]</span></code> equal to <code class="docutils literal notranslate"><span class="pre">len(v)</span></code>.   The operation <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">*</span> <span class="pre">a</span></code>
is defined if <code class="docutils literal notranslate"><span class="pre">a</span></code> is scalar, or if <code class="docutils literal notranslate"><span class="pre">len(v)</span></code> is 1 and <code class="docutils literal notranslate"><span class="pre">a</span></code> is a
matrix with one column.</p>
</dd>
<dt><strong>Inner products</strong></dt><dd><p>The following two functions return scalar affine functions defined
as inner products of a constant vector with  a variable or affine
function.</p>
<dl class="py function">
<dt class="sig sig-object py" id="cvxopt.modeling.sum">
<span class="sig-prename descclassname"><span class="pre">cvxopt.modeling.</span></span><span class="sig-name descname"><span class="pre">sum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.modeling.sum" title="Permalink to this definition"></a></dt>
<dd><p>The argument is an affine function or a variable.  The result is an
affine function of length 1, with the sum of the components of the
argument <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cvxopt.modeling.dot">
<span class="sig-prename descclassname"><span class="pre">cvxopt.modeling.</span></span><span class="sig-name descname"><span class="pre">dot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.modeling.dot" title="Permalink to this definition"></a></dt>
<dd><p>If <code class="docutils literal notranslate"><span class="pre">v</span></code> is a variable or affine function and <code class="docutils literal notranslate"><span class="pre">u</span></code> is a
<code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> matrix of size <code class="docutils literal notranslate"><span class="pre">(len(v),</span> <span class="pre">1)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">dot(u,</span> <span class="pre">v)</span></code> and <code class="docutils literal notranslate"><span class="pre">dot(v,</span> <span class="pre">u)</span></code> are equivalent to
<code class="docutils literal notranslate"><span class="pre">u.trans()</span> <span class="pre">*</span> <span class="pre">v</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">u</span></code> and <code class="docutils literal notranslate"><span class="pre">v</span></code> are dense matrices, then <a class="reference internal" href="#cvxopt.modeling.dot" title="cvxopt.modeling.dot"><code class="xref py py-func docutils literal notranslate"><span class="pre">dot</span></code></a>
is equivalent to the function <a class="reference internal" href="blas.html#cvxopt.blas.dot" title="cvxopt.blas.dot"><code class="xref py py-func docutils literal notranslate"><span class="pre">blas.dot</span></code></a>,
i.e., it returns the inner product of the two matrices.</p>
</dd></dl>

</dd>
</dl>
<p>In the following example, the variable <code class="docutils literal notranslate"><span class="pre">x</span></code> has length 1 and <code class="docutils literal notranslate"><span class="pre">y</span></code> has
length 2.  The functions <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code> are given by</p>
<div class="math">
<p><img src="_images/math/7b25a0b8e9e5569bb0e977a9ea61b5daedb78e11.png" alt="f(x,y) &amp;= \left[ \begin{array}{c} 2 \\ 2 \end{array}\right] x
    + y + \left[ \begin{array}{c} 3 \\ 3 \end{array}\right], \\
g(x,y) &amp;=
    \left[ \begin{array}{cc} 1 &amp; 3 \\ 2 &amp; 4 \end{array}\right] f(x,y) +
    \left[ \begin{array}{cc} 1 &amp; 1 \\ 1 &amp; 1 \end{array} \right] y +
    \left[ \begin{array}{c} 1 \\ -1 \end{array} \right] \\
       &amp;= \left[ \begin{array}{c} 8 \\ 12 \end{array}\right] x +
   \left[ \begin{array}{cc} 2 &amp; 4 \\ 3 &amp; 5 \end{array}\right] y +
   \left[ \begin{array}{c} 13 \\ 17\end{array}\right]."/></p>
</div><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt.modeling</span> <span class="kn">import</span> <span class="n">variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">variable</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">variable</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">],</span> <span class="p">[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">4.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="o">-</span><span class="mf">1.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">A</span><span class="o">*</span><span class="n">f</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">affine function of length 2</span>
<span class="go">constant term:</span>
<span class="go">[ 1.30e+01]</span>
<span class="go">[ 1.70e+01]</span>
<span class="go">linear term: linear function of length 2</span>
<span class="go">coefficient of variable(2,&#39;y&#39;):</span>
<span class="go">[ 2.00e+00  4.00e+00]</span>
<span class="go">[ 3.00e+00  5.00e+00]</span>
<span class="go">coefficient of variable(1,&#39;x&#39;):</span>
<span class="go">[ 8.00e+00]</span>
<span class="go">[ 1.20e+01]</span>
</pre></div>
</div>
<dl class="simple">
<dt><strong>In-place operations</strong></dt><dd><p>For an affine function <code class="docutils literal notranslate"><span class="pre">f</span></code> the operations <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">+=</span> <span class="pre">u</span></code> and
<code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">-=</span> <span class="pre">u</span></code>, with <code class="docutils literal notranslate"><span class="pre">u</span></code> a constant, a variable or an affine function,
are allowed if they do not change the length of <code class="docutils literal notranslate"><span class="pre">f</span></code>, i.e., if <code class="docutils literal notranslate"><span class="pre">u</span></code>
has length <code class="docutils literal notranslate"><span class="pre">len(f)</span></code> or length 1.  In-place multiplication
<code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">*=</span> <span class="pre">u</span></code> and division <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">/=</span> <span class="pre">u</span></code> are allowed if <code class="docutils literal notranslate"><span class="pre">u</span></code> is an
integer, float, or 1 by 1 matrix.</p>
</dd>
<dt><strong>Indexing and slicing</strong></dt><dd><p>Variables and affine functions admit single-argument indexing of the
four types described in the section <a class="reference internal" href="matrices.html#s-indexing"><span class="std std-ref">Indexing and Slicing</span></a>.  The result of
an indexing or slicing operation is an affine function.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">variable</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">x</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">linear function of length 2</span>
<span class="go">linear term: linear function of length 2</span>
<span class="go">coefficient of variable(4,&#39;x&#39;):</span>
<span class="go">[ 1.00e+00     0         0         0    ]</span>
<span class="go">[    0         0      1.00e+00     0    ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">variable</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span><span class="s1">&#39;d&#39;</span><span class="p">)</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">g</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">affine function of length 1</span>
<span class="go">constant term:</span>
<span class="go">[ 2.00e+00]</span>
<span class="go">linear term: linear function of length 1</span>
<span class="go">coefficient of variable(4,&#39;x&#39;):</span>
<span class="go">[ 2.00e+00  8.00e+00  1.40e+01  2.00e+01]</span>
<span class="go">coefficient of variable(3,&#39;x&#39;):</span>
<span class="go">[-3.00e+00     0     -3.00e+00]</span>
</pre></div>
</div>
<p>The general expression of a <strong>convex piecewise-linear</strong> function is</p>
<div class="math">
<p><img src="_images/math/0f36e4d687eeb224ee6593ac11df99a1d4451ba9.png" alt="f(x_1,\ldots,x_n) = b + A_1 x_1 + \cdots + A_n x_n +
    \sum_{k=1}^K \max (y_1, y_2, \ldots, y_{m_k})."/></p>
</div><p>The maximum in this expression is a componentwise maximum of its vector
arguments, which can be constant vectors, variables, affine functions or
convex piecewise-linear functions.  The general expression for a
<strong>concave piecewise-linear</strong> function is</p>
<div class="math">
<p><img src="_images/math/620321226792601132c52174a5287a8c93e9bc5f.png" alt="f(x_1,\ldots,x_n) = b + A_1 x_1 + \cdots + A_n x_n +
    \sum_{k=1}^K \min (y_1, y_2, \ldots, y_{m_k})."/></p>
</div><p>Here the arguments of the <code class="xref py py-func docutils literal notranslate"><span class="pre">min</span></code>
can be constants, variables, affine
functions or concave piecewise-linear functions.</p>
<p>Piecewise-linear functions can be created using the following
operations.</p>
<dl>
<dt><strong>Maximum</strong></dt><dd><p>If the arguments in <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">max(y1,</span> <span class="pre">y2,</span> <span class="pre">...)</span></code> do not include any
variables or functions, then the Python built-in <code class="xref py py-func docutils literal notranslate"><span class="pre">max</span></code> is
evaluated.</p>
<p>If one or more of the arguments are variables or functions,
<code class="xref py py-func docutils literal notranslate"><span class="pre">max</span></code>
returns a piecewise-linear function defined as the elementwise maximum
of its arguments.  In other words,
<code class="docutils literal notranslate"><span class="pre">f[k]</span> <span class="pre">=</span> <span class="pre">max(y1[k],</span> <span class="pre">y2[k],</span> <span class="pre">...)</span></code> for <code class="docutils literal notranslate"><span class="pre">k</span></code> = 0, …,
<code class="docutils literal notranslate"><span class="pre">len(f)</span> <span class="pre">-</span> <span class="pre">1</span></code>.  The length of <code class="docutils literal notranslate"><span class="pre">f</span></code> is equal to the maximum of the
lengths of the arguments.  Each argument must have length equal to
<code class="docutils literal notranslate"><span class="pre">len(f)</span></code> or length one.  Arguments with length one are interpreted
as vectors of length <code class="docutils literal notranslate"><span class="pre">len(f)</span></code> with identical entries.</p>
<p>The arguments can be scalars of type integer or float, dense
<code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> matrices with one column, variables, affine functions or
convex piecewise-linear functions.</p>
<p>With one argument, <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">max(u)</span></code> is interpreted as
<code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">max(u[0],</span> <span class="pre">u[1],</span> <span class="pre">...,</span> <span class="pre">u[len(u)-1])</span></code>.</p>
</dd>
<dt><strong>Minimum</strong></dt><dd><p>Similar to <code class="xref py py-func docutils literal notranslate"><span class="pre">max</span></code> but returns a concave piecewise-linear
function.
The arguments can be scalars of type integer or float, dense
<code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> matrices with one column, variables, affine functions or
concave piecewise-linear functions.</p>
</dd>
<dt><strong>Absolute value</strong></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">u</span></code> is a variable or affine function then <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">abs(u)</span></code>
returns the convex piecewise-linear function <code class="docutils literal notranslate"><span class="pre">max(u,</span> <span class="pre">-u)</span></code>.</p>
</dd>
<dt><strong>Unary plus and minus</strong></dt><dd><p><code class="docutils literal notranslate"><span class="pre">+f</span></code> creates a copy of <code class="docutils literal notranslate"><span class="pre">f</span></code>.  <code class="docutils literal notranslate"><span class="pre">-f</span></code> is a concave
piecewise-linear function if <code class="docutils literal notranslate"><span class="pre">f</span></code> is convex and a convex
piecewise-linear function if <code class="docutils literal notranslate"><span class="pre">f</span></code> is concave.</p>
</dd>
<dt><strong>Addition and subtraction</strong></dt><dd><p>Sums and differences involving piecewise-linear functions are allowed
if they result in convex or concave functions.  For example, one can add
two convex or two concave functions, but not a convex and a concave
function.  The command <code class="docutils literal notranslate"><span class="pre">sum(f)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">f[0]</span> <span class="pre">+</span> <span class="pre">f[1]</span> <span class="pre">+</span> <span class="pre">...</span> <span class="pre">+</span> <span class="pre">f[len(f)</span> <span class="pre">-</span> <span class="pre">1]</span></code>.</p>
</dd>
<dt><strong>Multiplication</strong></dt><dd><p>Scalar multiplication <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">f</span></code> of a piecewise-linear function <code class="docutils literal notranslate"><span class="pre">f</span></code>
is defined if <code class="docutils literal notranslate"><span class="pre">a</span></code> is an integer, float, 1 by 1 <code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> matrix.
Matrix-matrix multiplications <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">f</span></code> or <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">*</span> <span class="pre">a</span></code> are only
defined if <code class="docutils literal notranslate"><span class="pre">a</span></code> is a dense or sparse 1 by 1 matrix.</p>
</dd>
<dt><strong>Indexing and slicing</strong></dt><dd><p>Piecewise-linear functions admit single-argument indexing of the four
types described in the section <a class="reference internal" href="matrices.html#s-indexing"><span class="std std-ref">Indexing and Slicing</span></a>.  The result of an
indexing or slicing operation is a new piecewise-linear function.</p>
</dd>
</dl>
<p>In the following example, <code class="docutils literal notranslate"><span class="pre">f</span></code> is the 1-norm of a vector variable <code class="docutils literal notranslate"><span class="pre">x</span></code> of
length 10, <code class="docutils literal notranslate"><span class="pre">g</span></code> is its infinity-norm, and <code class="docutils literal notranslate"><span class="pre">h</span></code> is the function</p>
<div class="math">
<p><img src="_images/math/d3b5cc5b170fbda975293f38dea08b951f37142f.png" alt="h(x) = \sum_k \phi(x[k]), \qquad
\phi(u) = \left\{\begin{array}{ll}
    0       &amp; |u| \leq 1 \\
    |u|-1   &amp; 1 \leq |u| \leq 2 \\
    2|u|-3  &amp; |u| \geq 2.
\end{array}\right."/></p>
</div><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt.modeling</span> <span class="kn">import</span> <span class="n">variable</span><span class="p">,</span> <span class="nb">max</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">variable</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
<dl class="simple">
<dt><strong>In-place operations</strong></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">f</span></code> is piecewise-linear then the in-place operations
<code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">+=</span> <span class="pre">u</span></code>, <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">-=</span> <span class="pre">u</span></code>, <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">*=</span> <span class="pre">u</span></code>, <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">/=</span> <span class="pre">u</span></code> are
defined if the corresponding expanded operations <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">f</span> <span class="pre">+</span> <span class="pre">u</span></code>,
<code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">f</span> <span class="pre">-</span> <span class="pre">u</span></code>, <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">f</span> <span class="pre">*</span> <span class="pre">u</span></code>, and <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">f/u</span></code> are defined
and if they do not change the length of <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p>
</dd>
</dl>
</section>
<section id="constraints">
<span id="s-constraints"></span><h2>Constraints<a class="headerlink" href="#constraints" title="Permalink to this heading"></a></h2>
<p>Linear equality and inequality constraints of the form</p>
<div class="math">
<p><img src="_images/math/12354e7e046bba1f8384eebcc70a2d9a09930e8e.png" alt="f(x_1,\ldots,x_n) = 0, \qquad f(x_1,\ldots,x_n) \preceq  0,"/></p>
</div><p>where <img class="math" src="_images/math/5b7752c757e0b691a80ab8227eadb8a8389dc58a.png" alt="f"/> is a convex function, are represented by <code class="xref py py-class docutils literal notranslate"><span class="pre">constraint</span></code>
objects.  Equality constraints are created by expressions of the form</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f1</span> <span class="o">==</span> <span class="n">f2</span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">f1</span></code> and <code class="docutils literal notranslate"><span class="pre">f2</span></code> can be any objects for which the difference
<code class="docutils literal notranslate"><span class="pre">f1</span> <span class="pre">-</span> <span class="pre">f2</span></code> yields an affine function.  Inequality constraints are
created by expressions of the form</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f1</span> <span class="o">&lt;=</span> <span class="n">f2</span>
<span class="n">f2</span> <span class="o">&gt;=</span> <span class="n">f1</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">f1</span></code> and <code class="docutils literal notranslate"><span class="pre">f2</span></code> can be any objects for which the difference
<code class="docutils literal notranslate"><span class="pre">f1</span> <span class="pre">-</span> <span class="pre">f2</span></code> yields a convex piecewise-linear function.  The comparison
operators first convert the expressions to <code class="docutils literal notranslate"><span class="pre">f1</span> <span class="pre">-</span> <span class="pre">f2</span> <span class="pre">==</span> <span class="pre">0</span></code>, resp.,
<code class="docutils literal notranslate"><span class="pre">f1</span> <span class="pre">-</span> <span class="pre">f2</span> <span class="pre">&lt;=</span> <span class="pre">0</span></code>, and then return a new <code class="xref py py-class docutils literal notranslate"><span class="pre">constraint</span></code> object with
constraint function <code class="docutils literal notranslate"><span class="pre">f1</span> <span class="pre">-</span> <span class="pre">f2</span></code>.</p>
<p>In the following example we create three constraints</p>
<div class="math">
<p><img src="_images/math/7dcb78b012b54b09f8760cec52ce8ae1389f0f11.png" alt="\newcommand{\ones}{{\bf 1}}
0 \preceq x \preceq \ones, \qquad \ones^T x = 2,"/></p>
</div><p>for a variable of length 5.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">variable</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c3</span> <span class="o">=</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>The built-in function <code class="xref py py-func docutils literal notranslate"><span class="pre">len</span></code> returns the dimension of the
constraint function.</p>
<p>Constraints have four public attributes.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="constraint.type">
<span class="sig-prename descclassname"><span class="pre">constraint.</span></span><span class="sig-name descname"><span class="pre">type</span></span><a class="headerlink" href="#constraint.type" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="xref py py-const docutils literal notranslate"><span class="pre">'='</span></code> if the constraint is an equality constraint, and
<strong>‘&lt;’</strong> if the constraint is an inequality constraint.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="constraint.value">
<span class="sig-prename descclassname"><span class="pre">constraint.</span></span><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#constraint.value" title="Permalink to this definition"></a></dt>
<dd><p>Returns the value of the constraint function.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="constraint.multiplier">
<span class="sig-prename descclassname"><span class="pre">constraint.</span></span><span class="sig-name descname"><span class="pre">multiplier</span></span><a class="headerlink" href="#constraint.multiplier" title="Permalink to this definition"></a></dt>
<dd><p>For a constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>, <code class="docutils literal notranslate"><span class="pre">c.multiplier</span></code> is a <code class="xref py py-class docutils literal notranslate"><span class="pre">variable</span></code>
object of dimension <code class="docutils literal notranslate"><span class="pre">len(c)</span></code>.  It is used to represent the
Lagrange multiplier or dual variable associated with the constraint.
Its value is initialized as <code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code>, and can be modified by making
an assignment to <code class="docutils literal notranslate"><span class="pre">c.multiplier.value</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="constraint.name">
<span class="sig-prename descclassname"><span class="pre">constraint.</span></span><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#constraint.name" title="Permalink to this definition"></a></dt>
<dd><p>The name of the constraint.  Changing the name of a constraint also
changes the name of the multiplier of <code class="docutils literal notranslate"><span class="pre">c</span></code>.  For example, the command
<code class="docutils literal notranslate"><span class="pre">c.name</span> <span class="pre">=</span> <span class="pre">'newname'</span></code> also changes
<code class="docutils literal notranslate"><span class="pre">c.multiplier.name</span></code> to <code class="docutils literal notranslate"><span class="pre">'newname_mul'</span></code>.</p>
</dd></dl>

</section>
<section id="optimization-problems">
<span id="s-lp"></span><h2>Optimization Problems<a class="headerlink" href="#optimization-problems" title="Permalink to this heading"></a></h2>
<p>Optimization problems are be constructed by calling the following
function.</p>
<dl class="py function">
<dt class="sig sig-object py" id="cvxopt.modeling.op">
<span class="sig-prename descclassname"><span class="pre">cvxopt.modeling.</span></span><span class="sig-name descname"><span class="pre">op</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">objective</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">constraints</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.modeling.op" title="Permalink to this definition"></a></dt>
<dd><p>The first argument specifies the objective function to be minimized.
It can be an affine or convex piecewise-linear function with length 1,
a <a class="reference internal" href="#cvxopt.modeling.variable" title="cvxopt.modeling.variable"><code class="xref py py-class docutils literal notranslate"><span class="pre">variable</span></code></a> with length 1, or a scalar constant (integer, float,
or 1 by 1 dense <code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> matrix).  The default value is 0.0.</p>
<p>The second argument is a single <code class="xref py py-class docutils literal notranslate"><span class="pre">constraint</span></code>, or a list of
<code class="xref py py-class docutils literal notranslate"><span class="pre">constraint</span></code> objects.  The default value is an empty list.</p>
<p>The third argument is a string with a name for the problem.
The default value is the empty string.</p>
</dd></dl>

<p>The following attributes and methods are useful for examining
and modifying optimization problems.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="op.objective">
<span class="sig-prename descclassname"><span class="pre">op.</span></span><span class="sig-name descname"><span class="pre">objective</span></span><a class="headerlink" href="#op.objective" title="Permalink to this definition"></a></dt>
<dd><p>The objective or cost function.  One can write to this attribute to
change the objective of an existing problem.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="op.variables">
<span class="sig-prename descclassname"><span class="pre">op.</span></span><span class="sig-name descname"><span class="pre">variables</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#op.variables" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of the variables of the problem.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="op.constraints">
<span class="sig-prename descclassname"><span class="pre">op.</span></span><span class="sig-name descname"><span class="pre">constraints</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#op.constraints" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of the constraints.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="op.inequalities">
<span class="sig-prename descclassname"><span class="pre">op.</span></span><span class="sig-name descname"><span class="pre">inequalities</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#op.inequalities" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of the inequality constraints.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="op.equalities">
<span class="sig-prename descclassname"><span class="pre">op.</span></span><span class="sig-name descname"><span class="pre">equalities</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#op.equalities" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of the equality constraints.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="op.delconstraint">
<span class="sig-prename descclassname"><span class="pre">op.</span></span><span class="sig-name descname"><span class="pre">delconstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">c</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#op.delconstraint" title="Permalink to this definition"></a></dt>
<dd><p>Deletes constraint <code class="docutils literal notranslate"><span class="pre">c</span></code> from the problem.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="op.addconstraint">
<span class="sig-prename descclassname"><span class="pre">op.</span></span><span class="sig-name descname"><span class="pre">addconstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">c</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#op.addconstraint" title="Permalink to this definition"></a></dt>
<dd><p>Adds constraint <code class="docutils literal notranslate"><span class="pre">c</span></code> to the problem.</p>
</dd></dl>

<p>An optimization problem with convex piecewise-linear objective and
constraints can be solved by calling the method <code class="xref py py-func docutils literal notranslate"><span class="pre">solve</span></code>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="op.solve">
<span class="sig-prename descclassname"><span class="pre">op.</span></span><span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">format</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#op.solve" title="Permalink to this definition"></a></dt>
<dd><p>This function converts the optimization problem to a linear program in
matrix form and then solves it using the solver described in
the section <a class="reference internal" href="coneprog.html#s-lpsolver"><span class="std std-ref">Linear Programming</span></a>.</p>
<p>The first argument is either <code class="xref py py-const docutils literal notranslate"><span class="pre">'dense'</span></code> or <code class="xref py py-const docutils literal notranslate"><span class="pre">'sparse'</span></code>, and
denotes the matrix types used in the matrix representation of the LP.
The default value is <code class="xref py py-const docutils literal notranslate"><span class="pre">'dense'</span></code>.</p>
<p>The second argument is either <code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">'glpk'</span></code>, or
<code class="xref py py-const docutils literal notranslate"><span class="pre">'mosek'</span></code>, and selects one of three available LP solvers: the
default solver written in Python, the GLPK solver (if installed) or the
MOSEK LP solver (if installed); see the section <a class="reference internal" href="coneprog.html#s-lpsolver"><span class="std std-ref">Linear Programming</span></a>.  The
default value is <code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>The solver reports the outcome of optimization by setting the attribute
<code class="xref py py-attr docutils literal notranslate"><span class="pre">self.status</span></code> and by modifying the <a class="reference internal" href="#value" title="value"><code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code></a> attributes of
the variables and the constraint multipliers of the problem.</p>
<ul class="simple">
<li><p>If the problem is solved to optimality, <code class="xref py py-attr docutils literal notranslate"><span class="pre">self.status</span></code> is set to
<code class="xref py py-const docutils literal notranslate"><span class="pre">'optimal'</span></code>.  The <a class="reference internal" href="#value" title="value"><code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code></a> attributes of the variables in
the problem  are set to their computed solutions, and the
<a class="reference internal" href="#value" title="value"><code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code></a> attributes of the multipliers of the constraints of the
problem are set to the computed dual optimal solution.</p></li>
<li><p>If it is determined that the problem is infeasible,
<code class="xref py py-attr docutils literal notranslate"><span class="pre">self.status</span></code> is set to <code class="xref py py-const docutils literal notranslate"><span class="pre">'primal</span> <span class="pre">infeasible'</span></code>.
The <a class="reference internal" href="#value" title="value"><code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code></a> attributes of the variables are set to
<code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code>.  The <a class="reference internal" href="#value" title="value"><code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code></a> attributes of the multipliers of
the constraints of the problem are set to a certificate of primal
infeasibility.  With the <code class="xref py py-const docutils literal notranslate"><span class="pre">'glpk'</span></code> option, <a class="reference internal" href="#op.solve" title="op.solve"><code class="xref py py-func docutils literal notranslate"><span class="pre">solve</span></code></a> does
not provide certificates of infeasibility.</p></li>
<li><p>If it is determined that the problem is dual infeasible,
<code class="xref py py-attr docutils literal notranslate"><span class="pre">self.status</span></code> is set to <code class="xref py py-const docutils literal notranslate"><span class="pre">'dual</span> <span class="pre">infeasible'</span></code>.
The <a class="reference internal" href="#value" title="value"><code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code></a> attributes of the multipliers of the constraints of
the problem are set to <code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code>.  The <a class="reference internal" href="#value" title="value"><code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code></a> attributes
of the variables are set to a certificate of dual infeasibility.
With the <code class="xref py py-const docutils literal notranslate"><span class="pre">'glpk'</span></code> option, <a class="reference internal" href="#op.solve" title="op.solve"><code class="xref py py-func docutils literal notranslate"><span class="pre">solve</span></code></a> does not provide
certificates of infeasibility.</p></li>
<li><p>If the problem was not solved successfully, <code class="xref py py-attr docutils literal notranslate"><span class="pre">self.status</span></code> is set
to <code class="xref py py-const docutils literal notranslate"><span class="pre">'unknown'</span></code>.  The <a class="reference internal" href="#value" title="value"><code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code></a> attributes of the variables
and the constraint multipliers are set to <code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
</ul>
</dd></dl>

<p>We refer to the section <a class="reference internal" href="coneprog.html#s-lpsolver"><span class="std std-ref">Linear Programming</span></a> for details on the algorithms and
the different solver options.</p>
<p>As an example we solve the LP</p>
<div class="math">
<p><img src="_images/math/3fd3b9b7b701e9534c715081f10fd72d4c4670f6.png" alt="\begin{array}{ll}
\mbox{minimize}   &amp; -4x - 5y \\
\mbox{subject to} &amp;  2x +y \leq 3 \\
                  &amp;  x +2y \leq 3 \\
                  &amp; x \geq 0, \quad y \geq 0.
\end{array}"/></p>
</div><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt.modeling</span> <span class="kn">import</span> <span class="n">op</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">variable</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">variable</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span> <span class="o">=</span> <span class="p">(</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">y</span> <span class="o">&lt;=</span> <span class="mi">3</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span> <span class="o">=</span> <span class="p">(</span> <span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">&lt;=</span> <span class="mi">3</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c3</span> <span class="o">=</span> <span class="p">(</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c4</span> <span class="o">=</span> <span class="p">(</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lp1</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">-</span><span class="mi">5</span><span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="n">c1</span><span class="p">,</span><span class="n">c2</span><span class="p">,</span><span class="n">c3</span><span class="p">,</span><span class="n">c4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lp1</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lp1</span><span class="o">.</span><span class="n">status</span>
<span class="go">&#39;optimal&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">lp1</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">value</span><span class="p">())</span>
<span class="go">[-9.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">[ 1.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">[ 1.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c1</span><span class="o">.</span><span class="n">multiplier</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">[ 1.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c2</span><span class="o">.</span><span class="n">multiplier</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">[ 2.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c3</span><span class="o">.</span><span class="n">multiplier</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">[ 2.87e-08]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c4</span><span class="o">.</span><span class="n">multiplier</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">[ 2.80e-08]</span>
</pre></div>
</div>
<p>We can solve the same LP in  matrix form as follows.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt.modeling</span> <span class="kn">import</span> <span class="n">op</span><span class="p">,</span> <span class="n">dot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">variable</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="mf">2.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="o">-</span><span class="mf">1.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span><span class="mf">3.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span><span class="o">-</span><span class="mf">4.</span><span class="p">,</span><span class="o">-</span><span class="mf">5.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ineq</span> <span class="o">=</span> <span class="p">(</span> <span class="n">A</span><span class="o">*</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">b</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lp2</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">x</span><span class="p">),</span> <span class="n">ineq</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lp2</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">lp2</span><span class="o">.</span><span class="n">objective</span><span class="o">.</span><span class="n">value</span><span class="p">())</span>
<span class="go">[-9.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">[ 1.00e+00]</span>
<span class="go">[ 1.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ineq</span><span class="o">.</span><span class="n">multiplier</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">[1.00e+00]</span>
<span class="go">[2.00e+00]</span>
<span class="go">[2.87e-08]</span>
<span class="go">[2.80e-08]</span>
</pre></div>
</div>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">op</span></code> class also includes two methods for writing and reading
files in
<a class="reference external" href="http://lpsolve.sourceforge.net/5.5/mps-format.htm">MPS format</a>.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">tofile(filename)</span> <span class="pre">:noindex:</span></span></dt>
<dd><p>If the problem is an LP, writes it to the file <cite>filename</cite> using the
MPS format.  Row and column labels are assigned based on the variable
and constraint names in the LP.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">fromfile(filename)</span> <span class="pre">:noindex:</span></span></dt>
<dd><p>Reads the LP from the file <cite>filename</cite>.  The file must be a fixed-format
MPS file.  Some features of the MPS format are not supported: comments
beginning with dollar signs, the row types ‘DE’, ‘DL’, ‘DG’, and ‘DN’,
and the capability of reading multiple righthand side, bound or range
vectors.</p>
</dd></dl>

</section>
<section id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this heading"></a></h2>
<p><strong>Norm and Penalty Approximation</strong></p>
<blockquote>
<div><p>In the first example we solve the norm approximation problems</p>
<div class="math">
<p><img src="_images/math/e3f4c5bf9e0470ceafd97d572163a4dfefc39743.png" alt="\begin{array}{ll}
\mbox{minimize} &amp; \|Ax - b\|_\infty,
\end{array}
\qquad
\begin{array}{ll}
\mbox{minimize} &amp; \|Ax - b\|_1
\end{array},"/></p>
</div><p>and the penalty approximation problem</p>
<div class="math">
<p><img src="_images/math/3910830c8976bd5c91219274bd08ca0401852b45.png" alt="\begin{array}{ll}
\mbox{minimize} &amp; \sum_k \phi((Ax-b)_k),
\end{array} \qquad
\phi(u) = \left\{\begin{array}{ll}
    0        &amp; |u| \leq 3/4 \\
    |u|-3/4  &amp; 3/4 \leq |u| \leq 3/2 \\
    2|u|-9/4 &amp; |u| \geq 3/2.
\end{array}\right."/></p>
</div><p>We use randomly generated data.</p>
<p>The code uses the <a class="reference external" href="http://matplotlib.sourceforge.net">Matplotlib</a>
package for plotting the histograms of the residual vectors for the
two solutions.  It generates the figure shown below.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">normal</span>
<span class="kn">from</span> <span class="nn">cvxopt.modeling</span> <span class="kn">import</span> <span class="n">variable</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="nb">sum</span>
<span class="kn">import</span> <span class="nn">pylab</span>

<span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">100</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">normal</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">normal</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

<span class="n">x1</span> <span class="o">=</span> <span class="n">variable</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="n">op</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">x1</span><span class="o">-</span><span class="n">b</span><span class="p">)))</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

<span class="n">x2</span> <span class="o">=</span> <span class="n">variable</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="n">op</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">x2</span><span class="o">-</span><span class="n">b</span><span class="p">)))</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

<span class="n">x3</span> <span class="o">=</span> <span class="n">variable</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="n">op</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">x3</span><span class="o">-</span><span class="n">b</span><span class="p">)</span><span class="o">-</span><span class="mf">0.75</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">x3</span><span class="o">-</span><span class="n">b</span><span class="p">)</span><span class="o">-</span><span class="mf">2.25</span><span class="p">)))</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

<span class="n">pylab</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">311</span><span class="p">)</span>
<span class="n">pylab</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">x1</span><span class="o">.</span><span class="n">value</span><span class="o">-</span><span class="n">b</span><span class="p">,</span> <span class="n">m</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span>
<span class="n">pylab</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">312</span><span class="p">)</span>
<span class="n">pylab</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">x2</span><span class="o">.</span><span class="n">value</span><span class="o">-</span><span class="n">b</span><span class="p">,</span> <span class="n">m</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span>
<span class="n">pylab</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">313</span><span class="p">)</span>
<span class="n">pylab</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">x3</span><span class="o">.</span><span class="n">value</span><span class="o">-</span><span class="n">b</span><span class="p">,</span> <span class="n">m</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span>
<span class="n">pylab</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/normappr.png"><img alt="_images/normappr.png" src="_images/normappr.png" style="width: 600px;" /></a>
<p>Equivalently, we can formulate and solve the problems as LPs.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">variable</span><span class="p">()</span>
<span class="n">x1</span> <span class="o">=</span> <span class="n">variable</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="n">op</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="n">t</span> <span class="o">&lt;=</span> <span class="n">A</span><span class="o">*</span><span class="n">x1</span><span class="o">-</span><span class="n">b</span><span class="p">,</span> <span class="n">A</span><span class="o">*</span><span class="n">x1</span><span class="o">-</span><span class="n">b</span><span class="o">&lt;=</span><span class="n">t</span><span class="p">])</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

<span class="n">u</span> <span class="o">=</span> <span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="n">x2</span> <span class="o">=</span> <span class="n">variable</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="n">op</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="p">[</span><span class="o">-</span><span class="n">u</span> <span class="o">&lt;=</span> <span class="n">A</span><span class="o">*</span><span class="n">x2</span><span class="o">+</span><span class="n">b</span><span class="p">,</span> <span class="n">A</span><span class="o">*</span><span class="n">x2</span><span class="o">+</span><span class="n">b</span> <span class="o">&lt;=</span> <span class="n">u</span><span class="p">])</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

<span class="n">v</span> <span class="o">=</span> <span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="n">x3</span> <span class="o">=</span> <span class="n">variable</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="n">op</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="p">[</span><span class="n">v</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">v</span> <span class="o">&gt;=</span> <span class="n">A</span><span class="o">*</span><span class="n">x3</span><span class="o">+</span><span class="n">b</span><span class="o">-</span><span class="mf">0.75</span><span class="p">,</span> <span class="n">v</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">x3</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="o">-</span><span class="mf">0.75</span><span class="p">,</span> <span class="n">v</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">x3</span><span class="o">-</span><span class="n">b</span><span class="p">)</span><span class="o">-</span><span class="mf">2.25</span><span class="p">,</span> <span class="n">v</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">x3</span><span class="o">-</span><span class="n">b</span><span class="p">)</span><span class="o">-</span><span class="mf">2.25</span><span class="p">])</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>Robust Linear Programming</strong></p>
<blockquote>
<div><p>The robust LP</p>
<div class="math">
<p><img src="_images/math/6b3a21804f75fb45e7f9963fc6c0621fcf710cc7.png" alt="\begin{array}{ll}
\mbox{minimize}   &amp; c^T x \\
\mbox{subject to} &amp; \sup_{\|v\|_\infty \leq 1}
                    (a_i+v)^T x \leq b_i, \qquad i=1,\ldots,m
\end{array}"/></p>
</div><p>is equivalent to the problem</p>
<div class="math">
<p><img src="_images/math/d9aec1e99d1bcb92578727e61fb60d877c0964b7.png" alt="\begin{array}{ll}
\mbox{minimize} &amp; c^Tx \\
\mbox{subject to} &amp; a_i^Tx + \|x\|_1 \leq b_i, \qquad i=1,\ldots,m.
\end{array}"/></p>
</div><p>The following code computes the solution and the solution of the
equivalent LP</p>
<div class="math">
<p><img src="_images/math/306121f2c5a959611abb74ce19acd25173d3cb33.png" alt="\newcommand{\ones}{{\bf 1}}
\begin{array}{ll}
\mbox{minimize}   &amp; c^Tx \\
\mbox{subject to} &amp; a_i^Tx + \ones^Ty \leq b_i,
                    \qquad i=1,\ldots,m \\
                  &amp; -y \preceq x \preceq y
\end{array}"/></p>
</div><p>for randomly generated data.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">normal</span><span class="p">,</span> <span class="n">uniform</span>
<span class="kn">from</span> <span class="nn">cvxopt.modeling</span> <span class="kn">import</span> <span class="n">variable</span><span class="p">,</span> <span class="n">dot</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="nb">sum</span>

<span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">100</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">normal</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">uniform</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">normal</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">variable</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="n">op</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">x</span><span class="p">),</span> <span class="n">A</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

<span class="n">x2</span> <span class="o">=</span> <span class="n">variable</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">variable</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="n">op</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">x2</span><span class="p">),</span> <span class="p">[</span><span class="n">A</span><span class="o">*</span><span class="n">x2</span><span class="o">+</span><span class="nb">sum</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="n">y</span> <span class="o">&lt;=</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x2</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="p">])</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>1-Norm Support Vector Classifier</strong></p>
<blockquote>
<div><p>The following problem arises in classification:</p>
<div class="math">
<p><img src="_images/math/4786cdb10b56effd1cbd6730d8a8497748d072c0.png" alt="\newcommand{\ones}{{\bf 1}}
\begin{array}{ll}
\mbox{minimize}   &amp; \|x\|_1 + \ones^Tu \\
\mbox{subject to} &amp; Ax \succeq \ones -u \\
                  &amp; u \succeq 0.
\end{array}"/></p>
</div><p>It can be solved as follows.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">variable</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">variable</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>
<span class="n">op</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="p">[</span><span class="n">A</span><span class="o">*</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">-</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
<p>An equivalent unconstrained formulation is</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">variable</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="n">op</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="o">-</span><span class="n">A</span><span class="o">*</span><span class="n">x</span><span class="p">)))</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="solvers.html" class="btn btn-neutral float-left" title="Nonlinear Convex Optimization" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="c-api.html" class="btn btn-neutral float-right" title="C API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; <a href="copyright.html">Copyright</a> 2004-2023, M.S. Andersen, J. Dahl, L. Vandenberghe.
      <span class="lastupdated">Last updated on Aug 09, 2023.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <div class="footer">
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 5.0.1.
    </div>

</body>
</html>
<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dense and Sparse Matrices &mdash; CVXOPT User&#39;s Guide</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="search" title="Search" href="search.html" />
    <link rel="copyright" title="Copyright" href="copyright.html" />
    <link rel="next" title="The BLAS Interface" href="blas.html" />
    <link rel="prev" title="Introduction" href="intro.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> CVXOPT User's Guide
          </a>
              <div class="version">
                1.3.2
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="copyright.html">Copyright and License</a></li>
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Dense and Sparse Matrices</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#dense-matrices">Dense Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sparse-matrices">Sparse Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="#arithmetic-operations">Arithmetic Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#indexing-and-slicing">Indexing and Slicing</a></li>
<li class="toctree-l2"><a class="reference internal" href="#attributes-and-methods">Attributes and Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="#built-in-functions">Built-In Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#other-matrix-functions">Other Matrix Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#randomly-generated-matrices">Randomly Generated Matrices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="blas.html">The BLAS Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="lapack.html">The LAPACK Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="fftw.html">Discrete Transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="spsolvers.html">Sparse Linear Equations</a></li>
<li class="toctree-l1"><a class="reference internal" href="coneprog.html">Cone Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="solvers.html">Nonlinear Convex Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="modeling.html">Modeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="c-api.html">C API</a></li>
<li class="toctree-l1"><a class="reference internal" href="printing.html">Matrix Formatting</a></li>
<li class="toctree-l1"><a class="reference external" href="http://cvxopt.org">cvxopt.org</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">CVXOPT User's Guide</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Dense and Sparse Matrices</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="dense-and-sparse-matrices">
<span id="c-matrices"></span><h1>Dense and Sparse Matrices<a class="headerlink" href="#dense-and-sparse-matrices" title="Permalink to this heading"></a></h1>
<p>This chapter describes the two CVXOPT matrix types:
<a class="reference internal" href="#cvxopt.matrix" title="cvxopt.matrix"><code class="xref py py-class docutils literal notranslate"><span class="pre">matrix</span></code></a> objects, used for dense matrix
computations, and <a class="reference internal" href="#cvxopt.spmatrix" title="cvxopt.spmatrix"><code class="xref py py-class docutils literal notranslate"><span class="pre">spmatrix</span></code></a> objects, used for
sparse matrix computations.</p>
<section id="dense-matrices">
<span id="s-dense-matrices"></span><h2>Dense Matrices<a class="headerlink" href="#dense-matrices" title="Permalink to this heading"></a></h2>
<p>A dense matrix is created by calling the function <code class="xref py py-func docutils literal notranslate"><span class="pre">matrix</span></code>.  The
arguments specify the values of the coefficients, the dimensions, and the
type (integer, double, or complex) of the matrix.</p>
<dl class="py function">
<dt class="sig sig-object py" id="cvxopt.matrix">
<span class="sig-prename descclassname"><span class="pre">cvxopt.</span></span><span class="sig-name descname"><span class="pre">matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">size</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">tc</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.matrix" title="Permalink to this definition"></a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">size</span></code>  is a tuple of length two with the matrix dimensions.
The number of rows and/or the number of columns can be zero.</p>
<p><code class="docutils literal notranslate"><span class="pre">tc</span></code>  stands for type code. The possible values are <code class="xref py py-const docutils literal notranslate"><span class="pre">'i'</span></code>,
<code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code>, and <code class="xref py py-const docutils literal notranslate"><span class="pre">'z'</span></code>, for integer, real (double), and complex
matrices, respectively.</p>
<p><code class="docutils literal notranslate"><span class="pre">x</span></code>  can be a number, a sequence of numbers, a dense or sparse
matrix, a one- or two-dimensional NumPy array, or a list of lists of
matrices and numbers.</p>
<ul>
<li><p>If <code class="docutils literal notranslate"><span class="pre">x</span></code> is a number (Python integer, float, or complex number),
a matrix is created with the dimensions specified by <code class="docutils literal notranslate"><span class="pre">size</span></code> and
with all the coefficients equal to <code class="docutils literal notranslate"><span class="pre">x</span></code>.
The default value of <code class="docutils literal notranslate"><span class="pre">size</span></code>  is <code class="docutils literal notranslate"><span class="pre">(1,1)</span></code>, and the default value
of <code class="docutils literal notranslate"><span class="pre">tc</span></code> is the type of <code class="docutils literal notranslate"><span class="pre">x</span></code>.
If necessary, the type of <code class="docutils literal notranslate"><span class="pre">x</span></code> is converted (from integer to double
when used to create a matrix of type <code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code>, and from integer or
double to complex when used to create a matrix of type <code class="xref py py-const docutils literal notranslate"><span class="pre">'z'</span></code>).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ 1  1  1  1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ 1.00e+00  1.00e+00  1.00e+00  1.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ 1.00e+00+j1.00e+00]</span>
</pre></div>
</div>
</li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">x</span></code> is a sequence of numbers (list, tuple, array,
<code class="xref py py-mod docutils literal notranslate"><span class="pre">array</span></code> array, …), then the numbers are interpreted as the
coefficients of a matrix in column-major order.
The length of <code class="docutils literal notranslate"><span class="pre">x</span></code>  must be equal to the product of
<code class="docutils literal notranslate"><span class="pre">size[0]</span></code> and <code class="docutils literal notranslate"><span class="pre">size[1]</span></code>.
If <code class="docutils literal notranslate"><span class="pre">size</span></code>  is not specified, a matrix with one column is created.
If <code class="docutils literal notranslate"><span class="pre">tc</span></code>  is not specified, it is determined from the elements of
<code class="docutils literal notranslate"><span class="pre">x</span></code>  (and if that is impossible, for example because <code class="docutils literal notranslate"><span class="pre">x</span></code>  is
an empty list, a value <code class="xref py py-const docutils literal notranslate"><span class="pre">'i'</span></code> is used).
Type conversion takes place as for scalar <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>The following example shows several ways to define the same integer
matrix.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">array</span> <span class="kn">import</span> <span class="n">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ 0  2]</span>
<span class="go">[ 1  3]</span>
</pre></div>
</div>
<p>In Python 2.7 the following also works.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">xrange</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
</li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">x</span></code>  is a dense or sparse matrix, then the coefficients of
<code class="docutils literal notranslate"><span class="pre">x</span></code>  are copied, in column-major order, to a new matrix of the
given size.
The total number of elements in the new matrix (the product of
<code class="docutils literal notranslate"><span class="pre">size[0]</span></code> and <code class="docutils literal notranslate"><span class="pre">size[1]</span></code>) must be the same as the product
of  the dimensions of <code class="docutils literal notranslate"><span class="pre">x</span></code>.  If <code class="docutils literal notranslate"><span class="pre">size</span></code>  is not specified, the
dimensions of <code class="docutils literal notranslate"><span class="pre">x</span></code>  are used.
The default value of <code class="docutils literal notranslate"><span class="pre">tc</span></code>  is the type of <code class="docutils literal notranslate"><span class="pre">x</span></code>.
Type conversion takes place when the type of <code class="docutils literal notranslate"><span class="pre">x</span></code> differs from
<code class="docutils literal notranslate"><span class="pre">tc</span></code>, in a similar way as for scalar <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">],</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ 1.00e+00  3.00e+00  5.00e+00]</span>
<span class="go">[ 2.00e+00  4.00e+00  6.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">[ 1.00e+00  4.00e+00]</span>
<span class="go">[ 2.00e+00  5.00e+00]</span>
<span class="go">[ 3.00e+00  6.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">tc</span><span class="o">=</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go">[ 1.00e+00-j0.00e+00  4.00e+00-j0.00e+00]</span>
<span class="go">[ 2.00e+00-j0.00e+00  5.00e+00-j0.00e+00]</span>
<span class="go">[ 3.00e+00-j0.00e+00  6.00e+00-j0.00e+00]</span>
</pre></div>
</div>
<p>NumPy arrays can be converted to matrices.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">],</span> <span class="p">[</span><span class="mf">4.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[ 1.  2.  3.]</span>
<span class="go">       [ 4.  5.  6.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">matrix</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">[ 1.00e+00  2.00e+00  3.00e+00]</span>
<span class="go">[ 4.00e+00  5.00e+00  6.00e+00]</span>
</pre></div>
</div>
</li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">x</span></code> is a list of lists of dense or sparse matrices
and numbers (Python integer, float, or complex),
then each element of <code class="docutils literal notranslate"><span class="pre">x</span></code> is interpreted as a
block-column stored in column-major order.
If <code class="docutils literal notranslate"><span class="pre">size</span></code> is not specified, the block-columns are juxtaposed
to obtain a matrix with <code class="docutils literal notranslate"><span class="pre">len(x)</span></code>  block-columns.
If <code class="docutils literal notranslate"><span class="pre">size</span></code> is specified, then the matrix with <code class="docutils literal notranslate"><span class="pre">len(x)</span></code>
block-columns is resized by copying its elements in column-major
order into a matrix of the dimensions given by <code class="docutils literal notranslate"><span class="pre">size</span></code>.
If <code class="docutils literal notranslate"><span class="pre">tc</span></code> is not specified, it is determined from the elements of
<code class="docutils literal notranslate"><span class="pre">x</span></code> (and if that is impossible, for example because <code class="docutils literal notranslate"><span class="pre">x</span></code> is
a list of empty lists, a value <code class="xref py py-const docutils literal notranslate"><span class="pre">'i'</span></code> is used).
The same rules for type conversion apply as for scalar <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">matrix</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">],</span> <span class="p">[</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">],</span> <span class="p">[</span><span class="mf">5.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">]]))</span>
<span class="go">[ 1.00e+00  3.00e+00  5.00e+00]</span>
<span class="go">[ 2.00e+00  4.00e+00  6.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A1</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B1</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">],</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B2</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span><span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">17</span><span class="p">],</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B3</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span><span class="mi">18</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="n">A1</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">],</span> <span class="p">[</span><span class="n">B1</span><span class="p">,</span> <span class="n">B2</span><span class="p">,</span> <span class="n">B3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go">[ 1.00e+00  6.00e+00  8.00e+00  1.00e+01]</span>
<span class="go">[ 2.00e+00  7.00e+00  9.00e+00  1.10e+01]</span>
<span class="go">[ 3.00e+00  1.20e+01  1.40e+01  1.60e+01]</span>
<span class="go">[ 4.00e+00  1.30e+01  1.50e+01  1.70e+01]</span>
<span class="go">[ 5.00e+00  1.80e+01  1.90e+01  2.00e+01]</span>
</pre></div>
</div>
<p>A matrix with a single block-column can be represented by a single
list (i.e., if <code class="docutils literal notranslate"><span class="pre">x</span></code> is a list of lists, and has length one,
then the argument <code class="docutils literal notranslate"><span class="pre">x</span></code> can be replaced by <code class="docutils literal notranslate"><span class="pre">x[0]</span></code>).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span><span class="n">B1</span><span class="p">,</span> <span class="n">B2</span><span class="p">,</span> <span class="n">B3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="go">[  6   8  10]</span>
<span class="go">[  7   9  11]</span>
<span class="go">[ 12  14  16]</span>
<span class="go">[ 13  15  17]</span>
<span class="go">[ 18  19  20]</span>
</pre></div>
</div>
</li>
</ul>
</dd></dl>

</section>
<section id="sparse-matrices">
<span id="s-sparse-matrices"></span><h2>Sparse Matrices<a class="headerlink" href="#sparse-matrices" title="Permalink to this heading"></a></h2>
<p>A general <a class="reference internal" href="#cvxopt.spmatrix" title="cvxopt.spmatrix"><code class="xref py py-class docutils literal notranslate"><span class="pre">spmatrix</span></code></a> object can be thought of as
a <em>triplet description</em> of a sparse matrix, i.e., a list of entries of the
matrix, with for each entry the value, row index, and column index.
Entries that are not included in the list are assumed to be zero.
For example, the sparse matrix</p>
<div class="math">
<p><img src="_images/math/0790b49262067229d1ce8165c4a66b4afa62cda9.png" alt="A = \left[ \begin{array}{rrrrr}
    0 &amp; 2 &amp; 0 &amp; 0 &amp; 3 \\
    2 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
   -1 &amp; -2 &amp; 0 &amp; 4 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \end{array} \right]"/></p>
</div><p>has the triplet description</p>
<div class="math">
<p><img src="_images/math/8edd44acd8c3889706afee3c81bb907c3f415683.png" alt="(2,1,0), \qquad (-1,2,0), \qquad (2,0,1), \qquad (-2,2,1), \qquad
(1,3,2), \qquad (4,2,3), \qquad (3,0,4)."/></p>
</div><p>The list may include entries with a zero value, so triplet descriptions
are not necessarily unique.  The list</p>
<div class="math">
<p><img src="_images/math/10d754c37b304c217ee6f80c9a3c4c7bcbbcba9d.png" alt="(2,1,0), \qquad (-1,2,0), \qquad (0,3,0), \qquad (2,0,1), \qquad
(-2,2,1), \qquad (1,3,2), \qquad (4,2,3), \qquad (3,0,4)"/></p>
</div><p>is another triplet description of the same matrix.</p>
<p>An <code class="xref py py-class docutils literal notranslate"><span class="pre">spmatrix</span></code> object corresponds to a particular
triplet description of a sparse matrix.  We will refer to the entries in
the triplet description as the <em>nonzero entries</em> of the object,
even though they may have a numerical value zero.</p>
<p>Three functions are provided to create sparse matrices.
The first, <code class="xref py py-func docutils literal notranslate"><span class="pre">spmatrix</span></code>,
constructs a sparse matrix from a triplet description.</p>
<dl class="py function">
<dt class="sig sig-object py" id="cvxopt.spmatrix">
<span class="sig-prename descclassname"><span class="pre">cvxopt.</span></span><span class="sig-name descname"><span class="pre">spmatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">I</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">J</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">size</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">tc</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.spmatrix" title="Permalink to this definition"></a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">I</span></code> and <code class="docutils literal notranslate"><span class="pre">J</span></code> are sequences of integers (lists, tuples,
<code class="xref py py-mod docutils literal notranslate"><span class="pre">array</span></code> arrays, …) or integer matrices
(<a class="reference internal" href="#cvxopt.matrix" title="cvxopt.matrix"><code class="xref py py-class docutils literal notranslate"><span class="pre">matrix</span></code></a> objects with typecode <code class="xref py py-const docutils literal notranslate"><span class="pre">'i'</span></code>),
containing the row and column indices of the nonzero entries.
The lengths of <code class="docutils literal notranslate"><span class="pre">I</span></code> and <code class="docutils literal notranslate"><span class="pre">J</span></code> must be  equal.  If they are matrices,
they are treated as lists of indices stored in column-major order,
i.e., as lists <code class="docutils literal notranslate"><span class="pre">list(I)</span></code>, respectively, <code class="docutils literal notranslate"><span class="pre">list(J)</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">size</span></code> is a tuple of nonnegative integers with the row and column
dimensions of the matrix.
The <code class="docutils literal notranslate"><span class="pre">size</span></code> argument is only needed when creating a matrix with
a zero last row or last column.  If <code class="docutils literal notranslate"><span class="pre">size</span></code> is not specified, it
is determined from <code class="docutils literal notranslate"><span class="pre">I</span></code> and <code class="docutils literal notranslate"><span class="pre">J</span></code>:
the default value for <code class="docutils literal notranslate"><span class="pre">size[0]</span></code> is <code class="docutils literal notranslate"><span class="pre">max(I)+1</span></code> if <code class="docutils literal notranslate"><span class="pre">I</span></code> is
nonempty and zero otherwise.
The default value for <code class="docutils literal notranslate"><span class="pre">size[1]</span></code> is <code class="docutils literal notranslate"><span class="pre">max(J)+1</span></code> if <code class="docutils literal notranslate"><span class="pre">J</span></code> is
nonempty and zero otherwise.</p>
<p><code class="docutils literal notranslate"><span class="pre">tc</span></code> is the typecode, <code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> or <code class="xref py py-const docutils literal notranslate"><span class="pre">'z'</span></code>, for double and
complex matrices, respectively.   Integer sparse matrices are
not implemented.</p>
<p><code class="docutils literal notranslate"><span class="pre">x</span></code> can be a number, a sequence of numbers, or a dense matrix.
This argument specifies the numerical values of the nonzero entries.</p>
<ul>
<li><p>If <code class="docutils literal notranslate"><span class="pre">x</span></code> is a number (Python integer, float, or complex),
a matrix is created with the sparsity pattern defined by <code class="docutils literal notranslate"><span class="pre">I</span></code> and
<code class="docutils literal notranslate"><span class="pre">J</span></code>, and nonzero entries initialized to the value of <code class="docutils literal notranslate"><span class="pre">x</span></code>.
The default value of <code class="docutils literal notranslate"><span class="pre">tc</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> if <code class="docutils literal notranslate"><span class="pre">x</span></code> is integer or
float, and <code class="xref py py-const docutils literal notranslate"><span class="pre">'z'</span></code> if <code class="docutils literal notranslate"><span class="pre">x</span></code>  is complex.</p>
<p>The following code creates a 4 by 4 sparse identity matrix.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">spmatrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">   [ 1.00e+00     0         0         0    ]</span>
<span class="go">   [    0      1.00e+00     0         0    ]</span>
<span class="go">   [    0         0      1.00e+00     0    ]</span>
<span class="go">   [    0         0         0      1.00e+00]</span>
</pre></div>
</div>
</li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">x</span></code> is a sequence of numbers, a sparse matrix is created
with the entries of <code class="docutils literal notranslate"><span class="pre">x</span></code> copied to the entries indexed by <code class="docutils literal notranslate"><span class="pre">I</span></code>
and <code class="docutils literal notranslate"><span class="pre">J</span></code>.  The list <code class="docutils literal notranslate"><span class="pre">x</span></code> must have the same length as <code class="docutils literal notranslate"><span class="pre">I</span></code> and
<code class="docutils literal notranslate"><span class="pre">J</span></code>.
The default value of <code class="docutils literal notranslate"><span class="pre">tc</span></code> is determined from the elements of <code class="docutils literal notranslate"><span class="pre">x</span></code>:
<code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> if <code class="docutils literal notranslate"><span class="pre">x</span></code> contains integers and floating-point numbers or
if <code class="docutils literal notranslate"><span class="pre">x</span></code> is an empty list, and <code class="xref py py-const docutils literal notranslate"><span class="pre">'z'</span></code> if <code class="docutils literal notranslate"><span class="pre">x</span></code> contains at
least one complex number.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">  [    0      2.00e+00     0         0      3.00e+00]</span>
<span class="go">  [ 2.00e+00     0         0         0         0    ]</span>
<span class="go">  [-1.00e+00 -2.00e+00     0      4.00e+00     0    ]</span>
<span class="go">  [    0         0      1.00e+00     0         0    ]</span>
</pre></div>
</div>
</li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">x</span></code> is a dense matrix, a sparse matrix is created with
all the entries of <code class="docutils literal notranslate"><span class="pre">x</span></code> copied, in column-major order, to the
entries indexed by <code class="docutils literal notranslate"><span class="pre">I</span></code> and <code class="docutils literal notranslate"><span class="pre">J</span></code>.
The matrix <code class="docutils literal notranslate"><span class="pre">x</span></code> must have the same length as <code class="docutils literal notranslate"><span class="pre">I</span></code> and <code class="docutils literal notranslate"><span class="pre">J</span></code>.
The default value of <code class="docutils literal notranslate"><span class="pre">tc</span></code> is <code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> if <code class="docutils literal notranslate"><span class="pre">x</span></code> is an
<code class="xref py py-const docutils literal notranslate"><span class="pre">'i'</span></code> or <code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> matrix, and <code class="xref py py-const docutils literal notranslate"><span class="pre">'z'</span></code> otherwise.
If <code class="docutils literal notranslate"><span class="pre">I</span></code> and <code class="docutils literal notranslate"><span class="pre">J</span></code> contain repeated entries, the corresponding
values of the coefficients are added.</p></li>
</ul>
</dd></dl>

<p>The function <code class="xref py py-func docutils literal notranslate"><span class="pre">sparse</span></code> constructs a sparse matrix
from a block-matrix description.</p>
<dl class="py function">
<dt class="sig sig-object py" id="cvxopt.sparse">
<span class="sig-prename descclassname"><span class="pre">cvxopt.</span></span><span class="sig-name descname"><span class="pre">sparse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">tc</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.sparse" title="Permalink to this definition"></a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">tc</span></code> is the typecode, <code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> or <code class="xref py py-const docutils literal notranslate"><span class="pre">'z'</span></code>, for double and
complex matrices, respectively.</p>
<p><code class="docutils literal notranslate"><span class="pre">x</span></code> can be a <a class="reference internal" href="#cvxopt.matrix" title="cvxopt.matrix"><code class="xref py py-class docutils literal notranslate"><span class="pre">matrix</span></code></a>, <a class="reference internal" href="#cvxopt.spmatrix" title="cvxopt.spmatrix"><code class="xref py py-class docutils literal notranslate"><span class="pre">spmatrix</span></code></a>, or a list of lists
of matrices (<a class="reference internal" href="#cvxopt.matrix" title="cvxopt.matrix"><code class="xref py py-class docutils literal notranslate"><span class="pre">matrix</span></code></a> or <a class="reference internal" href="#cvxopt.spmatrix" title="cvxopt.spmatrix"><code class="xref py py-class docutils literal notranslate"><span class="pre">spmatrix</span></code></a> objects) and
numbers (Python integer, float, or complex).</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">x</span></code> is a <a class="reference internal" href="#cvxopt.matrix" title="cvxopt.matrix"><code class="xref py py-class docutils literal notranslate"><span class="pre">matrix</span></code></a> or <a class="reference internal" href="#cvxopt.spmatrix" title="cvxopt.spmatrix"><code class="xref py py-class docutils literal notranslate"><span class="pre">spmatrix</span></code></a> object, then a
sparse matrix of the same size and the same numerical value is
created.  Numerical zeros in <code class="docutils literal notranslate"><span class="pre">x</span></code> are treated as structural zeros
and removed from the triplet description of the new sparse matrix.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">x</span></code> is a list of lists of matrices (<a class="reference internal" href="#cvxopt.matrix" title="cvxopt.matrix"><code class="xref py py-class docutils literal notranslate"><span class="pre">matrix</span></code></a> or
<a class="reference internal" href="#cvxopt.spmatrix" title="cvxopt.spmatrix"><code class="xref py py-class docutils literal notranslate"><span class="pre">spmatrix</span></code></a> objects) and numbers (Python integer, float, or
complex) then each element of <code class="docutils literal notranslate"><span class="pre">x</span></code> is interpreted as a
(block-)column matrix stored in colum-major order, and a
block-matrix is constructed by juxtaposing the <code class="docutils literal notranslate"><span class="pre">len(x)</span></code>
block-columns (as in <a class="reference internal" href="#cvxopt.matrix" title="cvxopt.matrix"><code class="xref py py-func docutils literal notranslate"><span class="pre">matrix</span></code></a>).
Numerical zeros are removed from the triplet description of the new
matrix.</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">spmatrix</span><span class="p">,</span> <span class="n">sparse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ 1.00e+00  2.00e+00  0.00e+00]</span>
<span class="go">[ 2.00e+00  1.00e+00  2.00e+00]</span>
<span class="go">[ 0.00e+00  2.00e+00  1.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">([],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">[0 0 0]</span>
<span class="go">[0 0 0]</span>
<span class="go">[0 0 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go">[ 3.00e+00     0         0    ]</span>
<span class="go">[    0      4.00e+00     0    ]</span>
<span class="go">[    0         0      5.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">sparse</span><span class="p">([[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">],</span> <span class="p">[</span><span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="go">[ 1.00e+00  2.00e+00     0         0         0         0    ]</span>
<span class="go">[ 2.00e+00  1.00e+00  2.00e+00     0         0         0    ]</span>
<span class="go">[    0      2.00e+00  1.00e+00     0         0         0    ]</span>
<span class="go">[    0         0         0      3.00e+00     0         0    ]</span>
<span class="go">[    0         0         0         0      4.00e+00     0    ]</span>
<span class="go">[    0         0         0         0         0      5.00e+00]</span>
</pre></div>
</div>
<p>A matrix with a single block-column can be represented by a single
list.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">sparse</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">C</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="go">[ 1.00e+00  2.00e+00     0    ]</span>
<span class="go">[ 2.00e+00  1.00e+00  2.00e+00]</span>
<span class="go">[    0      2.00e+00  1.00e+00]</span>
<span class="go">[ 3.00e+00     0         0    ]</span>
<span class="go">[    0      4.00e+00     0    ]</span>
<span class="go">[    0         0      5.00e+00]</span>
</pre></div>
</div>
</dd></dl>

<p>The function <code class="xref py py-func docutils literal notranslate"><span class="pre">spdiag</span></code> constructs a block-diagonal
sparse matrix from a list of matrices.</p>
<dl class="py function">
<dt class="sig sig-object py" id="cvxopt.spdiag">
<span class="sig-prename descclassname"><span class="pre">cvxopt.</span></span><span class="sig-name descname"><span class="pre">spdiag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.spdiag" title="Permalink to this definition"></a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">x</span></code> is a dense or sparse matrix with a single row or column, or a
list of square dense or sparse matrices or scalars.
If <code class="docutils literal notranslate"><span class="pre">x</span></code> is a matrix, a sparse diagonal matrix is returned with
the entries of <code class="docutils literal notranslate"><span class="pre">x</span></code> on its diagonal.
If <code class="docutils literal notranslate"><span class="pre">x</span></code> is list, a sparse block-diagonal matrix is returned with
the elements in the list as its diagonal blocks.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">spmatrix</span><span class="p">,</span> <span class="n">spdiag</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="mf">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">],[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">spdiag</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="go">[ 3.00e+00     0         0         0         0         0    ]</span>
<span class="go">[    0      1.00e+00 -2.00e+00     0         0         0    ]</span>
<span class="go">[    0     -2.00e+00  1.00e+00     0         0         0    ]</span>
<span class="go">[    0         0         0      1.00e+00  1.00e+00  1.00e+00]</span>
<span class="go">[    0         0         0      1.00e+00     0         0    ]</span>
<span class="go">[    0         0         0      1.00e+00     0         0    ]</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="arithmetic-operations">
<span id="s-arithmetic"></span><h2>Arithmetic Operations<a class="headerlink" href="#arithmetic-operations" title="Permalink to this heading"></a></h2>
<p>The following table lists the arithmetic operations defined for dense and
sparse matrices.  In the table <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> are dense or sparse
matrices of compatible dimensions, <code class="docutils literal notranslate"><span class="pre">c</span></code>  is a scalar (a Python number or
a dense 1 by 1 matrix), <code class="docutils literal notranslate"><span class="pre">D</span></code> is a dense matrix, and <code class="docutils literal notranslate"><span class="pre">e</span></code> is a Python
number.</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Unary plus/minus</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">+A,</span> <span class="pre">-A</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Addition</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">+</span> <span class="pre">B,</span> <span class="pre">A</span> <span class="pre">+</span> <span class="pre">c,</span> <span class="pre">c</span> <span class="pre">+</span> <span class="pre">A</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Subtraction</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">-</span> <span class="pre">B,</span> <span class="pre">A</span> <span class="pre">-</span> <span class="pre">c,</span> <span class="pre">c</span> <span class="pre">-</span> <span class="pre">A</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Matrix multiplication</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">B</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Scalar multiplication and division</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">*</span> <span class="pre">A,</span> <span class="pre">A</span> <span class="pre">*</span> <span class="pre">c,</span> <span class="pre">A</span> <span class="pre">/</span> <span class="pre">c</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Remainder after division</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">D</span> <span class="pre">%</span> <span class="pre">c</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Elementwise exponentiation</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">D**e</span></code></p></td>
</tr>
</tbody>
</table>
<p>The type of the result of these operations generally follows the Python
conventions.
For example, if <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">c</span></code> are integer, then in Python 2 the division
<code class="docutils literal notranslate"><span class="pre">A/c</span></code> is interpreted as integer division and results in a
type <code class="xref py py-const docutils literal notranslate"><span class="pre">'i'</span></code> matrix, while in Python 3 it is interpreted as standard
divison and results in a type <code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> matrix.
An exception to the Python conventions is elementwise exponentiation:
if <code class="docutils literal notranslate"><span class="pre">D</span></code> is an integer matrix and <code class="docutils literal notranslate"><span class="pre">e</span></code> is an integer number
than <code class="docutils literal notranslate"><span class="pre">D**e</span></code> is a matrix of type <code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code>.</p>
<p>Addition, subtraction, and matrix multiplication with two matrix operands
result in a sparse matrix if both matrices are sparse, and in a dense
matrix otherwise.  The result of a scalar multiplication or division is
dense if <code class="docutils literal notranslate"><span class="pre">A</span></code> is dense, and sparse if <code class="docutils literal notranslate"><span class="pre">A</span></code> is sparse.  Postmultiplying
a matrix with a number <code class="docutils literal notranslate"><span class="pre">c</span></code> means the same as premultiplying, i.e.,
scalar multiplication.  Dividing a matrix by <code class="docutils literal notranslate"><span class="pre">c</span></code> means dividing all its
entries by <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">c</span></code> in the expressions <code class="docutils literal notranslate"><span class="pre">A+c</span></code>, <code class="docutils literal notranslate"><span class="pre">c+A</span></code>, <code class="docutils literal notranslate"><span class="pre">A-c</span></code>, <code class="docutils literal notranslate"><span class="pre">c-A</span></code> is a number,
then it is interpreted as a dense matrix with
the same dimensions as <code class="docutils literal notranslate"><span class="pre">A</span></code>, type given by the type of <code class="docutils literal notranslate"><span class="pre">c</span></code>, and all
its entries equal to <code class="docutils literal notranslate"><span class="pre">c</span></code>.  If <code class="docutils literal notranslate"><span class="pre">c</span></code>  is a 1 by 1 dense matrix and <code class="docutils literal notranslate"><span class="pre">A</span></code>
is not 1 by 1, then <code class="docutils literal notranslate"><span class="pre">c</span></code> is interpreted as a dense matrix with the same
size of <code class="docutils literal notranslate"><span class="pre">A</span></code> and all entries equal to <code class="docutils literal notranslate"><span class="pre">c[0]</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">c</span></code> is a 1 by 1 dense matrix, then, if possible, the products
<code class="docutils literal notranslate"><span class="pre">c*A</span></code> and <code class="docutils literal notranslate"><span class="pre">A*c</span></code> are interpreted as matrix-matrix products.
If the product cannot be interpreted as a matrix-matrix product
because the dimensions of <code class="docutils literal notranslate"><span class="pre">A</span></code> are incompatible, then the product is
interpreted as the scalar multiplication with <code class="docutils literal notranslate"><span class="pre">c[0]</span></code>.
The division <code class="docutils literal notranslate"><span class="pre">A/c</span></code> and remainder <code class="docutils literal notranslate"><span class="pre">A%c</span></code> with <code class="docutils literal notranslate"><span class="pre">c</span></code> a
1 by 1 matrix are always interpreted as <code class="docutils literal notranslate"><span class="pre">A/c[0]</span></code>, resp., <code class="docutils literal notranslate"><span class="pre">A%c[0]</span></code>.</p>
<p>The following in-place operations are also defined, but only if they do
not change the type (sparse or dense, integer, real, or complex) of the
matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>.  These in-place operations do not return a new matrix but
modify the existing object <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>In-place addition</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">+=</span> <span class="pre">B,</span> <span class="pre">A</span> <span class="pre">+=</span> <span class="pre">c</span></code></p></td>
</tr>
<tr class="row-even"><td><p>In-place subtraction</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">-=</span> <span class="pre">B,</span> <span class="pre">A</span> <span class="pre">-=</span> <span class="pre">c</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>In-place scalar multiplication and division</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">*=</span> <span class="pre">c,</span> <span class="pre">A</span> <span class="pre">/=</span> <span class="pre">c</span></code></p></td>
</tr>
<tr class="row-even"><td><p>In-place remainder</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">%=</span> <span class="pre">c</span></code></p></td>
</tr>
</tbody>
</table>
<p>For example, if <code class="docutils literal notranslate"><span class="pre">A</span></code> has typecode <code class="xref py py-const docutils literal notranslate"><span class="pre">'i'</span></code>, then <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">+=</span> <span class="pre">B</span></code> is
allowed if <code class="docutils literal notranslate"><span class="pre">B</span></code> has typecode <code class="xref py py-const docutils literal notranslate"><span class="pre">'i'</span></code>.  It is not allowed if <code class="docutils literal notranslate"><span class="pre">B</span></code>
has typecode <code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> or <code class="xref py py-const docutils literal notranslate"><span class="pre">'z'</span></code> because the addition
<code class="docutils literal notranslate"><span class="pre">A+B</span></code> results in a <code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> or <code class="xref py py-const docutils literal notranslate"><span class="pre">'z'</span></code> matrix and
therefore cannot be assigned to <code class="docutils literal notranslate"><span class="pre">A</span></code> without changing its type.
As another example, if <code class="docutils literal notranslate"><span class="pre">A</span></code> is a sparse matrix, then <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">+=</span> <span class="pre">1.0</span></code> is
not allowed because the operation <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">A</span> <span class="pre">+</span> <span class="pre">1.0</span></code> results in a dense
matrix, so it cannot be assigned to <code class="docutils literal notranslate"><span class="pre">A</span></code> without changing its type.</p>
<p>In-place matrix-matrix products are not allowed.  (Except when <code class="docutils literal notranslate"><span class="pre">c</span></code> is
a 1 by 1 dense matrix, in which case <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">*=</span> <span class="pre">c</span></code> is interpreted as the
scalar product <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">*=</span> <span class="pre">c[0]</span></code>.)</p>
<p>In-place remainder is only defined for dense <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
<p>It is important to know when a matrix operation creates a new object.
The following rules apply.</p>
<ul>
<li><p>A simple assignment (<code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">B</span></code>) is given the standard Python
interpretation, i.e., it assigns to the variable <code class="docutils literal notranslate"><span class="pre">A</span></code> a reference (or
pointer) to the object referenced by <code class="docutils literal notranslate"><span class="pre">B</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">],</span> <span class="p">[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">4.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">[ 1.00e+00  3.00e+00]</span>
<span class="go">[ 2.00e+00  4.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">B</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>   <span class="c1"># modifying A[0,0] also modified B[0,0]</span>
<span class="go">[-1.00e+00  3.00e+00]</span>
<span class="go">[ 2.00e+00  4.00e+00]</span>
</pre></div>
</div>
</li>
<li><p>The regular (i.e., not in-place) arithmetic operations always return
new objects.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">],</span> <span class="p">[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">4.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="o">+</span><span class="n">B</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>   <span class="c1"># modifying A[0,0] does not modify B[0,0]</span>
<span class="go">[ 1.00e+00  3.00e+00]</span>
<span class="go">[ 2.00e+00  4.00e+00]</span>
</pre></div>
</div>
</li>
<li><p>The in-place operations directly modify the coefficients of the
existing matrix object and do not create a new object.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">],</span> <span class="p">[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">4.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">B</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">*=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>   <span class="c1"># in-place operation also changed B</span>
<span class="go">[ 2.00e+00  6.00e+00]</span>
<span class="go">[ 4.00e+00  8.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>   <span class="c1"># regular operation creates a new A, so does not change B</span>
<span class="go">[ 2.00e+00  6.00e+00]</span>
<span class="go">[ 4.00e+00  8.00e+00]</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="indexing-and-slicing">
<span id="s-indexing"></span><h2>Indexing and Slicing<a class="headerlink" href="#indexing-and-slicing" title="Permalink to this heading"></a></h2>
<p>Matrices can be indexed using one or two arguments.  In single-argument
indexing of a matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>, the index runs from <code class="docutils literal notranslate"><span class="pre">-len(A)</span></code> to
<code class="docutils literal notranslate"><span class="pre">len(A)-1</span></code>, and is interpreted as an index in the one-dimensional
array of coefficients of <code class="docutils literal notranslate"><span class="pre">A</span></code> in column-major order.   Negative indices
have the standard Python interpretation: for negative <code class="docutils literal notranslate"><span class="pre">k</span></code>,
<code class="docutils literal notranslate"><span class="pre">A[k]</span></code> is the same element as <code class="docutils literal notranslate"><span class="pre">A[len(A)</span> <span class="pre">+</span> <span class="pre">k]</span></code>.</p>
<p>Four different types of one-argument indexing are implemented.</p>
<ol class="arabic simple">
<li><p>The index can be a single integer.
This returns a number, e.g., <code class="docutils literal notranslate"><span class="pre">A[0]</span></code> is the first element of <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p></li>
<li><p>The index can be an integer matrix.  This returns a column matrix: the
command <code class="docutils literal notranslate"><span class="pre">A[matrix([0,1,2,3])]</span></code> returns the 4 by 1 matrix
consisting of the first four elements of <code class="docutils literal notranslate"><span class="pre">A</span></code>.  The size of the index
matrix is ignored: <code class="docutils literal notranslate"><span class="pre">A[matrix([0,1,2,3],</span> <span class="pre">(2,2))]</span></code> returns the same
4 by 1 matrix.</p></li>
<li><p>The index can be a list of integers.  This returns a column matrix,
e.g., <code class="docutils literal notranslate"><span class="pre">A[[0,1,2,3]]</span></code> is the 4 by 1 matrix consisting of elements
0, 1, 2, 3 of <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p></li>
<li><p>The index can be a Python slice.  This returns a matrix with one column
(possibly 0 by 1, or 1 by 1).  For example, <code class="docutils literal notranslate"><span class="pre">A[::2]</span></code> is the column
matrix defined by taking every other element of <code class="docutils literal notranslate"><span class="pre">A</span></code>, stored in
column-major order.  <code class="docutils literal notranslate"><span class="pre">A[0:0]</span></code> is a matrix with size (0,1).</p></li>
</ol>
<p>Thus, single-argument indexing returns a scalar (if the index is an
integer), or a matrix with one column.  This is consistent with the
interpretation that single-argument indexing accesses the matrix in
column-major order.</p>
<p>Note that an index list or an index matrix are equivalent, but they are
both useful, especially when we perform operations on index sets.  For
example, if <code class="docutils literal notranslate"><span class="pre">I</span></code> and <code class="docutils literal notranslate"><span class="pre">J</span></code> are lists then <code class="docutils literal notranslate"><span class="pre">I+J</span></code> is the
concatenated list, and <code class="docutils literal notranslate"><span class="pre">2*I</span></code> is <code class="docutils literal notranslate"><span class="pre">I</span></code> repeated twice.  If they
are matrices, these operations are interpreted as arithmetic operations.
For large index sets, indexing with integer matrices is also faster
than indexing with lists.</p>
<p>The following example illustrates one-argument indexing.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">spmatrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ 0.00e+00  4.00e+00  8.00e+00  1.20e+01]</span>
<span class="go">[ 1.00e+00  5.00e+00  9.00e+00  1.30e+01]</span>
<span class="go">[ 2.00e+00  6.00e+00  1.00e+01  1.40e+01]</span>
<span class="go">[ 3.00e+00  7.00e+00  1.10e+01  1.50e+01]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
<span class="go">4.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">I</span><span class="p">])</span>      <span class="c1"># the diagonal</span>
<span class="go">[ 0.00e+00]</span>
<span class="go">[ 5.00e+00]</span>
<span class="go">[ 1.00e+01]</span>
<span class="go">[ 1.50e+01]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">];</span>  <span class="n">J</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="o">+</span><span class="n">J</span><span class="p">])</span>  <span class="c1"># duplicate I and append J</span>
<span class="go">[ 0.00e+00]</span>
<span class="go">[ 2.00e+00]</span>
<span class="go">[ 0.00e+00]</span>
<span class="go">[ 2.00e+00]</span>
<span class="go">[ 1.00e+00]</span>
<span class="go">[ 3.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]);</span>  <span class="n">J</span> <span class="o">=</span>  <span class="n">matrix</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="o">+</span><span class="n">J</span><span class="p">])</span>  <span class="c1"># multiply I by 2 and add J</span>
<span class="go">[ 1.00e+00]</span>
<span class="go">[ 7.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">4</span><span class="p">::</span><span class="mi">4</span><span class="p">])</span>   <span class="c1"># get every fourth element skipping the first four</span>
<span class="go">[ 4.00e+00]</span>
<span class="go">[ 8.00e+00]</span>
<span class="go">[ 1.20e+01]</span>
</pre></div>
</div>
<p>In two-argument indexing the arguments can be any combinations of the
four types listed above.  The first argument indexes the rows of
the matrix and the second argument indexes the columns.  If both
indices are scalars, then a scalar is returned.  In all other cases,
a matrix is returned.  We continue the example.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">[ 4.00e+00]</span>
<span class="go">[ 5.00e+00]</span>
<span class="go">[ 6.00e+00]</span>
<span class="go">[ 7.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">J</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">J</span><span class="p">,</span><span class="n">J</span><span class="p">])</span>
<span class="go">[ 0.00e+00  8.00e+00]</span>
<span class="go">[ 2.00e+00  1.00e+01]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">:])</span>
<span class="go">[ 8.00e+00  1.20e+01]</span>
<span class="go">[ 9.00e+00  1.30e+01]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="go">[ 0.00e+00  2.00e+00]</span>
<span class="go">[ 2.00e+00     0    ]</span>
<span class="go">[-1.00e+00 -2.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:,</span><span class="o">-</span><span class="mi">2</span><span class="p">:])</span>
<span class="go">[ 0.00e+00-j0.00e+00  0.00e+00-j0.00e+00]</span>
<span class="go">[ 0.00e+00+j2.00e+00 -2.00e+00-j0.00e+00]</span>
</pre></div>
</div>
<p>Expressions of the form <code class="docutils literal notranslate"><span class="pre">A[I]</span></code> or <code class="docutils literal notranslate"><span class="pre">A[I,J]</span></code> can also appear on
the left-hand side of an assignment.   The right-hand side must be a
scalar
(i.e., a number or a 1 by 1 dense matrix), a sequence of numbers, or a
dense or sparse matrix.  If the right-hand side is a scalar, it is
interpreted as a dense matrix with identical entries and the dimensions of
the left-hand side.  If the right-hand side is a sequence of numbers
(list, tuple, <code class="xref py py-mod docutils literal notranslate"><span class="pre">array</span></code> array, range object, …) its values are
interpreted
as the coefficients of a dense matrix in column-major order.  If the
right-hand side is a matrix (<code class="xref py py-class docutils literal notranslate"><span class="pre">matrix</span></code> or
<code class="xref py py-class docutils literal notranslate"><span class="pre">spmatrix</span></code>), it must
have the same size as the left-hand side.  Sparse matrices are
converted to dense in the assignment to a dense matrix.</p>
<p>Indexed assignments are only allowed if they do not change the type of
the matrix.  For example, if <code class="docutils literal notranslate"><span class="pre">A</span></code> is a matrix with type <code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code>,
then <code class="docutils literal notranslate"><span class="pre">A[I]</span> <span class="pre">=</span> <span class="pre">B</span></code> is only permitted if <code class="docutils literal notranslate"><span class="pre">B</span></code> is an integer, a float,
or a matrix of type <code class="xref py py-const docutils literal notranslate"><span class="pre">'i'</span></code> or <code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code>.  If <code class="docutils literal notranslate"><span class="pre">A</span></code> is an integer
matrix, then <code class="docutils literal notranslate"><span class="pre">A[I]</span> <span class="pre">=</span> <span class="pre">B</span></code> is only permitted if <code class="docutils literal notranslate"><span class="pre">B</span></code> is an integer or
an integer matrix.</p>
<p>The following examples illustrate indexed assignment.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">[::</span><span class="mi">2</span><span class="p">,::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ -1   4  -3  12]</span>
<span class="go">[  1   5   9  13]</span>
<span class="go">[ -2   6  -4  14]</span>
<span class="go">[  3   7  11  15]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">[::</span><span class="mi">5</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[  0   4  -3  12]</span>
<span class="go">[  1   6   9  13]</span>
<span class="go">[ -2   6  -3  14]</span>
<span class="go">[  3   7  11  16]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ -1   1  -1   1]</span>
<span class="go">[  1   6   9  13]</span>
<span class="go">[ -2   6  -3  14]</span>
<span class="go">[  3   7  11  16]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">:,</span><span class="mi">2</span><span class="p">:]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ -1   1  -1   1]</span>
<span class="go">[  1   6   9  13]</span>
<span class="go">[ -2   6   0   2]</span>
<span class="go">[  3   7   1   3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ 0.00e+00  2.00e+00     0    ]</span>
<span class="go">[ 2.00e+00     0      1.00e+00]</span>
<span class="go">[-1.00e+00 -2.00e+00     0    ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go">[ 1.00e+01     0    ]</span>
<span class="go">[    0      3.00e+01]</span>
<span class="go">[-2.00e+01     0    ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">C</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ 1.00e+01  2.00e+00     0    ]</span>
<span class="go">[    0         0      1.00e+00]</span>
<span class="go">[-2.00e+01 -2.00e+00     0    ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ 0.00e+00  2.00e+00     0    ]</span>
<span class="go">[ 1.00e+00     0      1.00e+00]</span>
<span class="go">[ 2.00e+00 -2.00e+00     0    ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ 1.00e+00  2.00e+00     0    ]</span>
<span class="go">[ 1.00e+00     0      1.00e+00]</span>
<span class="go">[ 1.00e+00 -2.00e+00     0    ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ 0.00e+00  2.00e+00     0    ]</span>
<span class="go">[ 0.00e+00     0      1.00e+00]</span>
<span class="go">[ 0.00e+00 -2.00e+00     0    ]</span>
</pre></div>
</div>
</section>
<section id="attributes-and-methods">
<h2>Attributes and Methods<a class="headerlink" href="#attributes-and-methods" title="Permalink to this heading"></a></h2>
<p>Dense and sparse matrices have the following attributes.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="size">
<span class="sig-name descname"><span class="pre">size</span></span><a class="headerlink" href="#size" title="Permalink to this definition"></a></dt>
<dd><p>A tuple with the dimensions of the matrix. The size of the matrix can
be changed by altering this attribute, as long as the number of
elements in the matrix remains unchanged.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typecode">
<span class="sig-name descname"><span class="pre">typecode</span></span><a class="headerlink" href="#typecode" title="Permalink to this definition"></a></dt>
<dd><p>A character, either <code class="xref py py-const docutils literal notranslate"><span class="pre">'i'</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code>, or <code class="xref py py-const docutils literal notranslate"><span class="pre">'z'</span></code>, for
integer, real, and complex matrices, respectively.  A read-only
attribute.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="trans">
<span class="sig-name descname"><span class="pre">trans</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trans" title="Permalink to this definition"></a></dt>
<dd><p>Returns the transpose of the matrix as a new matrix.  One can also use
<code class="docutils literal notranslate"><span class="pre">A.T</span></code> instead of <code class="docutils literal notranslate"><span class="pre">A.trans()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ctrans">
<span class="sig-name descname"><span class="pre">ctrans</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctrans" title="Permalink to this definition"></a></dt>
<dd><p>Returns the conjugate transpose of the matrix as a new matrix.  One
can also use <code class="docutils literal notranslate"><span class="pre">A.H</span></code> instead of <code class="docutils literal notranslate"><span class="pre">A.ctrans()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="real">
<span class="sig-name descname"><span class="pre">real</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#real" title="Permalink to this definition"></a></dt>
<dd><p>For complex matrices, returns the real part as a real matrix.  For
integer and real matrices, returns a copy of the matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="imag">
<span class="sig-name descname"><span class="pre">imag</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#imag" title="Permalink to this definition"></a></dt>
<dd><p>For complex matrices, returns the imaginary part as a real matrix.
For integer and real matrices, returns an integer or real zero matrix.</p>
</dd></dl>

<p>In addition, sparse matrices have the following attributes.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="V">
<span class="sig-name descname"><span class="pre">V</span></span><a class="headerlink" href="#V" title="Permalink to this definition"></a></dt>
<dd><p>A single-column dense matrix containing the numerical values of the
nonzero entries in column-major order.  Making an assignment to the
attribute is an efficient way of changing the values of the sparse
matrix, without changing the sparsity pattern.</p>
<p>When the attribute <a class="reference internal" href="#V" title="V"><code class="xref py py-attr docutils literal notranslate"><span class="pre">V</span></code></a> is read, a <em>copy</em> of <a class="reference internal" href="#V" title="V"><code class="xref py py-attr docutils literal notranslate"><span class="pre">V</span></code></a> is
returned, as a new dense matrix.  This implies, for example, that an
indexed assignment <code class="docutils literal notranslate"><span class="pre">A.V[I]</span> <span class="pre">=</span> <span class="pre">B</span></code> does not work, or at least
cannot be used to modify <code class="docutils literal notranslate"><span class="pre">A</span></code>.  Instead the attribute <a class="reference internal" href="#V" title="V"><code class="xref py py-attr docutils literal notranslate"><span class="pre">V</span></code></a>
will be read and returned as a new matrix; then the elements of this
new matrix are modified.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="I">
<span class="sig-name descname"><span class="pre">I</span></span><a class="headerlink" href="#I" title="Permalink to this definition"></a></dt>
<dd><p>A single-column integer dense matrix with the row indices of the
entries in <a class="reference internal" href="#V" title="V"><code class="xref py py-attr docutils literal notranslate"><span class="pre">V</span></code></a>.  A read-only attribute.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="J">
<span class="sig-name descname"><span class="pre">J</span></span><a class="headerlink" href="#J" title="Permalink to this definition"></a></dt>
<dd><p>A single-column integer dense matrix with the column indices of the
entries in <a class="reference internal" href="#V" title="V"><code class="xref py py-attr docutils literal notranslate"><span class="pre">V</span></code></a>.  A read-only attribute.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="CCS">
<span class="sig-name descname"><span class="pre">CCS</span></span><a class="headerlink" href="#CCS" title="Permalink to this definition"></a></dt>
<dd><p>A triplet (column pointers, row indices, values) with the
compressed-column-storage representation of the matrix.  A read-only
attribute.  This attribute can be used to export sparse matrices to
other packages such as MOSEK.</p>
</dd></dl>

<p>The next example below illustrates assignments to <a class="reference internal" href="#V" title="V"><code class="xref py py-attr docutils literal notranslate"><span class="pre">V</span></code></a>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">spmatrix</span><span class="p">,</span> <span class="n">matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ 0.00e+00     0         0    ]</span>
<span class="go">[ 1.00e+00  2.00e+00     0    ]</span>
<span class="go">[    0      3.00e+00  4.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">J</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>  <span class="c1"># transpose and add a zero row and column</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">[ 0.00e+00  1.00e+00     0         0    ]</span>
<span class="go">[    0      2.00e+00  3.00e+00     0    ]</span>
<span class="go">[    0         0      4.00e+00     0    ]</span>
<span class="go">[    0         0         0         0    ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">7.</span><span class="p">,</span> <span class="mf">8.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">])</span>   <span class="c1"># assign new values to nonzero entries</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">[ 1.00e+00  7.00e+00     0         0    ]</span>
<span class="go">[    0      8.00e+00  6.00e+00     0    ]</span>
<span class="go">[    0         0      4.00e+00     0    ]</span>
<span class="go">[    0         0         0         0    ]</span>
</pre></div>
</div>
<p>The following attributes and methods are defined for dense matrices.</p>
<dl class="py method">
<dt class="sig sig-object py" id="tofile">
<span class="sig-name descname"><span class="pre">tofile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tofile" title="Permalink to this definition"></a></dt>
<dd><p>Writes the elements of the matrix in column-major order to a binary
file <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fromfile">
<span class="sig-name descname"><span class="pre">fromfile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fromfile" title="Permalink to this definition"></a></dt>
<dd><p>Reads the contents of a binary file <code class="docutils literal notranslate"><span class="pre">f</span></code> into the matrix object.</p>
</dd></dl>

<p>The last two methods are illustrated in the following examples.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">spmatrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">,</span><span class="mf">3.</span><span class="p">],</span> <span class="p">[</span><span class="mf">4.</span><span class="p">,</span><span class="mf">5.</span><span class="p">,</span><span class="mf">6.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ 1.00e+00  4.00e+00]</span>
<span class="go">[ 2.00e+00  5.00e+00]</span>
<span class="go">[ 3.00e+00  6.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;mat.bin&#39;</span><span class="p">,</span><span class="s1">&#39;wb&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;mat.bin&#39;</span><span class="p">,</span><span class="s1">&#39;rb&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">[ 1.00e+00  3.00e+00  5.00e+00]</span>
<span class="go">[ 2.00e+00  4.00e+00  6.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;test.bin&#39;</span><span class="p">,</span><span class="s1">&#39;wb&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">V</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">I</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">J</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;test.bin&#39;</span><span class="p">,</span><span class="s1">&#39;rb&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">V</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>  <span class="n">V</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>  <span class="n">I</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">J</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>  <span class="n">J</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">[ 0.00e+00     0         0    ]</span>
<span class="go">[ 1.00e+00  2.00e+00     0    ]</span>
<span class="go">[    0      3.00e+00  4.00e+00]</span>
</pre></div>
</div>
<p>Note that the <code class="xref py py-func docutils literal notranslate"><span class="pre">dump</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">load</span></code> functions in the <code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code>
module offer a convenient alternative for writing matrices to files and
reading matrices from files.</p>
</section>
<section id="built-in-functions">
<h2>Built-In Functions<a class="headerlink" href="#built-in-functions" title="Permalink to this heading"></a></h2>
<p>Many Python built-in functions and operations can be used with matrix
arguments.  We list some useful examples.</p>
<dl class="py function">
<dt class="sig sig-object py" id="len">
<span class="sig-name descname"><span class="pre">len</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#len" title="Permalink to this definition"></a></dt>
<dd><p>If <code class="docutils literal notranslate"><span class="pre">x</span></code> is a dense matrix, returns the product of the number of rows
and the number of columns.  If <code class="docutils literal notranslate"><span class="pre">x</span></code> is a sparse matrix, returns the
number of nonzero entries.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="bool">
<span class="sig-name descname"><span class="pre">bool</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#bool" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code> if <code class="docutils literal notranslate"><span class="pre">x</span></code> is a zero matrix and <code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code>
otherwise.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="max">
<span class="sig-name descname"><span class="pre">max</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#max" title="Permalink to this definition"></a></dt>
<dd><p>If <code class="docutils literal notranslate"><span class="pre">x</span></code> is a dense matrix, returns the maximum element of <code class="docutils literal notranslate"><span class="pre">x</span></code>.
If <code class="docutils literal notranslate"><span class="pre">x</span></code> is a sparse, returns the maximum nonzero element of <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="min">
<span class="sig-name descname"><span class="pre">min</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#min" title="Permalink to this definition"></a></dt>
<dd><p>If <code class="docutils literal notranslate"><span class="pre">x</span></code> is a dense matrix, returns the minimum element of <code class="docutils literal notranslate"><span class="pre">x</span></code>.
If <code class="docutils literal notranslate"><span class="pre">x</span></code> is a sparse matrix, returns the minimum nonzero element of
<code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="abs">
<span class="sig-name descname"><span class="pre">abs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#abs" title="Permalink to this definition"></a></dt>
<dd><p>Returns a matrix with the absolute values of the elements of <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sum">
<span class="sig-name descname"><span class="pre">sum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">start</span> <span class="pre">=</span> <span class="pre">0.0</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#sum" title="Permalink to this definition"></a></dt>
<dd><p>Returns the sum of <code class="docutils literal notranslate"><span class="pre">start</span></code> and the elements of <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</dd></dl>

<p>Dense and sparse matrices can be used as  arguments to the <code class="xref py py-func docutils literal notranslate"><span class="pre">list</span></code>,
<code class="xref py py-func docutils literal notranslate"><span class="pre">tuple</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">zip</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">map</span></code>, and <code class="xref py py-func docutils literal notranslate"><span class="pre">filter</span></code> functions
described in the Python Library Reference.
However, one should note that when used with sparse matrix arguments,
these functions only consider the nonzero entries.
For example, <code class="docutils literal notranslate"><span class="pre">list(A)</span></code> and <code class="docutils literal notranslate"><span class="pre">tuple(A)</span></code> construct a list,
respectively a tuple, from the elements of <code class="docutils literal notranslate"><span class="pre">A</span></code> if <code class="docutils literal notranslate"><span class="pre">A</span></code> is dense, and
of the nonzero elements of <code class="docutils literal notranslate"><span class="pre">A</span></code> if <code class="docutils literal notranslate"><span class="pre">A</span></code> is sparse.</p>
<p><code class="docutils literal notranslate"><span class="pre">list(zip(A,</span> <span class="pre">B,</span> <span class="pre">...))</span></code> returns a list of tuples, with the i-th tuple
containing the i-th elements (or nonzero elements) of <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code>, ….</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="o">-</span><span class="mf">11.</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.</span><span class="p">,</span> <span class="o">-</span><span class="mf">20.</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">6.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">7.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[-11.0, -5.0, -20.0, -6.0, 0.0, 7.0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">tuple</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">(0, 1, 2, 3, 4, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">))</span>
<span class="go">[(-11.0, 0), (-5.0, 1), (-20.0, 2), (-6.0, 3), (0.0, 4), (7.0, 5)]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">list(map(f,</span> <span class="pre">A))</span></code>, where <code class="docutils literal notranslate"><span class="pre">f</span></code> is a function and <code class="docutils literal notranslate"><span class="pre">A</span></code> is a
dense matrix, returns a list constructed by applying <code class="docutils literal notranslate"><span class="pre">f</span></code> to each
element of <code class="docutils literal notranslate"><span class="pre">A</span></code>.  If
<code class="docutils literal notranslate"><span class="pre">A</span></code> is sparse, the function <code class="docutils literal notranslate"><span class="pre">f</span></code> is applied to each nonzero element of
<code class="docutils literal notranslate"><span class="pre">A</span></code>.  Multiple arguments can be provided, for example, as in
<code class="docutils literal notranslate"><span class="pre">map(f,</span> <span class="pre">A,</span> <span class="pre">B)</span></code>, if <code class="docutils literal notranslate"><span class="pre">f</span></code> is a function with two arguments.
In the following example, we return an integer 0-1 matrix with the
result of an elementwise comparison.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ 5.00e-01  1.50e+00  3.00e-01]</span>
<span class="go">[-1.00e-01  2.00e-01  1.00e+00]</span>
<span class="go">[ 2.00e+00 -1.00e-01  0.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">matrix</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">A</span><span class="p">)),</span> <span class="n">A</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
<span class="go">[ 1  0  1]</span>
<span class="go">[ 0  1  1]</span>
<span class="go">[ 0  0  1]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">list(filter(f,</span> <span class="pre">A))</span></code>, where <code class="docutils literal notranslate"><span class="pre">f</span></code> is a function and <code class="docutils literal notranslate"><span class="pre">A</span></code> is a matrix,
returns a list containing the elements of <code class="docutils literal notranslate"><span class="pre">A</span></code> (or nonzero elements of
<code class="docutils literal notranslate"><span class="pre">A</span></code> is <code class="docutils literal notranslate"><span class="pre">A</span></code> is sparse) for which <code class="docutils literal notranslate"><span class="pre">f</span></code> is true.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>  <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[  5  -1   6  -1]</span>
<span class="go">[ -4  -5   1   2]</span>
<span class="go">[ 10  -6   5  -3]</span>
<span class="go">[ -7   2   2  -7]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">%</span><span class="mi">2</span><span class="p">,</span> <span class="n">A</span><span class="p">))</span>         <span class="c1"># list of odd elements in A</span>
<span class="go">[5, -7, -1, -5, 1, 5, -1, -3, -7]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">,</span> <span class="n">A</span><span class="p">))</span>  <span class="c1"># list of elements between -2 and 3</span>
<span class="go">[-1, 2, 1, 2, -1, 2]</span>
</pre></div>
</div>
<p>It is also possible to iterate over matrix elements, as illustrated in
the following example.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">5</span>
<span class="go">0</span>
<span class="go">9</span>
<span class="go">11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">A</span><span class="p">]</span>
<span class="go">[5, 0, 9, 11]</span>
</pre></div>
</div>
<p>The expression <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">A</span></code> returns <code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code> if an element
of <code class="docutils literal notranslate"><span class="pre">A</span></code> (or a nonzero element of <code class="docutils literal notranslate"><span class="pre">A</span></code> if <code class="docutils literal notranslate"><span class="pre">A</span></code> is sparse)
is equal to <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</section>
<section id="other-matrix-functions">
<h2>Other Matrix Functions<a class="headerlink" href="#other-matrix-functions" title="Permalink to this heading"></a></h2>
<p>The following functions can be imported from CVXOPT.</p>
<dl class="py function">
<dt class="sig sig-object py" id="cvxopt.sqrt">
<span class="sig-prename descclassname"><span class="pre">cvxopt.</span></span><span class="sig-name descname"><span class="pre">sqrt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.sqrt" title="Permalink to this definition"></a></dt>
<dd><p>The elementwise square root of a dense matrix <code class="docutils literal notranslate"><span class="pre">x</span></code>.  The result is
returned as a real matrix if <code class="docutils literal notranslate"><span class="pre">x</span></code> is an integer or real matrix and
as a complex matrix if <code class="docutils literal notranslate"><span class="pre">x</span></code> is a complex matrix.  Raises an exception
when <code class="docutils literal notranslate"><span class="pre">x</span></code> is an integer or real matrix with negative elements.</p>
<p>As an example we take the elementwise square root of the sparse matrix</p>
<div class="math">
<p><img src="_images/math/37ab88a567d07e7cd18072c1f9878e17b26e1a6a.png" alt="A = \left[ \begin{array}{rrrrr}
    0 &amp; 2 &amp; 0 &amp; 0 &amp; 3 \\
    2 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    1 &amp; 2 &amp; 0 &amp; 4 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \end{array} \right]"/></p>
</div><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">spmatrix</span><span class="p">,</span> <span class="n">sqrt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">V</span><span class="p">),</span> <span class="n">A</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">J</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">[    0      1.41e+00     0      1.73e+00]</span>
<span class="go">[ 1.41e+00     0         0         0    ]</span>
<span class="go">[ 1.00e+00  1.41e+00     0      2.00e+00]</span>
<span class="go">[    0         0      1.00e+00     0    ]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cvxopt.sin">
<span class="sig-prename descclassname"><span class="pre">cvxopt.</span></span><span class="sig-name descname"><span class="pre">sin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.sin" title="Permalink to this definition"></a></dt>
<dd><p>The sine function applied elementwise to a dense matrix <code class="docutils literal notranslate"><span class="pre">x</span></code>.
The result is returned as a real matrix if <code class="docutils literal notranslate"><span class="pre">x</span></code> is an integer
or real matrix and as a complex matrix otherwise.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cvxopt.cos">
<span class="sig-prename descclassname"><span class="pre">cvxopt.</span></span><span class="sig-name descname"><span class="pre">cos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.cos" title="Permalink to this definition"></a></dt>
<dd><p>The cosine function applied elementwise to a dense matrix <code class="docutils literal notranslate"><span class="pre">x</span></code>.
The result is returned as a real matrix if <code class="docutils literal notranslate"><span class="pre">x</span></code> is an integer
or real matrix and as a complex matrix otherwise.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cvxopt.exp">
<span class="sig-prename descclassname"><span class="pre">cvxopt.</span></span><span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.exp" title="Permalink to this definition"></a></dt>
<dd><p>The exponential function applied elementwise to a dense matrix <code class="docutils literal notranslate"><span class="pre">x</span></code>.
The result is returned as a real matrix if <code class="docutils literal notranslate"><span class="pre">x</span></code> is an integer
or real matrix and as a complex matrix otherwise.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cvxopt.log">
<span class="sig-prename descclassname"><span class="pre">cvxopt.</span></span><span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.log" title="Permalink to this definition"></a></dt>
<dd><p>The natural logarithm applied elementwise to a dense matrix <code class="docutils literal notranslate"><span class="pre">x</span></code>.
The result is returned as a real matrix if <code class="docutils literal notranslate"><span class="pre">x</span></code> is an integer
or real matrix and as a complex matrix otherwise.
Raises an exception when <code class="docutils literal notranslate"><span class="pre">x</span></code> is an integer or real matrix with
nonpositive elements, or a complex matrix with zero elements.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cvxopt.mul">
<span class="sig-prename descclassname"><span class="pre">cvxopt.</span></span><span class="sig-name descname"><span class="pre">mul</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">x1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">x2</span> <span class="pre">...</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.mul" title="Permalink to this definition"></a></dt>
<dd><p>If the arguments are dense or sparse matrices of the same size, returns
the elementwise product of its arguments.  The result is a sparse
matrix if one or more of its arguments is sparse, and a dense matrix
otherwise.</p>
<p>If the arguments include scalars, a scalar product with the scalar is
made.  (A 1 by 1 dense matrix is treated as a scalar if the dimensions
of the other arguments are not all 1 by 1.)</p>
<p><a class="reference internal" href="#cvxopt.mul" title="cvxopt.mul"><code class="xref py py-func docutils literal notranslate"><span class="pre">mul</span></code></a> can also be called with an iterable
(list, tuple, range object, or generator) as its single argument,
if the iterable generates a list of dense or sparse matrices or
scalars.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">spmatrix</span><span class="p">,</span> <span class="n">mul</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">([</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mul</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">))</span>
<span class="go">[-2.00e+00     0    ]</span>
<span class="go">[    0     -1.20e+01]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mul</span><span class="p">(</span> <span class="n">matrix</span><span class="p">([</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">))</span>
<span class="go">[  6]</span>
<span class="go">[ 24]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cvxopt.div">
<span class="sig-prename descclassname"><span class="pre">cvxopt.</span></span><span class="sig-name descname"><span class="pre">div</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.div" title="Permalink to this definition"></a></dt>
<dd><p>Returns the elementwise division of <code class="docutils literal notranslate"><span class="pre">x</span></code> by <code class="docutils literal notranslate"><span class="pre">y</span></code>.  <code class="docutils literal notranslate"><span class="pre">x</span></code> is a dense
or sparse matrix, or a scalar (Python number of 1 by 1 dense matrix).
<code class="docutils literal notranslate"><span class="pre">y</span></code> is a dense matrix or a scalar.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cvxopt.max">
<span class="sig-prename descclassname"><span class="pre">cvxopt.</span></span><span class="sig-name descname"><span class="pre">max</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">x1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">x2</span> <span class="pre">...</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.max" title="Permalink to this definition"></a></dt>
<dd><p>When called with a single matrix argument, returns the maximum of the
elements of the matrix (including the zero entries, if the matrix is
sparse).</p>
<p>When called with multiple arguments, the arguments must be matrices of
the same size, or scalars, and the elementwise maximum is returned.
A 1 by 1 dense matrix is treated as a scalar if the other arguments
are not all 1 by 1.  If one of the arguments is scalar, and the other
arguments are not all 1 by 1, then the scalar argument is interpreted
as a dense matrix with all its entries equal to the scalar.</p>
<p>The result is a sparse matrix if all its arguments are sparse matrices.
The result is a number if all its arguments are numbers.  The result
is a dense matrix if at least one of the arguments is a dense matrix.</p>
<p><a class="reference internal" href="#cvxopt.max" title="cvxopt.max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max</span></code></a> can also be called with an iterable
(list, tuple, range object, or generator) as its single argument,
if the iterable generates a list of dense or sparse matrices or
scalars.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">spmatrix</span><span class="p">,</span> <span class="nb">max</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="o">-</span><span class="n">A</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">[ 2.00e+00  1.00e+00]</span>
<span class="go">[ 1.00e+00  3.00e+00]</span>
</pre></div>
</div>
<p>It is important to note the difference between this
<a class="reference internal" href="#cvxopt.max" title="cvxopt.max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max</span></code></a>
and the built-in <a class="reference internal" href="#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max</span></code></a>, explained in the previous section.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">spmatrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">([</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>          <span class="c1"># built-in max of a sparse matrix takes maximum over nonzero elements</span>
<span class="go">-1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.5</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">NotImplementedError</span>: <span class="n">matrix comparison not implemented</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="nb">max</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>          <span class="c1"># cvxopt.max takes maximum over all the  elements</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.5</span><span class="p">))</span>
<span class="go">[-1.00e+00  0.00e+00]</span>
<span class="go">[ 0.00e+00 -1.50e+00]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cvxopt.min">
<span class="sig-prename descclassname"><span class="pre">cvxopt.</span></span><span class="sig-name descname"><span class="pre">min</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">x1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">x2</span> <span class="pre">...</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.min" title="Permalink to this definition"></a></dt>
<dd><p>When called with a single matrix argument, returns the minimum of the
elements of the matrix (including the zero entries, if the matrix is
sparse).</p>
<p>When called with multiple arguments, the arguments must be matrices of
the same size, or scalars, and the elementwise maximum is returned.
A 1 by 1 dense matrix is treated as a scalar if the other arguments
are not all 1 by 1.  If one of the arguments is scalar, and the other
arguments are not all 1 by 1, then the scalar argument is interpreted
as a dense matrix with all its entries equal to the scalar.</p>
<p><a class="reference internal" href="#cvxopt.min" title="cvxopt.min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min</span></code></a> can also be called with an iterable
(list, tuple, range object, or generator) as its single argument,
if the iterable generates a list of dense or sparse matrices or
scalars.</p>
</dd></dl>

</section>
<section id="randomly-generated-matrices">
<span id="s-random"></span><h2>Randomly Generated Matrices<a class="headerlink" href="#randomly-generated-matrices" title="Permalink to this heading"></a></h2>
<p>The CVXOPT package provides two functions
<a class="reference internal" href="#cvxopt.normal" title="cvxopt.normal"><code class="xref py py-func docutils literal notranslate"><span class="pre">normal</span></code></a> and
<a class="reference internal" href="#cvxopt.uniform" title="cvxopt.uniform"><code class="xref py py-func docutils literal notranslate"><span class="pre">uniform</span></code></a> for generating randomly distributed
matrices.
The default installation relies on the pseudo-random number generators in
the Python standard library <code class="xref py py-mod docutils literal notranslate"><span class="pre">random</span></code>.  Alternatively, the random
number generators in the
<a class="reference external" href="http://www.gnu.org/software/gsl">GNU Scientific Library (GSL)</a>
can be used, if this option is selected during the installation of CVXOPT.
The random matrix functions based on GSL are faster than the default
functions based on the <code class="xref py py-mod docutils literal notranslate"><span class="pre">random</span></code> module.</p>
<dl class="py function">
<dt class="sig sig-object py" id="cvxopt.normal">
<span class="sig-prename descclassname"><span class="pre">cvxopt.</span></span><span class="sig-name descname"><span class="pre">normal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nrows</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">ncols</span> <span class="pre">=</span> <span class="pre">1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mean</span> <span class="pre">=</span> <span class="pre">0.0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">std</span> <span class="pre">=</span> <span class="pre">1.0</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.normal" title="Permalink to this definition"></a></dt>
<dd><p>Returns a type <code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> dense matrix of size <code class="docutils literal notranslate"><span class="pre">nrows</span></code>  by
<code class="docutils literal notranslate"><span class="pre">ncols</span></code> with elements chosen from a normal distribution
with mean <code class="docutils literal notranslate"><span class="pre">mean</span></code> and standard deviation <code class="docutils literal notranslate"><span class="pre">std</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cvxopt.uniform">
<span class="sig-prename descclassname"><span class="pre">cvxopt.</span></span><span class="sig-name descname"><span class="pre">uniform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nrows</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">ncols</span> <span class="pre">=</span> <span class="pre">1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">0.0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">b</span> <span class="pre">=</span> <span class="pre">1.0</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.uniform" title="Permalink to this definition"></a></dt>
<dd><p>Returns a type <code class="xref py py-const docutils literal notranslate"><span class="pre">'d'</span></code> dense matrix of size <code class="docutils literal notranslate"><span class="pre">nrows</span></code> by
<code class="docutils literal notranslate"><span class="pre">ncols</span></code> matrix with elements uniformly distributed between <code class="docutils literal notranslate"><span class="pre">a</span></code> and
<code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cvxopt.setseed">
<span class="sig-prename descclassname"><span class="pre">cvxopt.</span></span><span class="sig-name descname"><span class="pre">setseed</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.setseed" title="Permalink to this definition"></a></dt>
<dd><p>Sets the state of the random number generator.  <code class="docutils literal notranslate"><span class="pre">value</span></code> must be an
integer.  If <code class="docutils literal notranslate"><span class="pre">value</span></code> is absent or equal to zero, the value is taken
from the system clock.  If the Python random number generators are
used, this is equivalent to <code class="samp docutils literal notranslate"><span class="pre">random.seed(value)</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cvxopt.getseed">
<span class="sig-prename descclassname"><span class="pre">cvxopt.</span></span><span class="sig-name descname"><span class="pre">getseed</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cvxopt.getseed" title="Permalink to this definition"></a></dt>
<dd><p>Returns the current state of the random number generator.  This
function is only available if the GSL random number generators are
installed.   (The state of the random number generators in the Python
<code class="xref py py-mod docutils literal notranslate"><span class="pre">random</span></code> module can be managed via the functions
<code class="xref py py-func docutils literal notranslate"><span class="pre">random.getstate</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">random.setstate</span></code>.)</p>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="intro.html" class="btn btn-neutral float-left" title="Introduction" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="blas.html" class="btn btn-neutral float-right" title="The BLAS Interface" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; <a href="copyright.html">Copyright</a> 2004-2023, M.S. Andersen, J. Dahl, L. Vandenberghe.
      <span class="lastupdated">Last updated on Aug 09, 2023.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <div class="footer">
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 5.0.1.
    </div>

</body>
</html>
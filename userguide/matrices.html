

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Dense and Sparse Matrices &mdash; CVXOPT User&#39;s Guide</title>
    
    <link rel="stylesheet" href="_static/cvxopt.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.1.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="copyright" title="Copyright" href="copyright.html" />
    <link rel="top" title="CVXOPT User&#39;s Guide" href="index.html" />
    <link rel="next" title="The BLAS Interface" href="blas.html" />
    <link rel="prev" title="Introduction" href="intro.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="blas.html" title="The BLAS Interface"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="intro.html" title="Introduction"
             accesskey="P">previous</a> |</li>
    <li><a href="http://cvxopt.org">CVXOPT home</a> |</li>
    
        <li><a href="index.html">user&#39;s guide</a> </li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="dense-and-sparse-matrices">
<span id="c-matrices"></span><h1>Dense and Sparse Matrices<a class="headerlink" href="#dense-and-sparse-matrices" title="Permalink to this headline">¶</a></h1>
<p>This chapter describes the two CVXOPT matrix types:
<a class="reference internal" href="#cvxopt.matrix" title="cvxopt.matrix"><tt class="xref py py-class docutils literal"><span class="pre">matrix</span></tt></a> objects, used for dense matrix
computations, and <a class="reference internal" href="#cvxopt.spmatrix" title="cvxopt.spmatrix"><tt class="xref py py-class docutils literal"><span class="pre">spmatrix</span></tt></a> objects, used for
sparse matrix computations.</p>
<div class="section" id="dense-matrices">
<span id="s-dense-matrices"></span><h2>Dense Matrices<a class="headerlink" href="#dense-matrices" title="Permalink to this headline">¶</a></h2>
<p>A dense matrix is created by calling the function <tt class="xref py py-func docutils literal"><span class="pre">matrix</span></tt>.  The
arguments specify the values of the coefficients, the dimensions, and the
type (integer, double, or complex) of the matrix.</p>
<dl class="function">
<dt id="cvxopt.matrix">
<tt class="descclassname">cvxopt.</tt><tt class="descname">matrix</tt><big>(</big><em>x</em><span class="optional">[</span>, <em>size</em><span class="optional">[</span>, <em>tc</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#cvxopt.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">size</span></tt>  is a tuple of length two with the matrix dimensions.
The number of rows and/or the number of columns can be zero.</p>
<p><tt class="docutils literal"><span class="pre">tc</span></tt>  stands for type code. The possible values are <tt class="xref py py-const docutils literal"><span class="pre">'i'</span></tt>,
<tt class="xref py py-const docutils literal"><span class="pre">'d'</span></tt>, and <tt class="xref py py-const docutils literal"><span class="pre">'z'</span></tt>, for integer, real (double), and complex
matrices, respectively.</p>
<p><tt class="docutils literal"><span class="pre">x</span></tt>  can be a number, a sequence of numbers, a dense or sparse
matrix, a one- or two-dimensional NumPy array, or a list of lists of
matrices and numbers.</p>
<ul>
<li><p class="first">If <tt class="docutils literal"><span class="pre">x</span></tt> is a number (Python integer, float, or complex number),
a matrix is created with the dimensions specified by <tt class="docutils literal"><span class="pre">size</span></tt> and
with all the coefficients equal to <tt class="docutils literal"><span class="pre">x</span></tt>.
The default value of <tt class="docutils literal"><span class="pre">size</span></tt>  is <tt class="docutils literal"><span class="pre">(1,1)</span></tt>, and the default value
of <tt class="docutils literal"><span class="pre">tc</span></tt> is the type of <tt class="docutils literal"><span class="pre">x</span></tt>.
If necessary, the type of <tt class="docutils literal"><span class="pre">x</span></tt> is converted (from integer to double
when used to create a matrix of type <tt class="xref py py-const docutils literal"><span class="pre">'d'</span></tt>, and from integer or
double to complex when used to create a matrix of type <tt class="xref py py-const docutils literal"><span class="pre">'z'</span></tt>).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ 1  1  1  1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ 1.00e+00  1.00e+00  1.00e+00  1.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1j</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ 1.00e+00+j1.00e+00]</span>
</pre></div>
</div>
</li>
<li><p class="first">If <tt class="docutils literal"><span class="pre">x</span></tt> is a sequence of numbers (list, tuple, array,
<tt class="xref py py-mod docutils literal"><span class="pre">array</span></tt> array, ...), then the numbers are interpreted as the
coefficients of a matrix in column-major order.
The length of <tt class="docutils literal"><span class="pre">x</span></tt>  must be equal to the product of
<tt class="docutils literal"><span class="pre">size[0]</span></tt> and <tt class="docutils literal"><span class="pre">size[1]</span></tt>.
If <tt class="docutils literal"><span class="pre">size</span></tt>  is not specified, a matrix with one column is created.
If <tt class="docutils literal"><span class="pre">tc</span></tt>  is not specified, it is determined from the elements of
<tt class="docutils literal"><span class="pre">x</span></tt>  (and if that is impossible, for example because <tt class="docutils literal"><span class="pre">x</span></tt>  is
an empty list, a value <tt class="xref py py-const docutils literal"><span class="pre">'i'</span></tt> is used).
Type conversion takes place as for scalar <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
<p>The following example shows several ways to define the same integer
matrix.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">array</span> <span class="kn">import</span> <span class="n">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">array</span><span class="p">(</span><span class="s">&#39;i&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ 0  2]</span>
<span class="go">[ 1  3]</span>
</pre></div>
</div>
<p>In Python 2.7 the following also works.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="nb">xrange</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
</li>
<li><p class="first">If <tt class="docutils literal"><span class="pre">x</span></tt>  is a dense or sparse matrix, then the coefficients of
<tt class="docutils literal"><span class="pre">x</span></tt>  are copied, in column-major order, to a new matrix of the
given size.
The total number of elements in the new matrix (the product of
<tt class="docutils literal"><span class="pre">size[0]</span></tt> and <tt class="docutils literal"><span class="pre">size[1]</span></tt>) must be the same as the product
of  the dimensions of <tt class="docutils literal"><span class="pre">x</span></tt>.  If <tt class="docutils literal"><span class="pre">size</span></tt>  is not specified, the
dimensions of <tt class="docutils literal"><span class="pre">x</span></tt>  are used.
The default value of <tt class="docutils literal"><span class="pre">tc</span></tt>  is the type of <tt class="docutils literal"><span class="pre">x</span></tt>.
Type conversion takes place when the type of <tt class="docutils literal"><span class="pre">x</span></tt> differs from
<tt class="docutils literal"><span class="pre">tc</span></tt>, in a similar way as for scalar <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">],</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ 1.00e+00  3.00e+00  5.00e+00]</span>
<span class="go">[ 2.00e+00  4.00e+00  6.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">[ 1.00e+00  4.00e+00]</span>
<span class="go">[ 2.00e+00  5.00e+00]</span>
<span class="go">[ 3.00e+00  6.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">tc</span><span class="o">=</span><span class="s">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go">[ 1.00e+00-j0.00e+00  4.00e+00-j0.00e+00]</span>
<span class="go">[ 2.00e+00-j0.00e+00  5.00e+00-j0.00e+00]</span>
<span class="go">[ 3.00e+00-j0.00e+00  6.00e+00-j0.00e+00]</span>
</pre></div>
</div>
<p>In Python 2.7 NumPy arrays can be converted to matrices.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">],</span> <span class="p">[</span><span class="mf">4.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[ 1.  2.  3.]</span>
<span class="go">       [ 4.  5.  6.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">matrix</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">[ 1.00e+00  2.00e+00  3.00e+00]</span>
<span class="go">[ 4.00e+00  5.00e+00  6.00e+00]</span>
</pre></div>
</div>
</li>
<li><p class="first">If <tt class="docutils literal"><span class="pre">x</span></tt> is a list of lists of dense or sparse matrices
and numbers (Python integer, float, or complex),
then each element of <tt class="docutils literal"><span class="pre">x</span></tt> is interpreted as a
block-column stored in column-major order.
If <tt class="docutils literal"><span class="pre">size</span></tt> is not specified, the block-columns are juxtaposed
to obtain a matrix with <tt class="docutils literal"><span class="pre">len(x)</span></tt>  block-columns.
If <tt class="docutils literal"><span class="pre">size</span></tt> is specified, then the matrix with <tt class="docutils literal"><span class="pre">len(x)</span></tt>
block-columns is resized by copying its elements in column-major
order into a matrix of the dimensions given by <tt class="docutils literal"><span class="pre">size</span></tt>.
If <tt class="docutils literal"><span class="pre">tc</span></tt> is not specified, it is determined from the elements of
<tt class="docutils literal"><span class="pre">x</span></tt> (and if that is impossible, for example because <tt class="docutils literal"><span class="pre">x</span></tt> is
a list of empty lists, a value <tt class="xref py py-const docutils literal"><span class="pre">'i'</span></tt> is used).
The same rules for type conversion apply as for scalar <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">matrix</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">],</span> <span class="p">[</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">],</span> <span class="p">[</span><span class="mf">5.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">]]))</span>
<span class="go">[ 1.00e+00  3.00e+00  5.00e+00]</span>
<span class="go">[ 2.00e+00  4.00e+00  6.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A1</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B1</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">],</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B2</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span><span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">17</span><span class="p">],</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B3</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span><span class="mi">18</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="n">A1</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">],</span> <span class="p">[</span><span class="n">B1</span><span class="p">,</span> <span class="n">B2</span><span class="p">,</span> <span class="n">B3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go">[ 1.00e+00  6.00e+00  8.00e+00  1.00e+01]</span>
<span class="go">[ 2.00e+00  7.00e+00  9.00e+00  1.10e+01]</span>
<span class="go">[ 3.00e+00  1.20e+01  1.40e+01  1.60e+01]</span>
<span class="go">[ 4.00e+00  1.30e+01  1.50e+01  1.70e+01]</span>
<span class="go">[ 5.00e+00  1.80e+01  1.90e+01  2.00e+01]</span>
</pre></div>
</div>
<p>A matrix with a single block-column can be represented by a single
list (i.e., if <tt class="docutils literal"><span class="pre">x</span></tt> is a list of lists, and has length one,
then the argument <tt class="docutils literal"><span class="pre">x</span></tt> can be replaced by <tt class="docutils literal"><span class="pre">x[0]</span></tt>).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span><span class="n">B1</span><span class="p">,</span> <span class="n">B2</span><span class="p">,</span> <span class="n">B3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="go">[  6   8  10]</span>
<span class="go">[  7   9  11]</span>
<span class="go">[ 12  14  16]</span>
<span class="go">[ 13  15  17]</span>
<span class="go">[ 18  19  20]</span>
</pre></div>
</div>
</li>
</ul>
</dd></dl>

</div>
<div class="section" id="sparse-matrices">
<span id="s-sparse-matrices"></span><h2>Sparse Matrices<a class="headerlink" href="#sparse-matrices" title="Permalink to this headline">¶</a></h2>
<p>A general <a class="reference internal" href="#cvxopt.spmatrix" title="cvxopt.spmatrix"><tt class="xref py py-class docutils literal"><span class="pre">spmatrix</span></tt></a> object can be thought of as
a <em>triplet description</em> of a sparse matrix, i.e., a list of entries of the
matrix, with for each entry the value, row index, and column index.
Entries that are not included in the list are assumed to be zero.
For example, the sparse matrix</p>
<div class="math">
<p><img src="_images/math/bee8975908ea146abf5a92e90f4cc1955c9f477b.png" alt="A = \left[ \begin{array}{rrrrr}
    0 &amp; 2 &amp; 0 &amp; 0 &amp; 3 \\
    2 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
   -1 &amp; -2 &amp; 0 &amp; 4 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \end{array} \right]"/></p>
</div><p>has the triplet description</p>
<div class="math">
<p><img src="_images/math/46260dba508c0827d1f9f6f8fb965791037f79d9.png" alt="(2,1,0), \qquad (-1,2,0), \qquad (2,0,1), \qquad (-2,2,1), \qquad
(1,3,2), \qquad (4,2,3), \qquad (3,0,4)."/></p>
</div><p>The list may include entries with a zero value, so triplet descriptions
are not necessarily unique.  The list</p>
<div class="math">
<p><img src="_images/math/44ca9c124a21e360685eaad738b7fe20d18fb2b3.png" alt="(2,1,0), \qquad (-1,2,0), \qquad (0,3,0), \qquad (2,0,1), \qquad
(-2,2,1), \qquad (1,3,2), \qquad (4,2,3), \qquad (3,0,4)"/></p>
</div><p>is another triplet description of the same matrix.</p>
<p>An <tt class="xref py py-class docutils literal"><span class="pre">spmatrix</span></tt> object corresponds to a particular
triplet description of a sparse matrix.  We will refer to the entries in
the triplet description as the <em>nonzero entries</em> of the object,
even though they may have a numerical value zero.</p>
<p>Three functions are provided to create sparse matrices.
The first, <tt class="xref py py-func docutils literal"><span class="pre">spmatrix</span></tt>,
constructs a sparse matrix from a triplet description.</p>
<dl class="function">
<dt id="cvxopt.spmatrix">
<tt class="descclassname">cvxopt.</tt><tt class="descname">spmatrix</tt><big>(</big><em>x</em>, <em>I</em>, <em>J</em><span class="optional">[</span>, <em>size</em><span class="optional">[</span>, <em>tc</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#cvxopt.spmatrix" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">I</span></tt> and <tt class="docutils literal"><span class="pre">J</span></tt> are sequences of integers (lists, tuples,
<tt class="xref py py-mod docutils literal"><span class="pre">array</span></tt> arrays, ...) or integer matrices
(<a class="reference internal" href="#cvxopt.matrix" title="cvxopt.matrix"><tt class="xref py py-class docutils literal"><span class="pre">matrix</span></tt></a> objects with typecode <tt class="xref py py-const docutils literal"><span class="pre">'i'</span></tt>),
containing the row and column indices of the nonzero entries.
The lengths of <tt class="docutils literal"><span class="pre">I</span></tt> and <tt class="docutils literal"><span class="pre">J</span></tt> must be  equal.  If they are matrices,
they are treated as lists of indices stored in column-major order,
i.e., as lists <tt class="docutils literal"><span class="pre">list(I)</span></tt>, respectively, <tt class="docutils literal"><span class="pre">list(J)</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">size</span></tt> is a tuple of nonnegative integers with the row and column
dimensions of the matrix.
The <tt class="docutils literal"><span class="pre">size</span></tt> argument is only needed when creating a matrix with
a zero last row or last column.  If <tt class="docutils literal"><span class="pre">size</span></tt> is not specified, it
is determined from <tt class="docutils literal"><span class="pre">I</span></tt> and <tt class="docutils literal"><span class="pre">J</span></tt>:
the default value for <tt class="docutils literal"><span class="pre">size[0]</span></tt> is <tt class="docutils literal"><span class="pre">max(I)+1</span></tt> if <tt class="docutils literal"><span class="pre">I</span></tt> is
nonempty and zero otherwise.
The default value for <tt class="docutils literal"><span class="pre">size[1]</span></tt> is <tt class="docutils literal"><span class="pre">max(J)+1</span></tt> if <tt class="docutils literal"><span class="pre">J</span></tt> is
nonempty and zero otherwise.</p>
<p><tt class="docutils literal"><span class="pre">tc</span></tt> is the typecode, <tt class="xref py py-const docutils literal"><span class="pre">'d'</span></tt> or <tt class="xref py py-const docutils literal"><span class="pre">'z'</span></tt>, for double and
complex matrices, respectively.   Integer sparse matrices are
not implemented.</p>
<p><tt class="docutils literal"><span class="pre">x</span></tt> can be a number, a sequence of numbers, or a dense matrix.
This argument specifies the numerical values of the nonzero entries.</p>
<ul>
<li><p class="first">If <tt class="docutils literal"><span class="pre">x</span></tt> is a number (Python integer, float, or complex),
a matrix is created with the sparsity pattern defined by <tt class="docutils literal"><span class="pre">I</span></tt> and
<tt class="docutils literal"><span class="pre">J</span></tt>, and nonzero entries initialized to the value of <tt class="docutils literal"><span class="pre">x</span></tt>.
The default value of <tt class="docutils literal"><span class="pre">tc</span></tt> is <tt class="xref py py-const docutils literal"><span class="pre">'d'</span></tt> if <tt class="docutils literal"><span class="pre">x</span></tt> is integer or
float, and <tt class="xref py py-const docutils literal"><span class="pre">'z'</span></tt> if <tt class="docutils literal"><span class="pre">x</span></tt>  is complex.</p>
<p>The following code creates a 4 by 4 sparse identity matrix.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">spmatrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">   [ 1.00e+00     0         0         0    ]</span>
<span class="go">   [    0      1.00e+00     0         0    ]</span>
<span class="go">   [    0         0      1.00e+00     0    ]</span>
<span class="go">   [    0         0         0      1.00e+00]</span>
</pre></div>
</div>
</li>
<li><p class="first">If <tt class="docutils literal"><span class="pre">x</span></tt> is a sequence of numbers, a sparse matrix is created
with the entries of <tt class="docutils literal"><span class="pre">x</span></tt> copied to the entries indexed by <tt class="docutils literal"><span class="pre">I</span></tt>
and <tt class="docutils literal"><span class="pre">J</span></tt>.  The list <tt class="docutils literal"><span class="pre">x</span></tt> must have the same length as <tt class="docutils literal"><span class="pre">I</span></tt> and
<tt class="docutils literal"><span class="pre">J</span></tt>.
The default value of <tt class="docutils literal"><span class="pre">tc</span></tt> is determined from the elements of <tt class="docutils literal"><span class="pre">x</span></tt>:
<tt class="xref py py-const docutils literal"><span class="pre">'d'</span></tt> if <tt class="docutils literal"><span class="pre">x</span></tt> contains integers and floating-point numbers or
if <tt class="docutils literal"><span class="pre">x</span></tt> is an empty list, and <tt class="xref py py-const docutils literal"><span class="pre">'z'</span></tt> if <tt class="docutils literal"><span class="pre">x</span></tt> contains at
least one complex number.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">  [    0      2.00e+00     0         0      3.00e+00]</span>
<span class="go">  [ 2.00e+00     0         0         0         0    ]</span>
<span class="go">  [-1.00e+00 -2.00e+00     0      4.00e+00     0    ]</span>
<span class="go">  [    0         0      1.00e+00     0         0    ]</span>
</pre></div>
</div>
</li>
<li><p class="first">If <tt class="docutils literal"><span class="pre">x</span></tt> is a dense matrix, a sparse matrix is created with
all the entries of <tt class="docutils literal"><span class="pre">x</span></tt> copied, in column-major order, to the
entries indexed by <tt class="docutils literal"><span class="pre">I</span></tt> and <tt class="docutils literal"><span class="pre">J</span></tt>.
The matrix <tt class="docutils literal"><span class="pre">x</span></tt> must have the same length as <tt class="docutils literal"><span class="pre">I</span></tt> and <tt class="docutils literal"><span class="pre">J</span></tt>.
The default value of <tt class="docutils literal"><span class="pre">tc</span></tt> is <tt class="xref py py-const docutils literal"><span class="pre">'d'</span></tt> if <tt class="docutils literal"><span class="pre">x</span></tt> is an
<tt class="xref py py-const docutils literal"><span class="pre">'i'</span></tt> or <tt class="xref py py-const docutils literal"><span class="pre">'d'</span></tt> matrix, and <tt class="xref py py-const docutils literal"><span class="pre">'z'</span></tt> otherwise.
If <tt class="docutils literal"><span class="pre">I</span></tt> and <tt class="docutils literal"><span class="pre">J</span></tt> contain repeated entries, the corresponding
values of the coefficients are added.</p>
</li>
</ul>
</dd></dl>

<p>The function <tt class="xref py py-func docutils literal"><span class="pre">sparse</span></tt> constructs a sparse matrix
from a block-matrix description.</p>
<dl class="function">
<dt id="cvxopt.sparse">
<tt class="descclassname">cvxopt.</tt><tt class="descname">sparse</tt><big>(</big><em>x</em><span class="optional">[</span>, <em>tc</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#cvxopt.sparse" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">tc</span></tt> is the typecode, <tt class="xref py py-const docutils literal"><span class="pre">'d'</span></tt> or <tt class="xref py py-const docutils literal"><span class="pre">'z'</span></tt>, for double and
complex matrices, respectively.</p>
<p><tt class="docutils literal"><span class="pre">x</span></tt> can be a <tt class="xref py py-class docutils literal"><span class="pre">matrix</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">spmatrix</span></tt>, or a list of lists
of matrices (<tt class="xref py py-class docutils literal"><span class="pre">matrix</span></tt> or <tt class="xref py py-class docutils literal"><span class="pre">spmatrix</span></tt> objects) and
numbers (Python integer, float, or complex).</p>
<ul class="simple">
<li>If <tt class="docutils literal"><span class="pre">x</span></tt> is a <tt class="xref py py-class docutils literal"><span class="pre">matrix</span></tt> or <tt class="xref py py-class docutils literal"><span class="pre">spmatrix</span></tt> object, then a
sparse matrix of the same size and the same numerical value is
created.  Numerical zeros in <tt class="docutils literal"><span class="pre">x</span></tt> are treated as structural zeros
and removed from the triplet description of the new sparse matrix.</li>
<li>If <tt class="docutils literal"><span class="pre">x</span></tt> is a list of lists of matrices (<tt class="xref py py-class docutils literal"><span class="pre">matrix</span></tt> or
<tt class="xref py py-class docutils literal"><span class="pre">spmatrix</span></tt> objects) and numbers (Python integer, float, or
complex) then each element of <tt class="docutils literal"><span class="pre">x</span></tt> is interpreted as a
(block-)column matrix stored in colum-major order, and a
block-matrix is constructed by juxtaposing the <tt class="docutils literal"><span class="pre">len(x)</span></tt>
block-columns (as in <a class="reference internal" href="#cvxopt.matrix" title="cvxopt.matrix"><tt class="xref py py-func docutils literal"><span class="pre">matrix</span></tt></a>).
Numerical zeros are removed from the triplet description of the new
matrix.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">spmatrix</span><span class="p">,</span> <span class="n">sparse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ 1.00e+00  2.00e+00  0.00e+00]</span>
<span class="go">[ 2.00e+00  1.00e+00  2.00e+00]</span>
<span class="go">[ 0.00e+00  2.00e+00  1.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">([],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">[0 0 0]</span>
<span class="go">[0 0 0]</span>
<span class="go">[0 0 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go">[ 3.00e+00     0         0    ]</span>
<span class="go">[    0      4.00e+00     0    ]</span>
<span class="go">[    0         0      5.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">sparse</span><span class="p">([[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">],</span> <span class="p">[</span><span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="go">[ 1.00e+00  2.00e+00     0         0         0         0    ]</span>
<span class="go">[ 2.00e+00  1.00e+00  2.00e+00     0         0         0    ]</span>
<span class="go">[    0      2.00e+00  1.00e+00     0         0         0    ]</span>
<span class="go">[    0         0         0      3.00e+00     0         0    ]</span>
<span class="go">[    0         0         0         0      4.00e+00     0    ]</span>
<span class="go">[    0         0         0         0         0      5.00e+00]</span>
</pre></div>
</div>
<p>A matrix with a single block-column can be represented by a single
list.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">sparse</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">C</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="go">[ 1.00e+00  2.00e+00     0    ]</span>
<span class="go">[ 2.00e+00  1.00e+00  2.00e+00]</span>
<span class="go">[    0      2.00e+00  1.00e+00]</span>
<span class="go">[ 3.00e+00     0         0    ]</span>
<span class="go">[    0      4.00e+00     0    ]</span>
<span class="go">[    0         0      5.00e+00]</span>
</pre></div>
</div>
</dd></dl>

<p>The function <tt class="xref py py-func docutils literal"><span class="pre">spdiag</span></tt> constructs a block-diagonal
sparse matrix from a list of matrices.</p>
<dl class="function">
<dt id="cvxopt.spdiag">
<tt class="descclassname">cvxopt.</tt><tt class="descname">spdiag</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#cvxopt.spdiag" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">x</span></tt> is a dense or sparse matrix with a single row or column, or a
list of square dense or sparse matrices or scalars.
If <tt class="docutils literal"><span class="pre">x</span></tt> is a matrix, a sparse diagonal matrix is returned with
the entries of <tt class="docutils literal"><span class="pre">x</span></tt> on its diagonal.
If <tt class="docutils literal"><span class="pre">x</span></tt> is list, a sparse block-diagonal matrix is returned with
the elements in the list as its diagonal blocks.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">spmatrix</span><span class="p">,</span> <span class="n">spdiag</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="mf">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">],[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">spdiag</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="go">[ 3.00e+00     0         0         0         0         0    ]</span>
<span class="go">[    0      1.00e+00 -2.00e+00     0         0         0    ]</span>
<span class="go">[    0     -2.00e+00  1.00e+00     0         0         0    ]</span>
<span class="go">[    0         0         0      1.00e+00  1.00e+00  1.00e+00]</span>
<span class="go">[    0         0         0      1.00e+00     0         0    ]</span>
<span class="go">[    0         0         0      1.00e+00     0         0    ]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="arithmetic-operations">
<span id="s-arithmetic"></span><h2>Arithmetic Operations<a class="headerlink" href="#arithmetic-operations" title="Permalink to this headline">¶</a></h2>
<p>The following table lists the arithmetic operations defined for dense and
sparse matrices.  In the table <tt class="docutils literal"><span class="pre">A</span></tt> and <tt class="docutils literal"><span class="pre">B</span></tt> are dense or sparse
matrices of compatible dimensions, <tt class="docutils literal"><span class="pre">c</span></tt>  is a scalar (a Python number or
a dense 1 by 1 matrix), <tt class="docutils literal"><span class="pre">D</span></tt> is a dense matrix, and <tt class="docutils literal"><span class="pre">e</span></tt> is a Python
number.</p>
<table border="1" class="docutils">
<colgroup>
<col width="59%" />
<col width="41%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Unary plus/minus</td>
<td><tt class="docutils literal"><span class="pre">+A,</span> <span class="pre">-A</span></tt></td>
</tr>
<tr class="row-even"><td>Addition</td>
<td><tt class="docutils literal"><span class="pre">A</span> <span class="pre">+</span> <span class="pre">B,</span> <span class="pre">A</span> <span class="pre">+</span> <span class="pre">c,</span> <span class="pre">c</span> <span class="pre">+</span> <span class="pre">A</span></tt></td>
</tr>
<tr class="row-odd"><td>Subtraction</td>
<td><tt class="docutils literal"><span class="pre">A</span> <span class="pre">-</span> <span class="pre">B,</span> <span class="pre">A</span> <span class="pre">-</span> <span class="pre">c,</span> <span class="pre">c</span> <span class="pre">-</span> <span class="pre">A</span></tt></td>
</tr>
<tr class="row-even"><td>Matrix multiplication</td>
<td><tt class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">B</span></tt></td>
</tr>
<tr class="row-odd"><td>Scalar multiplication and division</td>
<td><tt class="docutils literal"><span class="pre">c</span> <span class="pre">*</span> <span class="pre">A,</span> <span class="pre">A</span> <span class="pre">*</span> <span class="pre">c,</span> <span class="pre">A</span> <span class="pre">/</span> <span class="pre">c</span></tt></td>
</tr>
<tr class="row-even"><td>Remainder after division</td>
<td><tt class="docutils literal"><span class="pre">D</span> <span class="pre">%</span> <span class="pre">c</span></tt></td>
</tr>
<tr class="row-odd"><td>Elementwise exponentiation</td>
<td><tt class="docutils literal"><span class="pre">D**e</span></tt></td>
</tr>
</tbody>
</table>
<p>The type of the result of these operations generally follows the Python
conventions.
For example, if <tt class="docutils literal"><span class="pre">A</span></tt> and <tt class="docutils literal"><span class="pre">c</span></tt> are integer, then in Python 2 the division
<tt class="docutils literal"><span class="pre">A/c</span></tt> is interpreted as integer division and results in a
type <tt class="xref py py-const docutils literal"><span class="pre">'i'</span></tt> matrix, while in Python 3 it is interpreted as standard
divison and results in a type <tt class="xref py py-const docutils literal"><span class="pre">'d'</span></tt> matrix.
An exception to the Python conventions is elementwise exponentiation:
if <tt class="docutils literal"><span class="pre">D</span></tt> is an integer matrix and <tt class="docutils literal"><span class="pre">e</span></tt> is an integer number
than <tt class="docutils literal"><span class="pre">D**e</span></tt> is a matrix of type <tt class="xref py py-const docutils literal"><span class="pre">'d'</span></tt>.</p>
<p>Addition, subtraction, and matrix multiplication with two matrix operands
result in a sparse matrix if both matrices are sparse, and in a dense
matrix otherwise.  The result of a scalar multiplication or division is
dense if <tt class="docutils literal"><span class="pre">A</span></tt> is dense, and sparse if <tt class="docutils literal"><span class="pre">A</span></tt> is sparse.  Postmultiplying
a matrix with a number <tt class="docutils literal"><span class="pre">c</span></tt> means the same as premultiplying, i.e.,
scalar multiplication.  Dividing a matrix by <tt class="docutils literal"><span class="pre">c</span></tt> means dividing all its
entries by <tt class="docutils literal"><span class="pre">c</span></tt>.</p>
<p>If <tt class="docutils literal"><span class="pre">c</span></tt> in the expressions <tt class="docutils literal"><span class="pre">A+c</span></tt>, <tt class="docutils literal"><span class="pre">c+A</span></tt>, <tt class="docutils literal"><span class="pre">A-c</span></tt>, <tt class="docutils literal"><span class="pre">c-A</span></tt> is a number,
then it is interpreted as a dense matrix with
the same dimensions as <tt class="docutils literal"><span class="pre">A</span></tt>, type given by the type of <tt class="docutils literal"><span class="pre">c</span></tt>, and all
its entries equal to <tt class="docutils literal"><span class="pre">c</span></tt>.  If <tt class="docutils literal"><span class="pre">c</span></tt>  is a 1 by 1 dense matrix and <tt class="docutils literal"><span class="pre">A</span></tt>
is not 1 by 1, then <tt class="docutils literal"><span class="pre">c</span></tt> is interpreted as a dense matrix with the same
size of <tt class="docutils literal"><span class="pre">A</span></tt> and all entries equal to <tt class="docutils literal"><span class="pre">c[0]</span></tt>.</p>
<p>If <tt class="docutils literal"><span class="pre">c</span></tt> is a 1 by 1 dense matrix, then, if possible, the products
<tt class="docutils literal"><span class="pre">c*A</span></tt> and <tt class="docutils literal"><span class="pre">A*c</span></tt> are interpreted as matrix-matrix products.
If the product cannot be interpreted as a matrix-matrix product
because the dimensions of <tt class="docutils literal"><span class="pre">A</span></tt> are incompatible, then the product is
interpreted as the scalar multiplication with <tt class="docutils literal"><span class="pre">c[0]</span></tt>.
The division <tt class="docutils literal"><span class="pre">A/c</span></tt> and remainder <tt class="docutils literal"><span class="pre">A%c</span></tt> with <tt class="docutils literal"><span class="pre">c</span></tt> a
1 by 1 matrix are always interpreted as <tt class="docutils literal"><span class="pre">A/c[0]</span></tt>, resp., <tt class="docutils literal"><span class="pre">A%c[0]</span></tt>.</p>
<p>The following in-place operations are also defined, but only if they do
not change the type (sparse or dense, integer, real, or complex) of the
matrix <tt class="docutils literal"><span class="pre">A</span></tt>.  These in-place operations do not return a new matrix but
modify the existing object <tt class="docutils literal"><span class="pre">A</span></tt>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="69%" />
<col width="31%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>In-place addition</td>
<td><tt class="docutils literal"><span class="pre">A</span> <span class="pre">+=</span> <span class="pre">B,</span> <span class="pre">A</span> <span class="pre">+=</span> <span class="pre">c</span></tt></td>
</tr>
<tr class="row-even"><td>In-place subtraction</td>
<td><tt class="docutils literal"><span class="pre">A</span> <span class="pre">-=</span> <span class="pre">B,</span> <span class="pre">A</span> <span class="pre">-=</span> <span class="pre">c</span></tt></td>
</tr>
<tr class="row-odd"><td>In-place scalar multiplication and division</td>
<td><tt class="docutils literal"><span class="pre">A</span> <span class="pre">*=</span> <span class="pre">c,</span> <span class="pre">A</span> <span class="pre">/=</span> <span class="pre">c</span></tt></td>
</tr>
<tr class="row-even"><td>In-place remainder</td>
<td><tt class="docutils literal"><span class="pre">A</span> <span class="pre">%=</span> <span class="pre">c</span></tt></td>
</tr>
</tbody>
</table>
<p>For example, if <tt class="docutils literal"><span class="pre">A</span></tt> has typecode <tt class="xref py py-const docutils literal"><span class="pre">'i'</span></tt>, then <tt class="docutils literal"><span class="pre">A</span> <span class="pre">+=</span> <span class="pre">B</span></tt> is
allowed if <tt class="docutils literal"><span class="pre">B</span></tt> has typecode <tt class="xref py py-const docutils literal"><span class="pre">'i'</span></tt>.  It is not allowed if <tt class="docutils literal"><span class="pre">B</span></tt>
has typecode <tt class="xref py py-const docutils literal"><span class="pre">'d'</span></tt> or <tt class="xref py py-const docutils literal"><span class="pre">'z'</span></tt> because the addition
<tt class="docutils literal"><span class="pre">A+B</span></tt> results in a <tt class="xref py py-const docutils literal"><span class="pre">'d'</span></tt> or <tt class="xref py py-const docutils literal"><span class="pre">'z'</span></tt> matrix and
therefore cannot be assigned to <tt class="docutils literal"><span class="pre">A</span></tt> without changing its type.
As another example, if <tt class="docutils literal"><span class="pre">A</span></tt> is a sparse matrix, then <tt class="docutils literal"><span class="pre">A</span> <span class="pre">+=</span> <span class="pre">1.0</span></tt> is
not allowed because the operation <tt class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">A</span> <span class="pre">+</span> <span class="pre">1.0</span></tt> results in a dense
matrix, so it cannot be assigned to <tt class="docutils literal"><span class="pre">A</span></tt> without changing its type.</p>
<p>In-place matrix-matrix products are not allowed.  (Except when <tt class="docutils literal"><span class="pre">c</span></tt> is
a 1 by 1 dense matrix, in which case <tt class="docutils literal"><span class="pre">A</span> <span class="pre">*=</span> <span class="pre">c</span></tt> is interpreted as the
scalar product <tt class="docutils literal"><span class="pre">A</span> <span class="pre">*=</span> <span class="pre">c[0]</span></tt>.)</p>
<p>In-place remainder is only defined for dense <tt class="docutils literal"><span class="pre">A</span></tt>.</p>
<p>It is important to know when a matrix operation creates a new object.
The following rules apply.</p>
<ul>
<li><p class="first">A simple assignment (<tt class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">B</span></tt>) is given the standard Python
interpretation, i.e., it assigns to the variable <tt class="docutils literal"><span class="pre">A</span></tt> a reference (or
pointer) to the object referenced by <tt class="docutils literal"><span class="pre">B</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">],</span> <span class="p">[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">4.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">[ 1.00e+00  3.00e+00]</span>
<span class="go">[ 2.00e+00  4.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">B</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>   <span class="c"># modifying A[0,0] also modified B[0,0]</span>
<span class="go">[-1.00e+00  3.00e+00]</span>
<span class="go">[ 2.00e+00  4.00e+00]</span>
</pre></div>
</div>
</li>
<li><p class="first">The regular (i.e., not in-place) arithmetic operations always return
new objects.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">],</span> <span class="p">[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">4.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="o">+</span><span class="n">B</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>   <span class="c"># modifying A[0,0] does not modify B[0,0]</span>
<span class="go">[ 1.00e+00  3.00e+00]</span>
<span class="go">[ 2.00e+00  4.00e+00]</span>
</pre></div>
</div>
</li>
<li><p class="first">The in-place operations directly modify the coefficients of the
existing matrix object and do not create a new object.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">],</span> <span class="p">[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">4.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">B</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">*=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>   <span class="c"># in-place operation also changed B</span>
<span class="go">[ 2.00e+00  6.00e+00]</span>
<span class="go">[ 4.00e+00  8.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>   <span class="c"># regular operation creates a new A, so does not change B</span>
<span class="go">[ 2.00e+00  6.00e+00]</span>
<span class="go">[ 4.00e+00  8.00e+00]</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="indexing-and-slicing">
<span id="s-indexing"></span><h2>Indexing and Slicing<a class="headerlink" href="#indexing-and-slicing" title="Permalink to this headline">¶</a></h2>
<p>Matrices can be indexed using one or two arguments.  In single-argument
indexing of a matrix <tt class="docutils literal"><span class="pre">A</span></tt>, the index runs from <tt class="docutils literal"><span class="pre">-len(A)</span></tt> to
<tt class="docutils literal"><span class="pre">len(A)-1</span></tt>, and is interpreted as an index in the one-dimensional
array of coefficients of <tt class="docutils literal"><span class="pre">A</span></tt> in column-major order.   Negative indices
have the standard Python interpretation: for negative <tt class="docutils literal"><span class="pre">k</span></tt>,
<tt class="docutils literal"><span class="pre">A[k]</span></tt> is the same element as <tt class="docutils literal"><span class="pre">A[len(A)</span> <span class="pre">+</span> <span class="pre">k]</span></tt>.</p>
<p>Four different types of one-argument indexing are implemented.</p>
<ol class="arabic simple">
<li>The index can be a single integer.
This returns a number, e.g., <tt class="docutils literal"><span class="pre">A[0]</span></tt> is the first element of <tt class="docutils literal"><span class="pre">A</span></tt>.</li>
<li>The index can be an integer matrix.  This returns a column matrix: the
command <tt class="docutils literal"><span class="pre">A[matrix([0,1,2,3])]</span></tt> returns the 4 by 1 matrix
consisting of the first four elements of <tt class="docutils literal"><span class="pre">A</span></tt>.  The size of the index
matrix is ignored: <tt class="docutils literal"><span class="pre">A[matrix([0,1,2,3],</span> <span class="pre">(2,2))]</span></tt> returns the same
4 by 1 matrix.</li>
<li>The index can be a list of integers.  This returns a column matrix,
e.g., <tt class="docutils literal"><span class="pre">A[[0,1,2,3]]</span></tt> is the 4 by 1 matrix consisting of elements
0, 1, 2, 3 of <tt class="docutils literal"><span class="pre">A</span></tt>.</li>
<li>The index can be a Python slice.  This returns a matrix with one column
(possibly 0 by 1, or 1 by 1).  For example, <tt class="docutils literal"><span class="pre">A[::2]</span></tt> is the column
matrix defined by taking every other element of <tt class="docutils literal"><span class="pre">A</span></tt>, stored in
column-major order.  <tt class="docutils literal"><span class="pre">A[0:0]</span></tt> is a matrix with size (0,1).</li>
</ol>
<p>Thus, single-argument indexing returns a scalar (if the index is an
integer), or a matrix with one column.  This is consistent with the
interpretation that single-argument indexing accesses the matrix in
column-major order.</p>
<p>Note that an index list or an index matrix are equivalent, but they are
both useful, especially when we perform operations on index sets.  For
example, if <tt class="docutils literal"><span class="pre">I</span></tt> and <tt class="docutils literal"><span class="pre">J</span></tt> are lists then <tt class="docutils literal"><span class="pre">I+J</span></tt> is the
concatenated list, and <tt class="docutils literal"><span class="pre">2*I</span></tt> is <tt class="docutils literal"><span class="pre">I</span></tt> repeated twice.  If they
are matrices, these operations are interpreted as arithmetic operations.
For large index sets, indexing with integer matrices is also faster
than indexing with lists.</p>
<p>The following example illustrates one-argument indexing.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">spmatrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="s">&#39;d&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ 0.00e+00  4.00e+00  8.00e+00  1.20e+01]</span>
<span class="go">[ 1.00e+00  5.00e+00  9.00e+00  1.30e+01]</span>
<span class="go">[ 2.00e+00  6.00e+00  1.00e+01  1.40e+01]</span>
<span class="go">[ 3.00e+00  7.00e+00  1.10e+01  1.50e+01]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
<span class="go">4.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">I</span><span class="p">])</span>      <span class="c"># the diagonal</span>
<span class="go">[ 0.00e+00]</span>
<span class="go">[ 5.00e+00]</span>
<span class="go">[ 1.00e+01]</span>
<span class="go">[ 1.50e+01]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">];</span>  <span class="n">J</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="o">+</span><span class="n">J</span><span class="p">])</span>  <span class="c"># duplicate I and append J</span>
<span class="go">[ 0.00e+00]</span>
<span class="go">[ 2.00e+00]</span>
<span class="go">[ 0.00e+00]</span>
<span class="go">[ 2.00e+00]</span>
<span class="go">[ 1.00e+00]</span>
<span class="go">[ 3.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]);</span>  <span class="n">J</span> <span class="o">=</span>  <span class="n">matrix</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="o">+</span><span class="n">J</span><span class="p">])</span>  <span class="c"># multiply I by 2 and add J</span>
<span class="go">[ 1.00e+00]</span>
<span class="go">[ 7.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">4</span><span class="p">::</span><span class="mi">4</span><span class="p">])</span>   <span class="c"># get every fourth element skipping the first four</span>
<span class="go">[ 4.00e+00]</span>
<span class="go">[ 8.00e+00]</span>
<span class="go">[ 1.20e+01]</span>
</pre></div>
</div>
<p>In two-argument indexing the arguments can be any combinations of the
four types listed above.  The first argument indexes the rows of
the matrix and the second argument indexes the columns.  If both
indices are scalars, then a scalar is returned.  In all other cases,
a matrix is returned.  We continue the example.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">[ 4.00e+00]</span>
<span class="go">[ 5.00e+00]</span>
<span class="go">[ 6.00e+00]</span>
<span class="go">[ 7.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">J</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">J</span><span class="p">,</span><span class="n">J</span><span class="p">])</span>
<span class="go">[ 0.00e+00  8.00e+00]</span>
<span class="go">[ 2.00e+00  1.00e+01]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">:])</span>
<span class="go">[ 8.00e+00  1.20e+01]</span>
<span class="go">[ 9.00e+00  1.30e+01]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="go">[ 0.00e+00  2.00e+00]</span>
<span class="go">[ 2.00e+00     0    ]</span>
<span class="go">[-1.00e+00 -2.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="mi">1j</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:,</span><span class="o">-</span><span class="mi">2</span><span class="p">:])</span>
<span class="go">[ 0.00e+00-j0.00e+00  0.00e+00-j0.00e+00]</span>
<span class="go">[ 0.00e+00+j2.00e+00 -2.00e+00-j0.00e+00]</span>
</pre></div>
</div>
<p>Expressions of the form <tt class="docutils literal"><span class="pre">A[I]</span></tt> or <tt class="docutils literal"><span class="pre">A[I,J]</span></tt> can also appear on
the left-hand side of an assignment.   The right-hand side must be a
scalar
(i.e., a number or a 1 by 1 dense matrix), a sequence of numbers, or a
dense or sparse matrix.  If the right-hand side is a scalar, it is
interpreted as a dense matrix with identical entries and the dimensions of
the left-hand side.  If the right-hand side is a sequence of numbers
(list, tuple, <tt class="xref py py-mod docutils literal"><span class="pre">array</span></tt> array, range object, ...) its values are
interpreted
as the coefficients of a dense matrix in column-major order.  If the
right-hand side is a matrix (<tt class="xref py py-class docutils literal"><span class="pre">matrix</span></tt> or
<tt class="xref py py-class docutils literal"><span class="pre">spmatrix</span></tt>), it must
have the same size as the left-hand side.  Sparse matrices are
converted to dense in the assignment to a dense matrix.</p>
<p>Indexed assignments are only allowed if they do not change the type of
the matrix.  For example, if <tt class="docutils literal"><span class="pre">A</span></tt> is a matrix with type <tt class="xref py py-const docutils literal"><span class="pre">'d'</span></tt>,
then <tt class="docutils literal"><span class="pre">A[I]</span> <span class="pre">=</span> <span class="pre">B</span></tt> is only permitted if <tt class="docutils literal"><span class="pre">B</span></tt> is an integer, a float,
or a matrix of type <tt class="xref py py-const docutils literal"><span class="pre">'i'</span></tt> or <tt class="xref py py-const docutils literal"><span class="pre">'d'</span></tt>.  If <tt class="docutils literal"><span class="pre">A</span></tt> is an integer
matrix, then <tt class="docutils literal"><span class="pre">A[I]</span> <span class="pre">=</span> <span class="pre">B</span></tt> is only permitted if <tt class="docutils literal"><span class="pre">B</span></tt> is an integer or
an integer matrix.</p>
<p>The following examples illustrate indexed assignment.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">[::</span><span class="mi">2</span><span class="p">,::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ -1   4  -3  12]</span>
<span class="go">[  1   5   9  13]</span>
<span class="go">[ -2   6  -4  14]</span>
<span class="go">[  3   7  11  15]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">[::</span><span class="mi">5</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[  0   4  -3  12]</span>
<span class="go">[  1   6   9  13]</span>
<span class="go">[ -2   6  -3  14]</span>
<span class="go">[  3   7  11  16]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ -1   1  -1   1]</span>
<span class="go">[  1   6   9  13]</span>
<span class="go">[ -2   6  -3  14]</span>
<span class="go">[  3   7  11  16]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">:,</span><span class="mi">2</span><span class="p">:]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ -1   1  -1   1]</span>
<span class="go">[  1   6   9  13]</span>
<span class="go">[ -2   6   0   2]</span>
<span class="go">[  3   7   1   3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ 0.00e+00  2.00e+00     0    ]</span>
<span class="go">[ 2.00e+00     0      1.00e+00]</span>
<span class="go">[-1.00e+00 -2.00e+00     0    ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go">[ 1.00e+01     0    ]</span>
<span class="go">[    0      3.00e+01]</span>
<span class="go">[-2.00e+01     0    ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">C</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ 1.00e+01  2.00e+00     0    ]</span>
<span class="go">[    0         0      1.00e+00]</span>
<span class="go">[-2.00e+01 -2.00e+00     0    ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ 0.00e+00  2.00e+00     0    ]</span>
<span class="go">[ 1.00e+00     0      1.00e+00]</span>
<span class="go">[ 2.00e+00 -2.00e+00     0    ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ 1.00e+00  2.00e+00     0    ]</span>
<span class="go">[ 1.00e+00     0      1.00e+00]</span>
<span class="go">[ 1.00e+00 -2.00e+00     0    ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ 0.00e+00  2.00e+00     0    ]</span>
<span class="go">[ 0.00e+00     0      1.00e+00]</span>
<span class="go">[ 0.00e+00 -2.00e+00     0    ]</span>
</pre></div>
</div>
</div>
<div class="section" id="attributes-and-methods">
<h2>Attributes and Methods<a class="headerlink" href="#attributes-and-methods" title="Permalink to this headline">¶</a></h2>
<p>Dense and sparse matrices have the following attributes.</p>
<dl class="attribute">
<dt id="size">
<tt class="descname">size</tt><a class="headerlink" href="#size" title="Permalink to this definition">¶</a></dt>
<dd><p>A tuple with the dimensions of the matrix. The size of the matrix can
be changed by altering this attribute, as long as the number of
elements in the matrix remains unchanged.</p>
</dd></dl>

<dl class="attribute">
<dt id="typecode">
<tt class="descname">typecode</tt><a class="headerlink" href="#typecode" title="Permalink to this definition">¶</a></dt>
<dd><p>A character, either <tt class="xref py py-const docutils literal"><span class="pre">'i'</span></tt>, <tt class="xref py py-const docutils literal"><span class="pre">'d'</span></tt>, or <tt class="xref py py-const docutils literal"><span class="pre">'z'</span></tt>, for
integer, real, and complex matrices, respectively.  A read-only
attribute.</p>
</dd></dl>

<dl class="method">
<dt id="trans">
<tt class="descname">trans</tt><big>(</big><big>)</big><a class="headerlink" href="#trans" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the transpose of the matrix as a new matrix.  One can also use
<tt class="docutils literal"><span class="pre">A.T</span></tt> instead of <tt class="docutils literal"><span class="pre">A.trans()</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="ctrans">
<tt class="descname">ctrans</tt><big>(</big><big>)</big><a class="headerlink" href="#ctrans" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the conjugate transpose of the matrix as a new matrix.  One
can also use <tt class="docutils literal"><span class="pre">A.H</span></tt> instead of <tt class="docutils literal"><span class="pre">A.ctrans()</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="real">
<tt class="descname">real</tt><big>(</big><big>)</big><a class="headerlink" href="#real" title="Permalink to this definition">¶</a></dt>
<dd><p>For complex matrices, returns the real part as a real matrix.  For
integer and real matrices, returns a copy of the matrix.</p>
</dd></dl>

<dl class="method">
<dt id="imag">
<tt class="descname">imag</tt><big>(</big><big>)</big><a class="headerlink" href="#imag" title="Permalink to this definition">¶</a></dt>
<dd><p>For complex matrices, returns the imaginary part as a real matrix.
For integer and real matrices, returns an integer or real zero matrix.</p>
</dd></dl>

<p>In addition, sparse matrices have the following attributes.</p>
<dl class="attribute">
<dt id="V">
<tt class="descname">V</tt><a class="headerlink" href="#V" title="Permalink to this definition">¶</a></dt>
<dd><p>A single-column dense matrix containing the numerical values of the
nonzero entries in column-major order.  Making an assignment to the
attribute is an efficient way of changing the values of the sparse
matrix, without changing the sparsity pattern.</p>
<p>When the attribute <a class="reference internal" href="#V" title="V"><tt class="xref py py-attr docutils literal"><span class="pre">V</span></tt></a> is read, a <em>copy</em> of <a class="reference internal" href="#V" title="V"><tt class="xref py py-attr docutils literal"><span class="pre">V</span></tt></a> is
returned, as a new dense matrix.  This implies, for example, that an
indexed assignment <tt class="docutils literal"><span class="pre">A.V[I]</span> <span class="pre">=</span> <span class="pre">B</span></tt> does not work, or at least
cannot be used to modify <tt class="docutils literal"><span class="pre">A</span></tt>.  Instead the attribute <a class="reference internal" href="#V" title="V"><tt class="xref py py-attr docutils literal"><span class="pre">V</span></tt></a>
will be read and returned as a new matrix; then the elements of this
new matrix are modified.</p>
</dd></dl>

<dl class="attribute">
<dt id="I">
<tt class="descname">I</tt><a class="headerlink" href="#I" title="Permalink to this definition">¶</a></dt>
<dd><p>A single-column integer dense matrix with the row indices of the
entries in <a class="reference internal" href="#V" title="V"><tt class="xref py py-attr docutils literal"><span class="pre">V</span></tt></a>.  A read-only attribute.</p>
</dd></dl>

<dl class="attribute">
<dt id="J">
<tt class="descname">J</tt><a class="headerlink" href="#J" title="Permalink to this definition">¶</a></dt>
<dd><p>A single-column integer dense matrix with the column indices of the
entries in <a class="reference internal" href="#V" title="V"><tt class="xref py py-attr docutils literal"><span class="pre">V</span></tt></a>.  A read-only attribute.</p>
</dd></dl>

<dl class="attribute">
<dt id="CCS">
<tt class="descname">CCS</tt><a class="headerlink" href="#CCS" title="Permalink to this definition">¶</a></dt>
<dd><p>A triplet (column pointers, row indices, values) with the
compressed-column-storage representation of the matrix.  A read-only
attribute.  This attribute can be used to export sparse matrices to
other packages such as MOSEK.</p>
</dd></dl>

<p>The next example below illustrates assignments to <a class="reference internal" href="#V" title="V"><tt class="xref py py-attr docutils literal"><span class="pre">V</span></tt></a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">spmatrix</span><span class="p">,</span> <span class="n">matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ 0.00e+00     0         0    ]</span>
<span class="go">[ 1.00e+00  2.00e+00     0    ]</span>
<span class="go">[    0      3.00e+00  4.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">J</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>  <span class="c"># transpose and add a zero row and column</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">[ 0.00e+00  1.00e+00     0         0    ]</span>
<span class="go">[    0      2.00e+00  3.00e+00     0    ]</span>
<span class="go">[    0         0      4.00e+00     0    ]</span>
<span class="go">[    0         0         0         0    ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">7.</span><span class="p">,</span> <span class="mf">8.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">])</span>   <span class="c"># assign new values to nonzero entries</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">[ 1.00e+00  7.00e+00     0         0    ]</span>
<span class="go">[    0      8.00e+00  6.00e+00     0    ]</span>
<span class="go">[    0         0      4.00e+00     0    ]</span>
<span class="go">[    0         0         0         0    ]</span>
</pre></div>
</div>
<p>The following attributes and methods are defined for dense matrices.</p>
<dl class="method">
<dt id="tofile">
<tt class="descname">tofile</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#tofile" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes the elements of the matrix in column-major order to a binary
file <tt class="docutils literal"><span class="pre">f</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="fromfile">
<tt class="descname">fromfile</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#fromfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the contents of a binary file <tt class="docutils literal"><span class="pre">f</span></tt> into the matrix object.</p>
</dd></dl>

<p>The last two methods are illustrated in the following examples.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">spmatrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">,</span><span class="mf">3.</span><span class="p">],</span> <span class="p">[</span><span class="mf">4.</span><span class="p">,</span><span class="mf">5.</span><span class="p">,</span><span class="mf">6.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ 1.00e+00  4.00e+00]</span>
<span class="go">[ 2.00e+00  5.00e+00]</span>
<span class="go">[ 3.00e+00  6.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;mat.bin&#39;</span><span class="p">,</span><span class="s">&#39;wb&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;mat.bin&#39;</span><span class="p">,</span><span class="s">&#39;rb&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">[ 1.00e+00  3.00e+00  5.00e+00]</span>
<span class="go">[ 2.00e+00  4.00e+00  6.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;test.bin&#39;</span><span class="p">,</span><span class="s">&#39;wb&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">V</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">I</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">J</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;test.bin&#39;</span><span class="p">,</span><span class="s">&#39;rb&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">V</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>  <span class="n">V</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>  <span class="n">I</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">J</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>  <span class="n">J</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">[ 0.00e+00     0         0    ]</span>
<span class="go">[ 1.00e+00  2.00e+00     0    ]</span>
<span class="go">[    0      3.00e+00  4.00e+00]</span>
</pre></div>
</div>
<p>Note that the <tt class="xref py py-func docutils literal"><span class="pre">dump</span></tt> and <tt class="xref py py-func docutils literal"><span class="pre">load</span></tt> functions in the <tt class="xref py py-mod docutils literal"><span class="pre">pickle</span></tt>
module offer a convenient alternative for writing matrices to files and
reading matrices from files.</p>
</div>
<div class="section" id="built-in-functions">
<h2>Built-In Functions<a class="headerlink" href="#built-in-functions" title="Permalink to this headline">¶</a></h2>
<p>Many Python built-in functions and operations can be used with matrix
arguments.  We list some useful examples.</p>
<dl class="function">
<dt id="len">
<tt class="descname">len</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#len" title="Permalink to this definition">¶</a></dt>
<dd><p>If <tt class="docutils literal"><span class="pre">x</span></tt> is a dense matrix, returns the product of the number of rows
and the number of columns.  If <tt class="docutils literal"><span class="pre">x</span></tt> is a sparse matrix, returns the
number of nonzero entries.</p>
</dd></dl>

<dl class="function">
<dt id="bool">
<tt class="descname">bool</tt><big>(</big><span class="optional">[</span><em>x</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#bool" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <tt class="xref py py-const docutils literal"><span class="pre">False</span></tt> if <tt class="docutils literal"><span class="pre">x</span></tt> is a zero matrix and <tt class="xref py py-const docutils literal"><span class="pre">True</span></tt>
otherwise.</p>
</dd></dl>

<dl class="function">
<dt id="max">
<tt class="descname">max</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#max" title="Permalink to this definition">¶</a></dt>
<dd><p>If <tt class="docutils literal"><span class="pre">x</span></tt> is a dense matrix, returns the maximum element of <tt class="docutils literal"><span class="pre">x</span></tt>.
If <tt class="docutils literal"><span class="pre">x</span></tt> is a sparse, returns the maximum nonzero element of <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="min">
<tt class="descname">min</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#min" title="Permalink to this definition">¶</a></dt>
<dd><p>If <tt class="docutils literal"><span class="pre">x</span></tt> is a dense matrix, returns the minimum element of <tt class="docutils literal"><span class="pre">x</span></tt>.
If <tt class="docutils literal"><span class="pre">x</span></tt> is a sparse matrix, returns the minimum nonzero element of
<tt class="docutils literal"><span class="pre">x</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="abs">
<tt class="descname">abs</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#abs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a matrix with the absolute values of the elements of <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="sum">
<tt class="descname">sum</tt><big>(</big><em>x</em><span class="optional">[</span>, <em>start = 0.0</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sum of <tt class="docutils literal"><span class="pre">start</span></tt> and the elements of <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
</dd></dl>

<p>Dense and sparse matrices can be used as  arguments to the <tt class="xref py py-func docutils literal"><span class="pre">list</span></tt>,
<tt class="xref py py-func docutils literal"><span class="pre">tuple</span></tt>, <tt class="xref py py-func docutils literal"><span class="pre">zip</span></tt>, <tt class="xref py py-func docutils literal"><span class="pre">map</span></tt>, and <tt class="xref py py-func docutils literal"><span class="pre">filter</span></tt> functions
described in the Python Library Reference.
However, one should note that when used with sparse matrix arguments,
these functions only consider the nonzero entries.
For example, <tt class="docutils literal"><span class="pre">list(A)</span></tt> and <tt class="docutils literal"><span class="pre">tuple(A)</span></tt> construct a list,
respectively a tuple, from the elements of <tt class="docutils literal"><span class="pre">A</span></tt> if <tt class="docutils literal"><span class="pre">A</span></tt> is dense, and
of the nonzero elements of <tt class="docutils literal"><span class="pre">A</span></tt> if <tt class="docutils literal"><span class="pre">A</span></tt> is sparse.</p>
<p><tt class="docutils literal"><span class="pre">list(zip(A,</span> <span class="pre">B,</span> <span class="pre">...))</span></tt> returns a list of tuples, with the i-th tuple
containing the i-th elements (or nonzero elements) of <tt class="docutils literal"><span class="pre">A</span></tt>, <tt class="docutils literal"><span class="pre">B</span></tt>, ....</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="o">-</span><span class="mf">11.</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.</span><span class="p">,</span> <span class="o">-</span><span class="mf">20.</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">6.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">7.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[-11.0, -5.0, -20.0, -6.0, 0.0, 7.0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">tuple</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">(0, 1, 2, 3, 4, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">))</span>
<span class="go">[(-11.0, 0), (-5.0, 1), (-20.0, 2), (-6.0, 3), (0.0, 4), (7.0, 5)]</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">list(map(f,</span> <span class="pre">A))</span></tt>, where <tt class="docutils literal"><span class="pre">f</span></tt> is a function and <tt class="docutils literal"><span class="pre">A</span></tt> is a
dense matrix, returns a list constructed by applying <tt class="docutils literal"><span class="pre">f</span></tt> to each
element of <tt class="docutils literal"><span class="pre">A</span></tt>.  If
<tt class="docutils literal"><span class="pre">A</span></tt> is sparse, the function <tt class="docutils literal"><span class="pre">f</span></tt> is applied to each nonzero element of
<tt class="docutils literal"><span class="pre">A</span></tt>.  Multiple arguments can be provided, for example, as in
<tt class="docutils literal"><span class="pre">map(f,</span> <span class="pre">A,</span> <span class="pre">B)</span></tt>, if <tt class="docutils literal"><span class="pre">f</span></tt> is a function with two arguments.
In the following example, we return an integer 0-1 matrix with the
result of an elementwise comparison.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[ 5.00e-01  1.50e+00  3.00e-01]</span>
<span class="go">[-1.00e-01  2.00e-01  1.00e+00]</span>
<span class="go">[ 2.00e+00 -1.00e-01  0.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">matrix</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">A</span><span class="p">),</span> <span class="n">A</span><span class="o">.</span><span class="n">size</span><span class="p">)))</span>
<span class="go">[ 1  0  1]</span>
<span class="go">[ 0  1  1]</span>
<span class="go">[ 0  0  1]</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">list(filter(f,</span> <span class="pre">A))</span></tt>, where <tt class="docutils literal"><span class="pre">f</span></tt> is a function and <tt class="docutils literal"><span class="pre">A</span></tt> is a matrix,
returns a list containing the elements of <tt class="docutils literal"><span class="pre">A</span></tt> (or nonzero elements of
<tt class="docutils literal"><span class="pre">A</span></tt> is <tt class="docutils literal"><span class="pre">A</span></tt> is sparse) for which <tt class="docutils literal"><span class="pre">f</span></tt> is true.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>  <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[  5  -1   6  -1]</span>
<span class="go">[ -4  -5   1   2]</span>
<span class="go">[ 10  -6   5  -3]</span>
<span class="go">[ -7   2   2  -7]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">%</span><span class="mi">2</span><span class="p">,</span> <span class="n">A</span><span class="p">))</span>         <span class="c"># list of odd elements in A</span>
<span class="go">[5, -7, -1, -5, 1, 5, -1, -3, -7]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">,</span> <span class="n">A</span><span class="p">))</span>  <span class="c"># list of elements between -2 and 3</span>
<span class="go">[-1, 2, 1, 2, -1, 2]</span>
</pre></div>
</div>
<p>It is also possible to iterate over matrix elements, as illustrated in
the following example.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span> <span class="k">print</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">5</span>
<span class="go">0</span>
<span class="go">9</span>
<span class="go">11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">A</span><span class="p">]</span>
<span class="go">[5, 0, 9, 11]</span>
</pre></div>
</div>
<p>The expression <tt class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">A</span></tt> returns <tt class="xref py py-const docutils literal"><span class="pre">True</span></tt> if an element
of <tt class="docutils literal"><span class="pre">A</span></tt> (or a nonzero element of <tt class="docutils literal"><span class="pre">A</span></tt> if <tt class="docutils literal"><span class="pre">A</span></tt> is sparse)
is equal to <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="xref py py-const docutils literal"><span class="pre">False</span></tt> otherwise.</p>
</div>
<div class="section" id="other-matrix-functions">
<h2>Other Matrix Functions<a class="headerlink" href="#other-matrix-functions" title="Permalink to this headline">¶</a></h2>
<p>The following functions can be imported from CVXOPT.</p>
<dl class="function">
<dt id="cvxopt.sqrt">
<tt class="descclassname">cvxopt.</tt><tt class="descname">sqrt</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#cvxopt.sqrt" title="Permalink to this definition">¶</a></dt>
<dd><p>The elementwise square root of a dense matrix <tt class="docutils literal"><span class="pre">x</span></tt>.  The result is
returned as a real matrix if <tt class="docutils literal"><span class="pre">x</span></tt> is an integer or real matrix and
as a complex matrix if <tt class="docutils literal"><span class="pre">x</span></tt> is a complex matrix.  Raises an exception
when <tt class="docutils literal"><span class="pre">x</span></tt> is an integer or real matrix with negative elements.</p>
<p>As an example we take the elementwise square root of the sparse matrix</p>
<div class="math">
<p><img src="_images/math/c782f1372833e05dd58ec611408b936a86c85c7d.png" alt="A = \left[ \begin{array}{rrrrr}
    0 &amp; 2 &amp; 0 &amp; 0 &amp; 3 \\
    2 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    1 &amp; 2 &amp; 0 &amp; 4 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \end{array} \right]"/></p>
</div><div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">spmatrix</span><span class="p">,</span> <span class="n">sqrt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">V</span><span class="p">),</span> <span class="n">A</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">J</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">[    0      1.41e+00     0      1.73e+00]</span>
<span class="go">[ 1.41e+00     0         0         0    ]</span>
<span class="go">[ 1.00e+00  1.41e+00     0      2.00e+00]</span>
<span class="go">[    0         0      1.00e+00     0    ]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cvxopt.sin">
<tt class="descclassname">cvxopt.</tt><tt class="descname">sin</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#cvxopt.sin" title="Permalink to this definition">¶</a></dt>
<dd><p>The sine function applied elementwise to a dense matrix <tt class="docutils literal"><span class="pre">x</span></tt>.
The result is returned as a real matrix if <tt class="docutils literal"><span class="pre">x</span></tt> is an integer
or real matrix and as a complex matrix otherwise.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.cos">
<tt class="descclassname">cvxopt.</tt><tt class="descname">cos</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#cvxopt.cos" title="Permalink to this definition">¶</a></dt>
<dd><p>The cosine function applied elementwise to a dense matrix <tt class="docutils literal"><span class="pre">x</span></tt>.
The result is returned as a real matrix if <tt class="docutils literal"><span class="pre">x</span></tt> is an integer
or real matrix and as a complex matrix otherwise.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.exp">
<tt class="descclassname">cvxopt.</tt><tt class="descname">exp</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#cvxopt.exp" title="Permalink to this definition">¶</a></dt>
<dd><p>The exponential function applied elementwise to a dense matrix <tt class="docutils literal"><span class="pre">x</span></tt>.
The result is returned as a real matrix if <tt class="docutils literal"><span class="pre">x</span></tt> is an integer
or real matrix and as a complex matrix otherwise.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.log">
<tt class="descclassname">cvxopt.</tt><tt class="descname">log</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#cvxopt.log" title="Permalink to this definition">¶</a></dt>
<dd><p>The natural logarithm applied elementwise to a dense matrix <tt class="docutils literal"><span class="pre">x</span></tt>.
The result is returned as a real matrix if <tt class="docutils literal"><span class="pre">x</span></tt> is an integer
or real matrix and as a complex matrix otherwise.
Raises an exception when <tt class="docutils literal"><span class="pre">x</span></tt> is an integer or real matrix with
nonpositive elements, or a complex matrix with zero elements.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.mul">
<tt class="descclassname">cvxopt.</tt><tt class="descname">mul</tt><big>(</big><em>x0</em><span class="optional">[</span>, <em>x1</em><span class="optional">[</span>, <em>x2 ...</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#cvxopt.mul" title="Permalink to this definition">¶</a></dt>
<dd><p>If the arguments are dense or sparse matrices of the same size, returns
the elementwise product of its arguments.  The result is a sparse
matrix if one or more of its arguments is sparse, and a dense matrix
otherwise.</p>
<p>If the arguments include scalars, a scalar product with the scalar is
made.  (A 1 by 1 dense matrix is treated as a scalar if the dimensions
of the other arguments are not all 1 by 1.)</p>
<p><tt class="xref py py-func docutils literal"><span class="pre">mul</span></tt> can also be called with an iterable
(list, tuple, range object, or generator) as its single argument,
if the iterable generates a list of dense or sparse matrices or
scalars.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">spmatrix</span><span class="p">,</span> <span class="n">mul</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">([</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">mul</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">))</span>
<span class="go">[-2.00e+00     0    ]</span>
<span class="go">[    0     -1.20e+01]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">mul</span><span class="p">(</span> <span class="n">matrix</span><span class="p">([</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">))</span>
<span class="go">[  6]</span>
<span class="go">[ 24]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cvxopt.div">
<tt class="descclassname">cvxopt.</tt><tt class="descname">div</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#cvxopt.div" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the elementwise division of <tt class="docutils literal"><span class="pre">x</span></tt> by <tt class="docutils literal"><span class="pre">y</span></tt>.  <tt class="docutils literal"><span class="pre">x</span></tt> is a dense
or sparse matrix, or a scalar (Python number of 1 by 1 dense matrix).
<tt class="docutils literal"><span class="pre">y</span></tt> is a dense matrix or a scalar.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.max">
<tt class="descclassname">cvxopt.</tt><tt class="descname">max</tt><big>(</big><em>x0</em><span class="optional">[</span>, <em>x1</em><span class="optional">[</span>, <em>x2 ...</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#cvxopt.max" title="Permalink to this definition">¶</a></dt>
<dd><p>When called with a single matrix argument, returns the maximum of the
elements of the matrix (including the zero entries, if the matrix is
sparse).</p>
<p>When called with multiple arguments, the arguments must be matrices of
the same size, or scalars, and the elementwise maximum is returned.
A 1 by 1 dense matrix is treated as a scalar if the other arguments
are not all 1 by 1.  If one of the arguments is scalar, and the other
arguments are not all 1 by 1, then the scalar argument is interpreted
as a dense matrix with all its entries equal to the scalar.</p>
<p>The result is a sparse matrix if all its arguments are sparse matrices.
The result is a number if all its arguments are numbers.  The result
is a dense matrix if at least one of the arguments is a dense matrix.</p>
<p><a class="reference internal" href="#cvxopt.max" title="cvxopt.max"><tt class="xref py py-func docutils literal"><span class="pre">max</span></tt></a> can also be called with an iterable
(list, tuple, range object, or generator) as its single argument,
if the iterable generates a list of dense or sparse matrices or
scalars.
&gt;&gt;&gt; from cvxopt import matrix, spmatrix, max
&gt;&gt;&gt; A = spmatrix([2, -3], [0, 1], [0, 1])
&gt;&gt;&gt; print(max(A, -A, 1))
[ 2.00e+00  1.00e+00]
[ 1.00e+00  3.00e+00]</p>
<p>It is important to note the difference between this
<a class="reference internal" href="#cvxopt.max" title="cvxopt.max"><tt class="xref py py-func docutils literal"><span class="pre">max</span></tt></a>
and the built-in <a class="reference internal" href="#max" title="max"><tt class="xref py py-func docutils literal"><span class="pre">max</span></tt></a>, explained in the previous section.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">spmatrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">spmatrix</span><span class="p">([</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>          <span class="c"># built-in max of a sparse matrix takes maximum over nonzero elements</span>
<span class="go">-1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.5</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">NotImplementedError</span>: <span class="n">matrix comparison not implemented</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="nb">max</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>          <span class="c"># cvxopt.max takes maximum over all the  elements</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.5</span><span class="p">))</span>
<span class="go">[-1.00e+00  0.00e+00]</span>
<span class="go">[ 0.00e+00 -1.50e+00]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cvxopt.min">
<tt class="descclassname">cvxopt.</tt><tt class="descname">min</tt><big>(</big><em>x0</em><span class="optional">[</span>, <em>x1</em><span class="optional">[</span>, <em>x2 ...</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#cvxopt.min" title="Permalink to this definition">¶</a></dt>
<dd><p>When called with a single matrix argument, returns the minimum of the
elements of the matrix (including the zero entries, if the matrix is
sparse).</p>
<p>When called with multiple arguments, the arguments must be matrices of
the same size, or scalars, and the elementwise maximum is returned.
A 1 by 1 dense matrix is treated as a scalar if the other arguments
are not all 1 by 1.  If one of the arguments is scalar, and the other
arguments are not all 1 by 1, then the scalar argument is interpreted
as a dense matrix with all its entries equal to the scalar.</p>
<p><a class="reference internal" href="#cvxopt.min" title="cvxopt.min"><tt class="xref py py-func docutils literal"><span class="pre">min</span></tt></a> can also be called with an iterable
(list, tuple, range object, or generator) as its single argument,
if the iterable generates a list of dense or sparse matrices or
scalars.</p>
</dd></dl>

</div>
<div class="section" id="randomly-generated-matrices">
<span id="s-random"></span><h2>Randomly Generated Matrices<a class="headerlink" href="#randomly-generated-matrices" title="Permalink to this headline">¶</a></h2>
<p>The CVXOPT package provides two functions
<a class="reference internal" href="#cvxopt.normal" title="cvxopt.normal"><tt class="xref py py-func docutils literal"><span class="pre">normal</span></tt></a> and
<a class="reference internal" href="#cvxopt.uniform" title="cvxopt.uniform"><tt class="xref py py-func docutils literal"><span class="pre">uniform</span></tt></a> for generating randomly distributed
matrices.
The default installation relies on the pseudo-random number generators in
the Python standard library <tt class="xref py py-mod docutils literal"><span class="pre">random</span></tt>.  Alternatively, the random
number generators in the
<a class="reference external" href="http://www.gnu.org/software/gsl">GNU Scientific Library (GSL)</a>
can be used, if this option is selected during the installation of CVXOPT.
The random matrix functions based on GSL are faster than the default
functions based on the <tt class="xref py py-mod docutils literal"><span class="pre">random</span></tt> module.</p>
<dl class="function">
<dt id="cvxopt.normal">
<tt class="descclassname">cvxopt.</tt><tt class="descname">normal</tt><big>(</big><em>nrows</em><span class="optional">[</span>, <em>ncols = 1</em><span class="optional">[</span>, <em>mean = 0.0</em><span class="optional">[</span>, <em>std = 1.0</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#cvxopt.normal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a type <tt class="xref py py-const docutils literal"><span class="pre">'d'</span></tt> dense matrix of size <tt class="docutils literal"><span class="pre">nrows</span></tt>  by
<tt class="docutils literal"><span class="pre">ncols</span></tt> with elements chosen from a normal distribution
with mean <tt class="docutils literal"><span class="pre">mean</span></tt> and standard deviation <tt class="docutils literal"><span class="pre">std</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.uniform">
<tt class="descclassname">cvxopt.</tt><tt class="descname">uniform</tt><big>(</big><em>nrows</em><span class="optional">[</span>, <em>ncols = 1</em><span class="optional">[</span>, <em>a = 0.0</em><span class="optional">[</span>, <em>b = 1.0</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#cvxopt.uniform" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a type <tt class="xref py py-const docutils literal"><span class="pre">'d'</span></tt> dense matrix of size <tt class="docutils literal"><span class="pre">nrows</span></tt> by
<tt class="docutils literal"><span class="pre">ncols</span></tt> matrix with elements uniformly distributed between <tt class="docutils literal"><span class="pre">a</span></tt> and
<tt class="docutils literal"><span class="pre">b</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.setseed">
<tt class="descclassname">cvxopt.</tt><tt class="descname">setseed</tt><big>(</big><span class="optional">[</span><em>value</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#cvxopt.setseed" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the state of the random number generator.  <tt class="docutils literal"><span class="pre">value</span></tt> must be an
integer.  If <tt class="docutils literal"><span class="pre">value</span></tt> is absent or equal to zero, the value is taken
from the system clock.  If the Python random number generators are
used, this is equivalent to <tt class="samp docutils literal"><span class="pre">random.seed(value)</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="cvxopt.getseed">
<tt class="descclassname">cvxopt.</tt><tt class="descname">getseed</tt><big>(</big><big>)</big><a class="headerlink" href="#cvxopt.getseed" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current state of the random number generator.  This
function is only available if the GSL random number generators are
installed.   (The state of the random number generators in the Python
<tt class="xref py py-mod docutils literal"><span class="pre">random</span></tt> module can be managed via the functions
<tt class="xref py py-func docutils literal"><span class="pre">random.getstate</span></tt> and <tt class="xref py py-func docutils literal"><span class="pre">random.setstate</span></tt>.)</p>
</dd></dl>

</div>
<div class="section" id="the-numpy-array-interface">
<span id="s-array-interface"></span><h2>The NumPy Array Interface<a class="headerlink" href="#the-numpy-array-interface" title="Permalink to this headline">¶</a></h2>
<p>This section only applies to the Python 2 version of CVXOPT.</p>
<p>The CVXOPT <tt class="xref py py-class docutils literal"><span class="pre">matrix</span></tt> object is compatible with the NumPy Array
Interface, which allows Python objects that represent multidimensional
arrays to exchange data using information stored in the attribute
<tt class="xref py py-attr docutils literal"><span class="pre">__array_struct__</span></tt>.</p>
<p>As already mentioned in the section <a class="reference internal" href="#s-dense-matrices"><em>Dense Matrices</em></a>, a
two-dimensional array
object (for example, a NumPy matrix or two-dimensional array) can be
converted to a CVXOPT <tt class="xref py py-class docutils literal"><span class="pre">matrix</span></tt> object by using
the <a class="reference internal" href="#cvxopt.matrix" title="cvxopt.matrix"><tt class="xref py py-func docutils literal"><span class="pre">matrix</span></tt></a> constructor.
Conversely, CVXOPT matrices can be used as array-like
objects in NumPy.  The following example illustrates the compatibility of
CVXOPT matrices and NumPy arrays.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cvxopt</span> <span class="kn">import</span> <span class="n">matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="s">&#39;d&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">[ 0.00e+00  2.00e+00  4.00e+00]</span>
<span class="go">[ 1.00e+00  3.00e+00  5.00e+00]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([[ 0.  2.  4.]</span>
<span class="go">       [ 1.  3.  5.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">*</span><span class="n">b</span>
<span class="go">array([[  0.   4.  16.]</span>
<span class="go">       [  1.   9.  25.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">mat</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">mat</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">matrix([[ 0.  2.  4.]</span>
<span class="go">        [ 1.  3.  5.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">c</span>
<span class="go">matrix([[  1.,   3.,   5.],</span>
<span class="go">        [  3.,  13.,  23.],</span>
<span class="go">        [  5.,  23.,  41.]])</span>
</pre></div>
</div>
<p>In the first product, <tt class="docutils literal"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">b</span></tt> is interpreted as NumPy array
multiplication, i.e., componentwise multiplication.
The second product <tt class="docutils literal"><span class="pre">a.T</span> <span class="pre">*</span> <span class="pre">c</span></tt> is interpreted as NumPy matrix
multiplication, i.e., standard matrix multiplication.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Dense and Sparse Matrices</a><ul>
<li><a class="reference internal" href="#dense-matrices">Dense Matrices</a></li>
<li><a class="reference internal" href="#sparse-matrices">Sparse Matrices</a></li>
<li><a class="reference internal" href="#arithmetic-operations">Arithmetic Operations</a></li>
<li><a class="reference internal" href="#indexing-and-slicing">Indexing and Slicing</a></li>
<li><a class="reference internal" href="#attributes-and-methods">Attributes and Methods</a></li>
<li><a class="reference internal" href="#built-in-functions">Built-In Functions</a></li>
<li><a class="reference internal" href="#other-matrix-functions">Other Matrix Functions</a></li>
<li><a class="reference internal" href="#randomly-generated-matrices">Randomly Generated Matrices</a></li>
<li><a class="reference internal" href="#the-numpy-array-interface">The NumPy Array Interface</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="intro.html"
                        title="previous chapter">Introduction</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="blas.html"
                        title="next chapter">The BLAS Interface</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="blas.html" title="The BLAS Interface"
             >next</a></li>
        <li class="right" >
          <a href="intro.html" title="Introduction"
             >previous</a> |</li>
    <li><a href="http://cvxopt.org">CVXOPT home</a> |</li>
    
        <li><a href="index.html">user&#39;s guide</a> </li>
 
      </ul>
    </div>
    <div class="footer">
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>